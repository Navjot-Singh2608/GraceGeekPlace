/* Copyright (C) 2007-2015, GoodData(R) Corporation. All rights reserved. */
/* @gooddata/gooddata-js - v13.0.4 */
/* 2020-07-16 13:37:56 */
/* Latest git commit: "a759579" */


(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else if(typeof exports === 'object')
		exports["gooddata"] = factory();
	else
		root["gooddata"] = factory();
})(this, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};

/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {

/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;

/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};

/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);

/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;

/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}


/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;

/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;

/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";

/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	function __export(m) {
	    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
	}
	var __importStar = (this && this.__importStar) || function (mod) {
	    if (mod && mod.__esModule) return mod;
	    var result = {};
	    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
	    result["default"] = mod;
	    return result;
	};
	Object.defineProperty(exports, "__esModule", { value: true });
	// (C) 2007-2020 GoodData Corporation
	__webpack_require__(1);
	var gooddata_1 = __webpack_require__(3);
	exports.SDK = gooddata_1.SDK;
	var xhr_1 = __webpack_require__(48);
	exports.ApiResponse = xhr_1.ApiResponse;
	exports.ApiResponseError = xhr_1.ApiResponseError;
	exports.ApiNetworkError = xhr_1.ApiNetworkError;
	var execute_afm_1 = __webpack_require__(184);
	exports.ApiExecutionResponseError = execute_afm_1.ApiExecutionResponseError;
	var referenceHandling = __importStar(__webpack_require__(116));
	exports.referenceHandling = referenceHandling;
	var DataLayer = __importStar(__webpack_require__(209));
	exports.DataLayer = DataLayer;
	var TypeGuards = __importStar(__webpack_require__(267));
	exports.TypeGuards = TypeGuards;
	var factoryBrowser = gooddata_1.factory(fetch.bind(window));
	exports.factory = factoryBrowser;
	__export(__webpack_require__(268));
	exports.default = factoryBrowser();


/***/ }),
/* 1 */
/***/ (function(module, exports, __webpack_require__) {

	// the whatwg-fetch polyfill installs the fetch() function
	// on the global object (window or self)
	//
	// Return that as the export for use in Webpack, Browserify etc.
	__webpack_require__(2);
	module.exports = self.fetch.bind(self);


/***/ }),
/* 2 */
/***/ (function(module, exports, __webpack_require__) {

	(function (global, factory) {
	   true ? factory(exports) :
	  typeof define === 'function' && define.amd ? define(['exports'], factory) :
	  (factory((global.WHATWGFetch = {})));
	}(this, (function (exports) { 'use strict';

	  var support = {
	    searchParams: 'URLSearchParams' in self,
	    iterable: 'Symbol' in self && 'iterator' in Symbol,
	    blob:
	      'FileReader' in self &&
	      'Blob' in self &&
	      (function() {
	        try {
	          new Blob();
	          return true
	        } catch (e) {
	          return false
	        }
	      })(),
	    formData: 'FormData' in self,
	    arrayBuffer: 'ArrayBuffer' in self
	  };

	  function isDataView(obj) {
	    return obj && DataView.prototype.isPrototypeOf(obj)
	  }

	  if (support.arrayBuffer) {
	    var viewClasses = [
	      '[object Int8Array]',
	      '[object Uint8Array]',
	      '[object Uint8ClampedArray]',
	      '[object Int16Array]',
	      '[object Uint16Array]',
	      '[object Int32Array]',
	      '[object Uint32Array]',
	      '[object Float32Array]',
	      '[object Float64Array]'
	    ];

	    var isArrayBufferView =
	      ArrayBuffer.isView ||
	      function(obj) {
	        return obj && viewClasses.indexOf(Object.prototype.toString.call(obj)) > -1
	      };
	  }

	  function normalizeName(name) {
	    if (typeof name !== 'string') {
	      name = String(name);
	    }
	    if (/[^a-z0-9\-#$%&'*+.^_`|~]/i.test(name)) {
	      throw new TypeError('Invalid character in header field name')
	    }
	    return name.toLowerCase()
	  }

	  function normalizeValue(value) {
	    if (typeof value !== 'string') {
	      value = String(value);
	    }
	    return value
	  }

	  // Build a destructive iterator for the value list
	  function iteratorFor(items) {
	    var iterator = {
	      next: function() {
	        var value = items.shift();
	        return {done: value === undefined, value: value}
	      }
	    };

	    if (support.iterable) {
	      iterator[Symbol.iterator] = function() {
	        return iterator
	      };
	    }

	    return iterator
	  }

	  function Headers(headers) {
	    this.map = {};

	    if (headers instanceof Headers) {
	      headers.forEach(function(value, name) {
	        this.append(name, value);
	      }, this);
	    } else if (Array.isArray(headers)) {
	      headers.forEach(function(header) {
	        this.append(header[0], header[1]);
	      }, this);
	    } else if (headers) {
	      Object.getOwnPropertyNames(headers).forEach(function(name) {
	        this.append(name, headers[name]);
	      }, this);
	    }
	  }

	  Headers.prototype.append = function(name, value) {
	    name = normalizeName(name);
	    value = normalizeValue(value);
	    var oldValue = this.map[name];
	    this.map[name] = oldValue ? oldValue + ', ' + value : value;
	  };

	  Headers.prototype['delete'] = function(name) {
	    delete this.map[normalizeName(name)];
	  };

	  Headers.prototype.get = function(name) {
	    name = normalizeName(name);
	    return this.has(name) ? this.map[name] : null
	  };

	  Headers.prototype.has = function(name) {
	    return this.map.hasOwnProperty(normalizeName(name))
	  };

	  Headers.prototype.set = function(name, value) {
	    this.map[normalizeName(name)] = normalizeValue(value);
	  };

	  Headers.prototype.forEach = function(callback, thisArg) {
	    for (var name in this.map) {
	      if (this.map.hasOwnProperty(name)) {
	        callback.call(thisArg, this.map[name], name, this);
	      }
	    }
	  };

	  Headers.prototype.keys = function() {
	    var items = [];
	    this.forEach(function(value, name) {
	      items.push(name);
	    });
	    return iteratorFor(items)
	  };

	  Headers.prototype.values = function() {
	    var items = [];
	    this.forEach(function(value) {
	      items.push(value);
	    });
	    return iteratorFor(items)
	  };

	  Headers.prototype.entries = function() {
	    var items = [];
	    this.forEach(function(value, name) {
	      items.push([name, value]);
	    });
	    return iteratorFor(items)
	  };

	  if (support.iterable) {
	    Headers.prototype[Symbol.iterator] = Headers.prototype.entries;
	  }

	  function consumed(body) {
	    if (body.bodyUsed) {
	      return Promise.reject(new TypeError('Already read'))
	    }
	    body.bodyUsed = true;
	  }

	  function fileReaderReady(reader) {
	    return new Promise(function(resolve, reject) {
	      reader.onload = function() {
	        resolve(reader.result);
	      };
	      reader.onerror = function() {
	        reject(reader.error);
	      };
	    })
	  }

	  function readBlobAsArrayBuffer(blob) {
	    var reader = new FileReader();
	    var promise = fileReaderReady(reader);
	    reader.readAsArrayBuffer(blob);
	    return promise
	  }

	  function readBlobAsText(blob) {
	    var reader = new FileReader();
	    var promise = fileReaderReady(reader);
	    reader.readAsText(blob);
	    return promise
	  }

	  function readArrayBufferAsText(buf) {
	    var view = new Uint8Array(buf);
	    var chars = new Array(view.length);

	    for (var i = 0; i < view.length; i++) {
	      chars[i] = String.fromCharCode(view[i]);
	    }
	    return chars.join('')
	  }

	  function bufferClone(buf) {
	    if (buf.slice) {
	      return buf.slice(0)
	    } else {
	      var view = new Uint8Array(buf.byteLength);
	      view.set(new Uint8Array(buf));
	      return view.buffer
	    }
	  }

	  function Body() {
	    this.bodyUsed = false;

	    this._initBody = function(body) {
	      this._bodyInit = body;
	      if (!body) {
	        this._bodyText = '';
	      } else if (typeof body === 'string') {
	        this._bodyText = body;
	      } else if (support.blob && Blob.prototype.isPrototypeOf(body)) {
	        this._bodyBlob = body;
	      } else if (support.formData && FormData.prototype.isPrototypeOf(body)) {
	        this._bodyFormData = body;
	      } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
	        this._bodyText = body.toString();
	      } else if (support.arrayBuffer && support.blob && isDataView(body)) {
	        this._bodyArrayBuffer = bufferClone(body.buffer);
	        // IE 10-11 can't handle a DataView body.
	        this._bodyInit = new Blob([this._bodyArrayBuffer]);
	      } else if (support.arrayBuffer && (ArrayBuffer.prototype.isPrototypeOf(body) || isArrayBufferView(body))) {
	        this._bodyArrayBuffer = bufferClone(body);
	      } else {
	        this._bodyText = body = Object.prototype.toString.call(body);
	      }

	      if (!this.headers.get('content-type')) {
	        if (typeof body === 'string') {
	          this.headers.set('content-type', 'text/plain;charset=UTF-8');
	        } else if (this._bodyBlob && this._bodyBlob.type) {
	          this.headers.set('content-type', this._bodyBlob.type);
	        } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
	          this.headers.set('content-type', 'application/x-www-form-urlencoded;charset=UTF-8');
	        }
	      }
	    };

	    if (support.blob) {
	      this.blob = function() {
	        var rejected = consumed(this);
	        if (rejected) {
	          return rejected
	        }

	        if (this._bodyBlob) {
	          return Promise.resolve(this._bodyBlob)
	        } else if (this._bodyArrayBuffer) {
	          return Promise.resolve(new Blob([this._bodyArrayBuffer]))
	        } else if (this._bodyFormData) {
	          throw new Error('could not read FormData body as blob')
	        } else {
	          return Promise.resolve(new Blob([this._bodyText]))
	        }
	      };

	      this.arrayBuffer = function() {
	        if (this._bodyArrayBuffer) {
	          return consumed(this) || Promise.resolve(this._bodyArrayBuffer)
	        } else {
	          return this.blob().then(readBlobAsArrayBuffer)
	        }
	      };
	    }

	    this.text = function() {
	      var rejected = consumed(this);
	      if (rejected) {
	        return rejected
	      }

	      if (this._bodyBlob) {
	        return readBlobAsText(this._bodyBlob)
	      } else if (this._bodyArrayBuffer) {
	        return Promise.resolve(readArrayBufferAsText(this._bodyArrayBuffer))
	      } else if (this._bodyFormData) {
	        throw new Error('could not read FormData body as text')
	      } else {
	        return Promise.resolve(this._bodyText)
	      }
	    };

	    if (support.formData) {
	      this.formData = function() {
	        return this.text().then(decode)
	      };
	    }

	    this.json = function() {
	      return this.text().then(JSON.parse)
	    };

	    return this
	  }

	  // HTTP methods whose capitalization should be normalized
	  var methods = ['DELETE', 'GET', 'HEAD', 'OPTIONS', 'POST', 'PUT'];

	  function normalizeMethod(method) {
	    var upcased = method.toUpperCase();
	    return methods.indexOf(upcased) > -1 ? upcased : method
	  }

	  function Request(input, options) {
	    options = options || {};
	    var body = options.body;

	    if (input instanceof Request) {
	      if (input.bodyUsed) {
	        throw new TypeError('Already read')
	      }
	      this.url = input.url;
	      this.credentials = input.credentials;
	      if (!options.headers) {
	        this.headers = new Headers(input.headers);
	      }
	      this.method = input.method;
	      this.mode = input.mode;
	      this.signal = input.signal;
	      if (!body && input._bodyInit != null) {
	        body = input._bodyInit;
	        input.bodyUsed = true;
	      }
	    } else {
	      this.url = String(input);
	    }

	    this.credentials = options.credentials || this.credentials || 'same-origin';
	    if (options.headers || !this.headers) {
	      this.headers = new Headers(options.headers);
	    }
	    this.method = normalizeMethod(options.method || this.method || 'GET');
	    this.mode = options.mode || this.mode || null;
	    this.signal = options.signal || this.signal;
	    this.referrer = null;

	    if ((this.method === 'GET' || this.method === 'HEAD') && body) {
	      throw new TypeError('Body not allowed for GET or HEAD requests')
	    }
	    this._initBody(body);
	  }

	  Request.prototype.clone = function() {
	    return new Request(this, {body: this._bodyInit})
	  };

	  function decode(body) {
	    var form = new FormData();
	    body
	      .trim()
	      .split('&')
	      .forEach(function(bytes) {
	        if (bytes) {
	          var split = bytes.split('=');
	          var name = split.shift().replace(/\+/g, ' ');
	          var value = split.join('=').replace(/\+/g, ' ');
	          form.append(decodeURIComponent(name), decodeURIComponent(value));
	        }
	      });
	    return form
	  }

	  function parseHeaders(rawHeaders) {
	    var headers = new Headers();
	    // Replace instances of \r\n and \n followed by at least one space or horizontal tab with a space
	    // https://tools.ietf.org/html/rfc7230#section-3.2
	    var preProcessedHeaders = rawHeaders.replace(/\r?\n[\t ]+/g, ' ');
	    preProcessedHeaders.split(/\r?\n/).forEach(function(line) {
	      var parts = line.split(':');
	      var key = parts.shift().trim();
	      if (key) {
	        var value = parts.join(':').trim();
	        headers.append(key, value);
	      }
	    });
	    return headers
	  }

	  Body.call(Request.prototype);

	  function Response(bodyInit, options) {
	    if (!options) {
	      options = {};
	    }

	    this.type = 'default';
	    this.status = options.status === undefined ? 200 : options.status;
	    this.ok = this.status >= 200 && this.status < 300;
	    this.statusText = 'statusText' in options ? options.statusText : 'OK';
	    this.headers = new Headers(options.headers);
	    this.url = options.url || '';
	    this._initBody(bodyInit);
	  }

	  Body.call(Response.prototype);

	  Response.prototype.clone = function() {
	    return new Response(this._bodyInit, {
	      status: this.status,
	      statusText: this.statusText,
	      headers: new Headers(this.headers),
	      url: this.url
	    })
	  };

	  Response.error = function() {
	    var response = new Response(null, {status: 0, statusText: ''});
	    response.type = 'error';
	    return response
	  };

	  var redirectStatuses = [301, 302, 303, 307, 308];

	  Response.redirect = function(url, status) {
	    if (redirectStatuses.indexOf(status) === -1) {
	      throw new RangeError('Invalid status code')
	    }

	    return new Response(null, {status: status, headers: {location: url}})
	  };

	  exports.DOMException = self.DOMException;
	  try {
	    new exports.DOMException();
	  } catch (err) {
	    exports.DOMException = function(message, name) {
	      this.message = message;
	      this.name = name;
	      var error = Error(message);
	      this.stack = error.stack;
	    };
	    exports.DOMException.prototype = Object.create(Error.prototype);
	    exports.DOMException.prototype.constructor = exports.DOMException;
	  }

	  function fetch(input, init) {
	    return new Promise(function(resolve, reject) {
	      var request = new Request(input, init);

	      if (request.signal && request.signal.aborted) {
	        return reject(new exports.DOMException('Aborted', 'AbortError'))
	      }

	      var xhr = new XMLHttpRequest();

	      function abortXhr() {
	        xhr.abort();
	      }

	      xhr.onload = function() {
	        var options = {
	          status: xhr.status,
	          statusText: xhr.statusText,
	          headers: parseHeaders(xhr.getAllResponseHeaders() || '')
	        };
	        options.url = 'responseURL' in xhr ? xhr.responseURL : options.headers.get('X-Request-URL');
	        var body = 'response' in xhr ? xhr.response : xhr.responseText;
	        resolve(new Response(body, options));
	      };

	      xhr.onerror = function() {
	        reject(new TypeError('Network request failed'));
	      };

	      xhr.ontimeout = function() {
	        reject(new TypeError('Network request failed'));
	      };

	      xhr.onabort = function() {
	        reject(new exports.DOMException('Aborted', 'AbortError'));
	      };

	      xhr.open(request.method, request.url, true);

	      if (request.credentials === 'include') {
	        xhr.withCredentials = true;
	      } else if (request.credentials === 'omit') {
	        xhr.withCredentials = false;
	      }

	      if ('responseType' in xhr && support.blob) {
	        xhr.responseType = 'blob';
	      }

	      request.headers.forEach(function(value, name) {
	        xhr.setRequestHeader(name, value);
	      });

	      if (request.signal) {
	        request.signal.addEventListener('abort', abortXhr);

	        xhr.onreadystatechange = function() {
	          // DONE (success or failure)
	          if (xhr.readyState === 4) {
	            request.signal.removeEventListener('abort', abortXhr);
	          }
	        };
	      }

	      xhr.send(typeof request._bodyInit === 'undefined' ? null : request._bodyInit);
	    })
	  }

	  fetch.polyfill = true;

	  if (!self.fetch) {
	    self.fetch = fetch;
	    self.Headers = Headers;
	    self.Request = Request;
	    self.Response = Response;
	  }

	  exports.Headers = Headers;
	  exports.Request = Request;
	  exports.Response = Response;
	  exports.fetch = fetch;

	  Object.defineProperty(exports, '__esModule', { value: true });

	})));


/***/ }),
/* 3 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var __importDefault = (this && this.__importDefault) || function (mod) {
	    return (mod && mod.__esModule) ? mod : { "default": mod };
	};
	Object.defineProperty(exports, "__esModule", { value: true });
	// (C) 2007-2020 GoodData Corporation
	var cloneDeep_1 = __importDefault(__webpack_require__(4));
	var xhr_1 = __webpack_require__(48);
	var user_1 = __webpack_require__(93);
	var metadata_1 = __webpack_require__(100);
	var execution_1 = __webpack_require__(147);
	var project_1 = __webpack_require__(94);
	var report_1 = __webpack_require__(189);
	var dashboard_1 = __webpack_require__(193);
	var config_1 = __webpack_require__(194);
	var catalogue_1 = __webpack_require__(195);
	var admin_1 = __webpack_require__(196);
	var attributesMapLoader_1 = __webpack_require__(182);
	var visualizationObjectHelper_1 = __webpack_require__(183);
	var referenceHandling_1 = __webpack_require__(116);
	var metadataExt_1 = __webpack_require__(206);
	var bootstrap_1 = __webpack_require__(208);
	/**
	 * # JS SDK
	 * Here is a set of functions that mostly are a thin wraper over the [GoodData API](https://developer.gooddata.com/api).
	 * Before calling any of those functions, you need to authenticate with a valid GoodData
	 * user credentials. After that, every subsequent call in the current session is authenticated.
	 * You can find more about the GD authentication mechanism here.
	 *
	 * ## GD Authentication Mechansim
	 * In this JS SDK library we provide you with a simple `login(username, passwd)` function
	 * that does the magic for you.
	 * To fully understand the authentication mechansim, please read
	 * [Authentication via API article](http://developer.gooddata.com/article/authentication-via-api)
	 * on [GoodData Developer Portal](http://developer.gooddata.com/)
	 *
	 * @module sdk
	 * @class sdk
	 */
	var SDK = /** @class */ (function () {
	    function SDK(fetchMethod, config) {
	        if (config === void 0) { config = {}; }
	        this.fetchMethod = fetchMethod;
	        this.configStorage = config_1.sanitizeConfig(config); // must be plain object, SDK modules MUST use this storage
	        this.config = new config_1.ConfigModule(this.configStorage);
	        this.xhr = new xhr_1.XhrModule(fetchMethod, this.configStorage);
	        this.user = new user_1.UserModule(this.xhr);
	        this.md = new metadata_1.MetadataModule(this.xhr);
	        this.mdExt = new metadataExt_1.MetadataModuleExt(this.xhr);
	        this.execution = new execution_1.ExecutionModule(this.xhr, this.md);
	        this.project = new project_1.ProjectModule(this.xhr);
	        this.report = new report_1.ReportModule(this.xhr);
	        this.dashboard = new dashboard_1.DashboardModule(this.xhr);
	        this.catalogue = new catalogue_1.CatalogueModule(this.xhr, this.execution);
	        this.admin = new admin_1.AdminModule(this.xhr);
	        this.bootstrap = new bootstrap_1.BootstrapModule(this.xhr);
	        var attributesMapLoaderModule = new attributesMapLoader_1.AttributesMapLoaderModule(this.md);
	        this.utils = {
	            loadAttributesMap: attributesMapLoaderModule.loadAttributesMap.bind(attributesMapLoaderModule),
	            getAttributesDisplayForms: visualizationObjectHelper_1.getAttributesDisplayForms,
	            convertReferencesToUris: referenceHandling_1.convertReferencesToUris,
	            convertUrisToReferences: referenceHandling_1.convertUrisToReferences,
	        };
	    }
	    SDK.prototype.clone = function () {
	        return new SDK(this.fetchMethod, cloneDeep_1.default(this.configStorage));
	    };
	    return SDK;
	}());
	exports.SDK = SDK;
	/**
	 * # Factory for creating SDK instances
	 *
	 * @param {object|null} config object to be passed to SDK constructor
	 * @method setCustomDomain
	 */
	exports.factory = function (fetchMethod) { return function (config) {
	    if (config === void 0) { config = {}; }
	    return new SDK(fetchMethod, config);
	}; };


/***/ }),
/* 4 */
/***/ (function(module, exports, __webpack_require__) {

	var baseClone = __webpack_require__(5);

	/** Used to compose bitmasks for cloning. */
	var CLONE_DEEP_FLAG = 1,
	    CLONE_SYMBOLS_FLAG = 4;

	/**
	 * This method is like `_.clone` except that it recursively clones `value`.
	 *
	 * @static
	 * @memberOf _
	 * @since 1.0.0
	 * @category Lang
	 * @param {*} value The value to recursively clone.
	 * @returns {*} Returns the deep cloned value.
	 * @see _.clone
	 * @example
	 *
	 * var objects = [{ 'a': 1 }, { 'b': 2 }];
	 *
	 * var deep = _.cloneDeep(objects);
	 * console.log(deep[0] === objects[0]);
	 * // => false
	 */
	function cloneDeep(value) {
	  return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG);
	}

	module.exports = cloneDeep;


/***/ }),
/* 5 */
/***/ (function(module, exports, __webpack_require__) {

	var Stack = __webpack_require__(6),
	    arrayEach = __webpack_require__(14),
	    assignValue = __webpack_require__(15),
	    baseAssign = __webpack_require__(19),
	    baseAssignIn = __webpack_require__(23),
	    cloneBuffer = __webpack_require__(25),
	    copyArray = __webpack_require__(29),
	    copySymbols = __webpack_require__(30),
	    copySymbolsIn = __webpack_require__(32),
	    getAllKeys = __webpack_require__(34),
	    getAllKeysIn = __webpack_require__(35),
	    getTag = __webpack_require__(36),
	    initCloneArray = __webpack_require__(37),
	    initCloneByTag = __webpack_require__(38),
	    initCloneObject = __webpack_require__(39),
	    isArray = __webpack_require__(44),
	    isBuffer = __webpack_require__(45),
	    isMap = __webpack_require__(46),
	    isObject = __webpack_require__(41),
	    isSet = __webpack_require__(47),
	    keys = __webpack_require__(21);

	/** Used to compose bitmasks for cloning. */
	var CLONE_DEEP_FLAG = 1,
	    CLONE_FLAT_FLAG = 2,
	    CLONE_SYMBOLS_FLAG = 4;

	/** `Object#toString` result references. */
	var argsTag = '[object Arguments]',
	    arrayTag = '[object Array]',
	    boolTag = '[object Boolean]',
	    dateTag = '[object Date]',
	    errorTag = '[object Error]',
	    funcTag = '[object Function]',
	    genTag = '[object GeneratorFunction]',
	    mapTag = '[object Map]',
	    numberTag = '[object Number]',
	    objectTag = '[object Object]',
	    regexpTag = '[object RegExp]',
	    setTag = '[object Set]',
	    stringTag = '[object String]',
	    symbolTag = '[object Symbol]',
	    weakMapTag = '[object WeakMap]';

	var arrayBufferTag = '[object ArrayBuffer]',
	    dataViewTag = '[object DataView]',
	    float32Tag = '[object Float32Array]',
	    float64Tag = '[object Float64Array]',
	    int8Tag = '[object Int8Array]',
	    int16Tag = '[object Int16Array]',
	    int32Tag = '[object Int32Array]',
	    uint8Tag = '[object Uint8Array]',
	    uint8ClampedTag = '[object Uint8ClampedArray]',
	    uint16Tag = '[object Uint16Array]',
	    uint32Tag = '[object Uint32Array]';

	/** Used to identify `toStringTag` values supported by `_.clone`. */
	var cloneableTags = {};
	cloneableTags[argsTag] = cloneableTags[arrayTag] =
	cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] =
	cloneableTags[boolTag] = cloneableTags[dateTag] =
	cloneableTags[float32Tag] = cloneableTags[float64Tag] =
	cloneableTags[int8Tag] = cloneableTags[int16Tag] =
	cloneableTags[int32Tag] = cloneableTags[mapTag] =
	cloneableTags[numberTag] = cloneableTags[objectTag] =
	cloneableTags[regexpTag] = cloneableTags[setTag] =
	cloneableTags[stringTag] = cloneableTags[symbolTag] =
	cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] =
	cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
	cloneableTags[errorTag] = cloneableTags[funcTag] =
	cloneableTags[weakMapTag] = false;

	/**
	 * The base implementation of `_.clone` and `_.cloneDeep` which tracks
	 * traversed objects.
	 *
	 * @private
	 * @param {*} value The value to clone.
	 * @param {boolean} bitmask The bitmask flags.
	 *  1 - Deep clone
	 *  2 - Flatten inherited properties
	 *  4 - Clone symbols
	 * @param {Function} [customizer] The function to customize cloning.
	 * @param {string} [key] The key of `value`.
	 * @param {Object} [object] The parent object of `value`.
	 * @param {Object} [stack] Tracks traversed objects and their clone counterparts.
	 * @returns {*} Returns the cloned value.
	 */
	function baseClone(value, bitmask, customizer, key, object, stack) {
	  var result,
	      isDeep = bitmask & CLONE_DEEP_FLAG,
	      isFlat = bitmask & CLONE_FLAT_FLAG,
	      isFull = bitmask & CLONE_SYMBOLS_FLAG;

	  if (customizer) {
	    result = object ? customizer(value, key, object, stack) : customizer(value);
	  }
	  if (result !== undefined) {
	    return result;
	  }
	  if (!isObject(value)) {
	    return value;
	  }
	  var isArr = isArray(value);
	  if (isArr) {
	    result = initCloneArray(value);
	    if (!isDeep) {
	      return copyArray(value, result);
	    }
	  } else {
	    var tag = getTag(value),
	        isFunc = tag == funcTag || tag == genTag;

	    if (isBuffer(value)) {
	      return cloneBuffer(value, isDeep);
	    }
	    if (tag == objectTag || tag == argsTag || (isFunc && !object)) {
	      result = (isFlat || isFunc) ? {} : initCloneObject(value);
	      if (!isDeep) {
	        return isFlat
	          ? copySymbolsIn(value, baseAssignIn(result, value))
	          : copySymbols(value, baseAssign(result, value));
	      }
	    } else {
	      if (!cloneableTags[tag]) {
	        return object ? value : {};
	      }
	      result = initCloneByTag(value, tag, isDeep);
	    }
	  }
	  // Check for circular references and return its corresponding clone.
	  stack || (stack = new Stack);
	  var stacked = stack.get(value);
	  if (stacked) {
	    return stacked;
	  }
	  stack.set(value, result);

	  if (isSet(value)) {
	    value.forEach(function(subValue) {
	      result.add(baseClone(subValue, bitmask, customizer, subValue, value, stack));
	    });
	  } else if (isMap(value)) {
	    value.forEach(function(subValue, key) {
	      result.set(key, baseClone(subValue, bitmask, customizer, key, value, stack));
	    });
	  }

	  var keysFunc = isFull
	    ? (isFlat ? getAllKeysIn : getAllKeys)
	    : (isFlat ? keysIn : keys);

	  var props = isArr ? undefined : keysFunc(value);
	  arrayEach(props || value, function(subValue, key) {
	    if (props) {
	      key = subValue;
	      subValue = value[key];
	    }
	    // Recursively populate clone (susceptible to call stack limits).
	    assignValue(result, key, baseClone(subValue, bitmask, customizer, key, value, stack));
	  });
	  return result;
	}

	module.exports = baseClone;


/***/ }),
/* 6 */
/***/ (function(module, exports, __webpack_require__) {

	var listCacheClear = __webpack_require__(7),
	    listCacheDelete = __webpack_require__(8),
	    listCacheGet = __webpack_require__(11),
	    listCacheHas = __webpack_require__(12),
	    listCacheSet = __webpack_require__(13);

	/**
	 * Creates an list cache object.
	 *
	 * @private
	 * @constructor
	 * @param {Array} [entries] The key-value pairs to cache.
	 */
	function ListCache(entries) {
	  var index = -1,
	      length = entries == null ? 0 : entries.length;

	  this.clear();
	  while (++index < length) {
	    var entry = entries[index];
	    this.set(entry[0], entry[1]);
	  }
	}

	// Add methods to `ListCache`.
	ListCache.prototype.clear = listCacheClear;
	ListCache.prototype['delete'] = listCacheDelete;
	ListCache.prototype.get = listCacheGet;
	ListCache.prototype.has = listCacheHas;
	ListCache.prototype.set = listCacheSet;

	module.exports = ListCache;


/***/ }),
/* 7 */
/***/ (function(module, exports) {

	/**
	 * Removes all key-value entries from the list cache.
	 *
	 * @private
	 * @name clear
	 * @memberOf ListCache
	 */
	function listCacheClear() {
	  this.__data__ = [];
	  this.size = 0;
	}

	module.exports = listCacheClear;


/***/ }),
/* 8 */
/***/ (function(module, exports, __webpack_require__) {

	var assocIndexOf = __webpack_require__(9);

	/** Used for built-in method references. */
	var arrayProto = Array.prototype;

	/** Built-in value references. */
	var splice = arrayProto.splice;

	/**
	 * Removes `key` and its value from the list cache.
	 *
	 * @private
	 * @name delete
	 * @memberOf ListCache
	 * @param {string} key The key of the value to remove.
	 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
	 */
	function listCacheDelete(key) {
	  var data = this.__data__,
	      index = assocIndexOf(data, key);

	  if (index < 0) {
	    return false;
	  }
	  var lastIndex = data.length - 1;
	  if (index == lastIndex) {
	    data.pop();
	  } else {
	    splice.call(data, index, 1);
	  }
	  --this.size;
	  return true;
	}

	module.exports = listCacheDelete;


/***/ }),
/* 9 */
/***/ (function(module, exports, __webpack_require__) {

	var eq = __webpack_require__(10);

	/**
	 * Gets the index at which the `key` is found in `array` of key-value pairs.
	 *
	 * @private
	 * @param {Array} array The array to inspect.
	 * @param {*} key The key to search for.
	 * @returns {number} Returns the index of the matched value, else `-1`.
	 */
	function assocIndexOf(array, key) {
	  var length = array.length;
	  while (length--) {
	    if (eq(array[length][0], key)) {
	      return length;
	    }
	  }
	  return -1;
	}

	module.exports = assocIndexOf;


/***/ }),
/* 10 */
/***/ (function(module, exports) {

	/**
	 * Performs a
	 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
	 * comparison between two values to determine if they are equivalent.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to compare.
	 * @param {*} other The other value to compare.
	 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
	 * @example
	 *
	 * var object = { 'a': 1 };
	 * var other = { 'a': 1 };
	 *
	 * _.eq(object, object);
	 * // => true
	 *
	 * _.eq(object, other);
	 * // => false
	 *
	 * _.eq('a', 'a');
	 * // => true
	 *
	 * _.eq('a', Object('a'));
	 * // => false
	 *
	 * _.eq(NaN, NaN);
	 * // => true
	 */
	function eq(value, other) {
	  return value === other || (value !== value && other !== other);
	}

	module.exports = eq;


/***/ }),
/* 11 */
/***/ (function(module, exports, __webpack_require__) {

	var assocIndexOf = __webpack_require__(9);

	/**
	 * Gets the list cache value for `key`.
	 *
	 * @private
	 * @name get
	 * @memberOf ListCache
	 * @param {string} key The key of the value to get.
	 * @returns {*} Returns the entry value.
	 */
	function listCacheGet(key) {
	  var data = this.__data__,
	      index = assocIndexOf(data, key);

	  return index < 0 ? undefined : data[index][1];
	}

	module.exports = listCacheGet;


/***/ }),
/* 12 */
/***/ (function(module, exports, __webpack_require__) {

	var assocIndexOf = __webpack_require__(9);

	/**
	 * Checks if a list cache value for `key` exists.
	 *
	 * @private
	 * @name has
	 * @memberOf ListCache
	 * @param {string} key The key of the entry to check.
	 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
	 */
	function listCacheHas(key) {
	  return assocIndexOf(this.__data__, key) > -1;
	}

	module.exports = listCacheHas;


/***/ }),
/* 13 */
/***/ (function(module, exports, __webpack_require__) {

	var assocIndexOf = __webpack_require__(9);

	/**
	 * Sets the list cache `key` to `value`.
	 *
	 * @private
	 * @name set
	 * @memberOf ListCache
	 * @param {string} key The key of the value to set.
	 * @param {*} value The value to set.
	 * @returns {Object} Returns the list cache instance.
	 */
	function listCacheSet(key, value) {
	  var data = this.__data__,
	      index = assocIndexOf(data, key);

	  if (index < 0) {
	    ++this.size;
	    data.push([key, value]);
	  } else {
	    data[index][1] = value;
	  }
	  return this;
	}

	module.exports = listCacheSet;


/***/ }),
/* 14 */
/***/ (function(module, exports) {

	/**
	 * A specialized version of `_.forEach` for arrays without support for
	 * iteratee shorthands.
	 *
	 * @private
	 * @param {Array} [array] The array to iterate over.
	 * @param {Function} iteratee The function invoked per iteration.
	 * @returns {Array} Returns `array`.
	 */
	function arrayEach(array, iteratee) {
	  var index = -1,
	      length = array == null ? 0 : array.length;

	  while (++index < length) {
	    if (iteratee(array[index], index, array) === false) {
	      break;
	    }
	  }
	  return array;
	}

	module.exports = arrayEach;


/***/ }),
/* 15 */
/***/ (function(module, exports, __webpack_require__) {

	var baseAssignValue = __webpack_require__(16),
	    eq = __webpack_require__(10);

	/** Used for built-in method references. */
	var objectProto = Object.prototype;

	/** Used to check objects for own properties. */
	var hasOwnProperty = objectProto.hasOwnProperty;

	/**
	 * Assigns `value` to `key` of `object` if the existing value is not equivalent
	 * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
	 * for equality comparisons.
	 *
	 * @private
	 * @param {Object} object The object to modify.
	 * @param {string} key The key of the property to assign.
	 * @param {*} value The value to assign.
	 */
	function assignValue(object, key, value) {
	  var objValue = object[key];
	  if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) ||
	      (value === undefined && !(key in object))) {
	    baseAssignValue(object, key, value);
	  }
	}

	module.exports = assignValue;


/***/ }),
/* 16 */
/***/ (function(module, exports, __webpack_require__) {

	var defineProperty = __webpack_require__(17);

	/**
	 * The base implementation of `assignValue` and `assignMergeValue` without
	 * value checks.
	 *
	 * @private
	 * @param {Object} object The object to modify.
	 * @param {string} key The key of the property to assign.
	 * @param {*} value The value to assign.
	 */
	function baseAssignValue(object, key, value) {
	  if (key == '__proto__' && defineProperty) {
	    defineProperty(object, key, {
	      'configurable': true,
	      'enumerable': true,
	      'value': value,
	      'writable': true
	    });
	  } else {
	    object[key] = value;
	  }
	}

	module.exports = baseAssignValue;


/***/ }),
/* 17 */
/***/ (function(module, exports, __webpack_require__) {

	var getNative = __webpack_require__(18);

	var defineProperty = (function() {
	  try {
	    var func = getNative(Object, 'defineProperty');
	    func({}, '', {});
	    return func;
	  } catch (e) {}
	}());

	module.exports = defineProperty;


/***/ }),
/* 18 */
/***/ (function(module, exports) {

	/**
	 * Gets the value at `key` of `object`.
	 *
	 * @private
	 * @param {Object} [object] The object to query.
	 * @param {string} key The key of the property to get.
	 * @returns {*} Returns the property value.
	 */
	function getValue(object, key) {
	  return object == null ? undefined : object[key];
	}

	module.exports = getValue;


/***/ }),
/* 19 */
/***/ (function(module, exports, __webpack_require__) {

	var copyObject = __webpack_require__(20),
	    keys = __webpack_require__(21);

	/**
	 * The base implementation of `_.assign` without support for multiple sources
	 * or `customizer` functions.
	 *
	 * @private
	 * @param {Object} object The destination object.
	 * @param {Object} source The source object.
	 * @returns {Object} Returns `object`.
	 */
	function baseAssign(object, source) {
	  return object && copyObject(source, keys(source), object);
	}

	module.exports = baseAssign;


/***/ }),
/* 20 */
/***/ (function(module, exports, __webpack_require__) {

	var assignValue = __webpack_require__(15),
	    baseAssignValue = __webpack_require__(16);

	/**
	 * Copies properties of `source` to `object`.
	 *
	 * @private
	 * @param {Object} source The object to copy properties from.
	 * @param {Array} props The property identifiers to copy.
	 * @param {Object} [object={}] The object to copy properties to.
	 * @param {Function} [customizer] The function to customize copied values.
	 * @returns {Object} Returns `object`.
	 */
	function copyObject(source, props, object, customizer) {
	  var isNew = !object;
	  object || (object = {});

	  var index = -1,
	      length = props.length;

	  while (++index < length) {
	    var key = props[index];

	    var newValue = customizer
	      ? customizer(object[key], source[key], key, object, source)
	      : undefined;

	    if (newValue === undefined) {
	      newValue = source[key];
	    }
	    if (isNew) {
	      baseAssignValue(object, key, newValue);
	    } else {
	      assignValue(object, key, newValue);
	    }
	  }
	  return object;
	}

	module.exports = copyObject;


/***/ }),
/* 21 */
/***/ (function(module, exports, __webpack_require__) {

	var overArg = __webpack_require__(22);

	/* Built-in method references for those with the same name as other `lodash` methods. */
	var nativeKeys = overArg(Object.keys, Object);

	module.exports = nativeKeys;


/***/ }),
/* 22 */
/***/ (function(module, exports) {

	/**
	 * Creates a unary function that invokes `func` with its argument transformed.
	 *
	 * @private
	 * @param {Function} func The function to wrap.
	 * @param {Function} transform The argument transform.
	 * @returns {Function} Returns the new function.
	 */
	function overArg(func, transform) {
	  return function(arg) {
	    return func(transform(arg));
	  };
	}

	module.exports = overArg;


/***/ }),
/* 23 */
/***/ (function(module, exports, __webpack_require__) {

	var copyObject = __webpack_require__(20),
	    keysIn = __webpack_require__(24);

	/**
	 * The base implementation of `_.assignIn` without support for multiple sources
	 * or `customizer` functions.
	 *
	 * @private
	 * @param {Object} object The destination object.
	 * @param {Object} source The source object.
	 * @returns {Object} Returns `object`.
	 */
	function baseAssignIn(object, source) {
	  return object && copyObject(source, keysIn(source), object);
	}

	module.exports = baseAssignIn;


/***/ }),
/* 24 */
/***/ (function(module, exports) {

	/**
	 * This function is like
	 * [`Object.keys`](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
	 * except that it includes inherited enumerable properties.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @returns {Array} Returns the array of property names.
	 */
	function nativeKeysIn(object) {
	  var result = [];
	  if (object != null) {
	    for (var key in Object(object)) {
	      result.push(key);
	    }
	  }
	  return result;
	}

	module.exports = nativeKeysIn;


/***/ }),
/* 25 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(module) {var root = __webpack_require__(27);

	/** Detect free variable `exports`. */
	var freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;

	/** Detect free variable `module`. */
	var freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;

	/** Detect the popular CommonJS extension `module.exports`. */
	var moduleExports = freeModule && freeModule.exports === freeExports;

	/** Built-in value references. */
	var Buffer = moduleExports ? root.Buffer : undefined,
	    allocUnsafe = Buffer ? Buffer.allocUnsafe : undefined;

	/**
	 * Creates a clone of  `buffer`.
	 *
	 * @private
	 * @param {Buffer} buffer The buffer to clone.
	 * @param {boolean} [isDeep] Specify a deep clone.
	 * @returns {Buffer} Returns the cloned buffer.
	 */
	function cloneBuffer(buffer, isDeep) {
	  if (isDeep) {
	    return buffer.slice();
	  }
	  var length = buffer.length,
	      result = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);

	  buffer.copy(result);
	  return result;
	}

	module.exports = cloneBuffer;

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(26)(module)))

/***/ }),
/* 26 */
/***/ (function(module, exports) {

	module.exports = function(module) {
		if(!module.webpackPolyfill) {
			module.deprecate = function() {};
			module.paths = [];
			// module.parent = undefined by default
			module.children = [];
			module.webpackPolyfill = 1;
		}
		return module;
	}


/***/ }),
/* 27 */
/***/ (function(module, exports, __webpack_require__) {

	var freeGlobal = __webpack_require__(28);

	/** Detect free variable `self`. */
	var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

	/** Used as a reference to the global object. */
	var root = freeGlobal || freeSelf || Function('return this')();

	module.exports = root;


/***/ }),
/* 28 */
/***/ (function(module, exports) {

	/* WEBPACK VAR INJECTION */(function(global) {/** Detect free variable `global` from Node.js. */
	var freeGlobal = typeof global == 'object' && global && global.Object === Object && global;

	module.exports = freeGlobal;

	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ }),
/* 29 */
/***/ (function(module, exports) {

	/**
	 * Copies the values of `source` to `array`.
	 *
	 * @private
	 * @param {Array} source The array to copy values from.
	 * @param {Array} [array=[]] The array to copy values to.
	 * @returns {Array} Returns `array`.
	 */
	function copyArray(source, array) {
	  var index = -1,
	      length = source.length;

	  array || (array = Array(length));
	  while (++index < length) {
	    array[index] = source[index];
	  }
	  return array;
	}

	module.exports = copyArray;


/***/ }),
/* 30 */
/***/ (function(module, exports, __webpack_require__) {

	var copyObject = __webpack_require__(20),
	    getSymbols = __webpack_require__(31);

	/**
	 * Copies own symbols of `source` to `object`.
	 *
	 * @private
	 * @param {Object} source The object to copy symbols from.
	 * @param {Object} [object={}] The object to copy symbols to.
	 * @returns {Object} Returns `object`.
	 */
	function copySymbols(source, object) {
	  return copyObject(source, getSymbols(source), object);
	}

	module.exports = copySymbols;


/***/ }),
/* 31 */
/***/ (function(module, exports) {

	/**
	 * This method returns a new empty array.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.13.0
	 * @category Util
	 * @returns {Array} Returns the new empty array.
	 * @example
	 *
	 * var arrays = _.times(2, _.stubArray);
	 *
	 * console.log(arrays);
	 * // => [[], []]
	 *
	 * console.log(arrays[0] === arrays[1]);
	 * // => false
	 */
	function stubArray() {
	  return [];
	}

	module.exports = stubArray;


/***/ }),
/* 32 */
/***/ (function(module, exports, __webpack_require__) {

	var copyObject = __webpack_require__(20),
	    getSymbolsIn = __webpack_require__(33);

	/**
	 * Copies own and inherited symbols of `source` to `object`.
	 *
	 * @private
	 * @param {Object} source The object to copy symbols from.
	 * @param {Object} [object={}] The object to copy symbols to.
	 * @returns {Object} Returns `object`.
	 */
	function copySymbolsIn(source, object) {
	  return copyObject(source, getSymbolsIn(source), object);
	}

	module.exports = copySymbolsIn;


/***/ }),
/* 33 */
/***/ (function(module, exports) {

	/**
	 * This method returns a new empty array.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.13.0
	 * @category Util
	 * @returns {Array} Returns the new empty array.
	 * @example
	 *
	 * var arrays = _.times(2, _.stubArray);
	 *
	 * console.log(arrays);
	 * // => [[], []]
	 *
	 * console.log(arrays[0] === arrays[1]);
	 * // => false
	 */
	function stubArray() {
	  return [];
	}

	module.exports = stubArray;


/***/ }),
/* 34 */
/***/ (function(module, exports, __webpack_require__) {

	var overArg = __webpack_require__(22);

	/* Built-in method references for those with the same name as other `lodash` methods. */
	var nativeKeys = overArg(Object.keys, Object);

	module.exports = nativeKeys;


/***/ }),
/* 35 */
/***/ (function(module, exports) {

	/**
	 * This function is like
	 * [`Object.keys`](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
	 * except that it includes inherited enumerable properties.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @returns {Array} Returns the array of property names.
	 */
	function nativeKeysIn(object) {
	  var result = [];
	  if (object != null) {
	    for (var key in Object(object)) {
	      result.push(key);
	    }
	  }
	  return result;
	}

	module.exports = nativeKeysIn;


/***/ }),
/* 36 */
/***/ (function(module, exports) {

	/** Used for built-in method references. */
	var objectProto = Object.prototype;

	/**
	 * Used to resolve the
	 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
	 * of values.
	 */
	var nativeObjectToString = objectProto.toString;

	/**
	 * Converts `value` to a string using `Object.prototype.toString`.
	 *
	 * @private
	 * @param {*} value The value to convert.
	 * @returns {string} Returns the converted string.
	 */
	function objectToString(value) {
	  return nativeObjectToString.call(value);
	}

	module.exports = objectToString;


/***/ }),
/* 37 */
/***/ (function(module, exports) {

	/** Used for built-in method references. */
	var objectProto = Object.prototype;

	/** Used to check objects for own properties. */
	var hasOwnProperty = objectProto.hasOwnProperty;

	/**
	 * Initializes an array clone.
	 *
	 * @private
	 * @param {Array} array The array to clone.
	 * @returns {Array} Returns the initialized clone.
	 */
	function initCloneArray(array) {
	  var length = array.length,
	      result = new array.constructor(length);

	  // Add properties assigned by `RegExp#exec`.
	  if (length && typeof array[0] == 'string' && hasOwnProperty.call(array, 'index')) {
	    result.index = array.index;
	    result.input = array.input;
	  }
	  return result;
	}

	module.exports = initCloneArray;


/***/ }),
/* 38 */
/***/ (function(module, exports) {

	/**
	 * This method returns the first argument it receives.
	 *
	 * @static
	 * @since 0.1.0
	 * @memberOf _
	 * @category Util
	 * @param {*} value Any value.
	 * @returns {*} Returns `value`.
	 * @example
	 *
	 * var object = { 'a': 1 };
	 *
	 * console.log(_.identity(object) === object);
	 * // => true
	 */
	function identity(value) {
	  return value;
	}

	module.exports = identity;


/***/ }),
/* 39 */
/***/ (function(module, exports, __webpack_require__) {

	var baseCreate = __webpack_require__(40),
	    getPrototype = __webpack_require__(42),
	    isPrototype = __webpack_require__(43);

	/**
	 * Initializes an object clone.
	 *
	 * @private
	 * @param {Object} object The object to clone.
	 * @returns {Object} Returns the initialized clone.
	 */
	function initCloneObject(object) {
	  return (typeof object.constructor == 'function' && !isPrototype(object))
	    ? baseCreate(getPrototype(object))
	    : {};
	}

	module.exports = initCloneObject;


/***/ }),
/* 40 */
/***/ (function(module, exports, __webpack_require__) {

	var isObject = __webpack_require__(41);

	/** Built-in value references. */
	var objectCreate = Object.create;

	/**
	 * The base implementation of `_.create` without support for assigning
	 * properties to the created object.
	 *
	 * @private
	 * @param {Object} proto The object to inherit from.
	 * @returns {Object} Returns the new object.
	 */
	var baseCreate = (function() {
	  function object() {}
	  return function(proto) {
	    if (!isObject(proto)) {
	      return {};
	    }
	    if (objectCreate) {
	      return objectCreate(proto);
	    }
	    object.prototype = proto;
	    var result = new object;
	    object.prototype = undefined;
	    return result;
	  };
	}());

	module.exports = baseCreate;


/***/ }),
/* 41 */
/***/ (function(module, exports) {

	/**
	 * Checks if `value` is the
	 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
	 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
	 * @example
	 *
	 * _.isObject({});
	 * // => true
	 *
	 * _.isObject([1, 2, 3]);
	 * // => true
	 *
	 * _.isObject(_.noop);
	 * // => true
	 *
	 * _.isObject(null);
	 * // => false
	 */
	function isObject(value) {
	  var type = typeof value;
	  return value != null && (type == 'object' || type == 'function');
	}

	module.exports = isObject;


/***/ }),
/* 42 */
/***/ (function(module, exports, __webpack_require__) {

	var overArg = __webpack_require__(22);

	/** Built-in value references. */
	var getPrototype = overArg(Object.getPrototypeOf, Object);

	module.exports = getPrototype;


/***/ }),
/* 43 */
/***/ (function(module, exports) {

	/**
	 * This method returns `false`.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.13.0
	 * @category Util
	 * @returns {boolean} Returns `false`.
	 * @example
	 *
	 * _.times(2, _.stubFalse);
	 * // => [false, false]
	 */
	function stubFalse() {
	  return false;
	}

	module.exports = stubFalse;


/***/ }),
/* 44 */
/***/ (function(module, exports) {

	/**
	 * Checks if `value` is classified as an `Array` object.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is an array, else `false`.
	 * @example
	 *
	 * _.isArray([1, 2, 3]);
	 * // => true
	 *
	 * _.isArray(document.body.children);
	 * // => false
	 *
	 * _.isArray('abc');
	 * // => false
	 *
	 * _.isArray(_.noop);
	 * // => false
	 */
	var isArray = Array.isArray;

	module.exports = isArray;


/***/ }),
/* 45 */
/***/ (function(module, exports) {

	/**
	 * This method returns `false`.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.13.0
	 * @category Util
	 * @returns {boolean} Returns `false`.
	 * @example
	 *
	 * _.times(2, _.stubFalse);
	 * // => [false, false]
	 */
	function stubFalse() {
	  return false;
	}

	module.exports = stubFalse;


/***/ }),
/* 46 */
/***/ (function(module, exports) {

	/**
	 * This method returns `false`.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.13.0
	 * @category Util
	 * @returns {boolean} Returns `false`.
	 * @example
	 *
	 * _.times(2, _.stubFalse);
	 * // => [false, false]
	 */
	function stubFalse() {
	  return false;
	}

	module.exports = stubFalse;


/***/ }),
/* 47 */
/***/ (function(module, exports) {

	/**
	 * This method returns `false`.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.13.0
	 * @category Util
	 * @returns {boolean} Returns `false`.
	 * @example
	 *
	 * _.times(2, _.stubFalse);
	 * // => [false, false]
	 */
	function stubFalse() {
	  return false;
	}

	module.exports = stubFalse;


/***/ }),
/* 48 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || (function () {
	    var extendStatics = function (d, b) {
	        extendStatics = Object.setPrototypeOf ||
	            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
	            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
	        return extendStatics(d, b);
	    };
	    return function (d, b) {
	        extendStatics(d, b);
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	})();
	var __assign = (this && this.__assign) || function () {
	    __assign = Object.assign || function(t) {
	        for (var s, i = 1, n = arguments.length; i < n; i++) {
	            s = arguments[i];
	            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
	                t[p] = s[p];
	        }
	        return t;
	    };
	    return __assign.apply(this, arguments);
	};
	var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
	    return new (P || (P = Promise))(function (resolve, reject) {
	        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
	        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
	        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
	        step((generator = generator.apply(thisArg, _arguments || [])).next());
	    });
	};
	var __generator = (this && this.__generator) || function (thisArg, body) {
	    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
	    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
	    function verb(n) { return function (v) { return step([n, v]); }; }
	    function step(op) {
	        if (f) throw new TypeError("Generator is already executing.");
	        while (_) try {
	            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
	            if (y = 0, t) op = [op[0] & 2, t.value];
	            switch (op[0]) {
	                case 0: case 1: t = op; break;
	                case 4: _.label++; return { value: op[1], done: false };
	                case 5: _.label++; y = op[1]; op = [0]; continue;
	                case 7: op = _.ops.pop(); _.trys.pop(); continue;
	                default:
	                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
	                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
	                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
	                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
	                    if (t[2]) _.ops.pop();
	                    _.trys.pop(); continue;
	            }
	            op = body.call(thisArg, _);
	        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
	        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
	    }
	};
	var __importDefault = (this && this.__importDefault) || function (mod) {
	    return (mod && mod.__esModule) ? mod : { "default": mod };
	};
	Object.defineProperty(exports, "__esModule", { value: true });
	// (C) 2007-2020 GoodData Corporation
	var isPlainObject_1 = __importDefault(__webpack_require__(49));
	var isFunction_1 = __importDefault(__webpack_require__(52));
	var set_1 = __importDefault(__webpack_require__(53));
	var defaults_1 = __importDefault(__webpack_require__(63));
	var merge_1 = __importDefault(__webpack_require__(70));
	var result_1 = __importDefault(__webpack_require__(87));
	var util_1 = __webpack_require__(88);
	/**
	 * Ajax wrapper around GDC authentication mechanisms, SST and TT token handling and polling.
	 * Interface is the same as original jQuery.ajax.
	 *
	 * If token is expired, current request is "paused", token is refreshed and request is retried and result
	 * is transparently returned to the original call.
	 *
	 * Additionally polling is handled. Only final result of polling returned.
	 * @module xhr
	 * @class xhr
	 */
	var DEFAULT_POLL_DELAY = 1000;
	var REST_API_VERSION_HEADER = "X-GDC-VERSION";
	var REST_API_DEPRECATED_VERSION_HEADER = "X-GDC-DEPRECATED";
	// The version used in X-GDC-VERSION header (see https://confluence.intgdc.com/display/Development/REST+API+versioning)
	var LATEST_REST_API_VERSION = 5;
	function simulateBeforeSend(url, settings) {
	    var xhrMockInBeforeSend = {
	        setRequestHeader: function (key, value) {
	            set_1.default(settings, ["headers", key], value);
	        },
	    };
	    if (isFunction_1.default(settings.beforeSend)) {
	        settings.beforeSend(xhrMockInBeforeSend, url);
	    }
	}
	function enrichSettingWithCustomDomain(originalUrl, originalSettings, domain) {
	    var url = originalUrl;
	    var settings = originalSettings;
	    if (domain) {
	        // protect url to be prepended with domain on retry
	        if (originalUrl.indexOf(domain) === -1) {
	            url = domain + originalUrl;
	        }
	        settings.mode = "cors";
	        settings.credentials = "include";
	    }
	    return { url: url, settings: settings };
	}
	function handlePolling(url, settings, sendRequest) {
	    var pollingDelay = result_1.default(settings, "pollDelay");
	    return new Promise(function (resolve, reject) {
	        setTimeout(function () {
	            sendRequest(url, settings).then(resolve, reject);
	        }, pollingDelay);
	    });
	}
	exports.handlePolling = handlePolling;
	function originPackageHeaders(_a) {
	    var name = _a.name, version = _a.version;
	    return {
	        "X-GDC-JS-PKG": name,
	        "X-GDC-JS-PKG-VERSION": version,
	    };
	}
	exports.originPackageHeaders = originPackageHeaders;
	var ApiError = /** @class */ (function (_super) {
	    __extends(ApiError, _super);
	    function ApiError(message, cause) {
	        var _this = _super.call(this, message) || this;
	        _this.cause = cause;
	        return _this;
	    }
	    return ApiError;
	}(Error));
	exports.ApiError = ApiError;
	var ApiResponseError = /** @class */ (function (_super) {
	    __extends(ApiResponseError, _super);
	    function ApiResponseError(message, response, responseBody) {
	        var _this = _super.call(this, message, null) || this;
	        _this.response = response;
	        _this.responseBody = responseBody;
	        return _this;
	    }
	    return ApiResponseError;
	}(ApiError));
	exports.ApiResponseError = ApiResponseError;
	var ApiNetworkError = /** @class */ (function (_super) {
	    __extends(ApiNetworkError, _super);
	    function ApiNetworkError() {
	        return _super !== null && _super.apply(this, arguments) || this;
	    }
	    return ApiNetworkError;
	}(ApiError));
	exports.ApiNetworkError = ApiNetworkError;
	var ApiResponse = /** @class */ (function () {
	    function ApiResponse(response, responseBody) {
	        this.response = response;
	        this.responseBody = responseBody;
	    }
	    Object.defineProperty(ApiResponse.prototype, "data", {
	        get: function () {
	            try {
	                return JSON.parse(this.responseBody);
	            }
	            catch (error) {
	                return this.responseBody;
	            }
	        },
	        enumerable: true,
	        configurable: true
	    });
	    ApiResponse.prototype.getData = function () {
	        try {
	            return JSON.parse(this.responseBody);
	        }
	        catch (error) {
	            return this.responseBody;
	        }
	    };
	    ApiResponse.prototype.getHeaders = function () {
	        return this.response;
	    };
	    return ApiResponse;
	}());
	exports.ApiResponse = ApiResponse;
	// the variable must be outside of the scope of the XhrModule to not log the message multiple times in SDK and KD
	var shouldLogDeprecatedRestApiCall = true;
	var XhrModule = /** @class */ (function () {
	    function XhrModule(fetch, configStorage) {
	        this.fetch = fetch;
	        this.configStorage = configStorage;
	        defaults_1.default(configStorage, { xhrSettings: {} });
	    }
	    /**
	     * Back compatible method for setting common XHR settings
	     *
	     * Usually in our apps we used beforeSend ajax callback to set the X-GDC-REQUEST header with unique ID.
	     *
	     * @param settings object XHR settings as
	     */
	    XhrModule.prototype.ajaxSetup = function (settings) {
	        Object.assign(this.configStorage.xhrSettings, settings);
	    };
	    XhrModule.prototype.ajax = function (originalUrl, customSettings) {
	        if (customSettings === void 0) { customSettings = {}; }
	        return __awaiter(this, void 0, Promise, function () {
	            var firstSettings, _a, url, settings, response, e_1, responseBody, finalUrl, finalSettings;
	            return __generator(this, function (_b) {
	                switch (_b.label) {
	                    case 0:
	                        firstSettings = this.createRequestSettings(customSettings);
	                        _a = enrichSettingWithCustomDomain(originalUrl, firstSettings, this.configStorage.domain), url = _a.url, settings = _a.settings;
	                        simulateBeforeSend(url, settings); // mutates `settings` param
	                        if (this.tokenRequest) {
	                            return [2 /*return*/, this.continueAfterTokenRequest(url, settings)];
	                        }
	                        _b.label = 1;
	                    case 1:
	                        _b.trys.push([1, 3, , 4]);
	                        return [4 /*yield*/, this.fetch(url, settings)];
	                    case 2:
	                        // TODO: We should clean up the settings at this point to be pure `RequestInit` object
	                        response = _b.sent();
	                        return [3 /*break*/, 4];
	                    case 3:
	                        e_1 = _b.sent();
	                        throw new ApiNetworkError(e_1.message, e_1); // TODO is it really necessary? couldn't we throw just Error?
	                    case 4: return [4 /*yield*/, response.text()];
	                    case 5:
	                        responseBody = _b.sent();
	                        if (response.status === 401) {
	                            // if 401 is in login-request, it means wrong user/password (we wont continue)
	                            if (url.indexOf("/gdc/account/login") !== -1) {
	                                throw new ApiResponseError("Unauthorized", response, responseBody);
	                            }
	                            return [2 /*return*/, this.handleUnauthorized(url, settings)];
	                        }
	                        // Note: Fetch does redirects automagically for 301 (and maybe more .. TODO when?)
	                        // see https://fetch.spec.whatwg.org/#ref-for-concept-request%E2%91%A3%E2%91%A2
	                        if (response.status === 202 && !settings.dontPollOnResult) {
	                            finalUrl = response.url || url;
	                            finalSettings = settings;
	                            // if the response is 202 and Location header is not empty, let's poll on the new Location
	                            if (response.headers.has("Location")) {
	                                finalUrl = response.headers.get("Location");
	                            }
	                            finalSettings.method = "GET";
	                            delete finalSettings.data;
	                            delete finalSettings.body;
	                            return [2 /*return*/, handlePolling(finalUrl, finalSettings, this.ajax.bind(this))];
	                        }
	                        this.verifyRestApiDeprecationStatus(response.headers);
	                        if (response.status >= 200 && response.status <= 399) {
	                            return [2 /*return*/, new ApiResponse(response, responseBody)];
	                        }
	                        // throws on 400, 500, etc.
	                        throw new ApiResponseError(response.statusText, response, responseBody);
	                }
	            });
	        });
	    };
	    /**
	     * Wrapper for xhr.ajax method GET
	     */
	    XhrModule.prototype.get = function (url, settings) {
	        return this.ajax(url, merge_1.default({ method: "GET" }, settings));
	    };
	    /**
	     * Wrapper for xhr.ajax method HEAD
	     */
	    XhrModule.prototype.head = function (url, settings) {
	        return this.ajax(url, merge_1.default({ method: "HEAD" }, settings));
	    };
	    /**
	     * Wrapper for xhr.ajax method POST
	     */
	    XhrModule.prototype.post = function (url, settings) {
	        return this.ajax(url, merge_1.default({ method: "POST" }, settings));
	    };
	    /**
	     * Wrapper for xhr.ajax method PUT
	     */
	    XhrModule.prototype.put = function (url, settings) {
	        return this.ajax(url, merge_1.default({ method: "PUT" }, settings));
	    };
	    /**
	     * Wrapper for xhr.ajax method DELETE
	     */
	    XhrModule.prototype.del = function (url, settings) {
	        return this.ajax(url, merge_1.default({ method: "DELETE" }, settings));
	    };
	    XhrModule.prototype.createRequestSettings = function (customSettings) {
	        var _a;
	        var settings = merge_1.default({
	            headers: __assign((_a = { Accept: "application/json; charset=utf-8", "Content-Type": "application/json" }, _a[REST_API_VERSION_HEADER] = LATEST_REST_API_VERSION, _a), originPackageHeaders(this.configStorage.originPackage || util_1.thisPackage)),
	        }, this.configStorage.xhrSettings, customSettings);
	        settings.pollDelay = settings.pollDelay !== undefined ? settings.pollDelay : DEFAULT_POLL_DELAY;
	        // TODO jquery compat - add to warnings
	        settings.body = settings.data ? settings.data : settings.body;
	        settings.mode = "same-origin";
	        settings.credentials = "same-origin";
	        if (isPlainObject_1.default(settings.body)) {
	            settings.body = JSON.stringify(settings.body);
	        }
	        return settings;
	    };
	    XhrModule.prototype.continueAfterTokenRequest = function (url, settings) {
	        var _this = this;
	        return this.tokenRequest.then(function (response) { return __awaiter(_this, void 0, void 0, function () {
	            return __generator(this, function (_a) {
	                if (!response.ok) {
	                    throw new ApiResponseError("Unauthorized", response, null);
	                }
	                this.tokenRequest = null;
	                return [2 /*return*/, this.ajax(url, settings)];
	            });
	        }); }, function (reason) {
	            _this.tokenRequest = null;
	            return reason;
	        });
	    };
	    XhrModule.prototype.handleUnauthorized = function (originalUrl, originalSettings) {
	        return __awaiter(this, void 0, void 0, function () {
	            var _a, url, settings, response, responseBody;
	            return __generator(this, function (_b) {
	                switch (_b.label) {
	                    case 0:
	                        // Create only single token request for any number of waiting request.
	                        // If token request exist, just listen for it's end.
	                        if (this.tokenRequest) {
	                            return [2 /*return*/, this.continueAfterTokenRequest(originalUrl, originalSettings)];
	                        }
	                        _a = enrichSettingWithCustomDomain("/gdc/account/token", this.createRequestSettings({}), this.configStorage.domain), url = _a.url, settings = _a.settings;
	                        this.tokenRequest = this.fetch(url, settings);
	                        return [4 /*yield*/, this.tokenRequest];
	                    case 1:
	                        response = _b.sent();
	                        return [4 /*yield*/, response.text()];
	                    case 2:
	                        responseBody = _b.sent();
	                        this.tokenRequest = null;
	                        // TODO jquery compat - allow to attach unauthorized callback and call it if attached
	                        // if ((xhrObj.status === 401) && (isFunction(req.unauthorized))) {
	                        //     req.unauthorized(xhrObj, textStatus, err, deferred);
	                        //     return;
	                        // }
	                        // unauthorized handler is not defined or not http 401
	                        // unauthorized when retrieving token -> not logged
	                        if (response.status === 401) {
	                            throw new ApiResponseError("Unauthorized", response, responseBody);
	                        }
	                        return [2 /*return*/, this.ajax(originalUrl, originalSettings)];
	                }
	            });
	        });
	    };
	    XhrModule.prototype.logDeprecatedRestApiCall = function (deprecatedVersionDetails) {
	        // tslint:disable-next-line:no-console
	        console.warn("The REST API version " + LATEST_REST_API_VERSION + " is deprecated (" + deprecatedVersionDetails + "). " +
	            "Please migrate your application to use GoodData.UI SDK or @gooddata/gooddata-js package that " +
	            "supports newer version of the API.");
	    };
	    XhrModule.prototype.isRestApiDeprecated = function (responseHeaders) {
	        return responseHeaders.has(REST_API_DEPRECATED_VERSION_HEADER);
	    };
	    XhrModule.prototype.verifyRestApiDeprecationStatus = function (responseHeaders) {
	        if (shouldLogDeprecatedRestApiCall && this.isRestApiDeprecated(responseHeaders)) {
	            var deprecatedVersionDetails = responseHeaders.get(REST_API_DEPRECATED_VERSION_HEADER);
	            this.logDeprecatedRestApiCall(deprecatedVersionDetails);
	            shouldLogDeprecatedRestApiCall = false;
	        }
	    };
	    return XhrModule;
	}());
	exports.XhrModule = XhrModule;


/***/ }),
/* 49 */
/***/ (function(module, exports, __webpack_require__) {

	var baseGetTag = __webpack_require__(50),
	    getPrototype = __webpack_require__(42),
	    isObjectLike = __webpack_require__(51);

	/** `Object#toString` result references. */
	var objectTag = '[object Object]';

	/** Used for built-in method references. */
	var funcProto = Function.prototype,
	    objectProto = Object.prototype;

	/** Used to resolve the decompiled source of functions. */
	var funcToString = funcProto.toString;

	/** Used to check objects for own properties. */
	var hasOwnProperty = objectProto.hasOwnProperty;

	/** Used to infer the `Object` constructor. */
	var objectCtorString = funcToString.call(Object);

	/**
	 * Checks if `value` is a plain object, that is, an object created by the
	 * `Object` constructor or one with a `[[Prototype]]` of `null`.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.8.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
	 * @example
	 *
	 * function Foo() {
	 *   this.a = 1;
	 * }
	 *
	 * _.isPlainObject(new Foo);
	 * // => false
	 *
	 * _.isPlainObject([1, 2, 3]);
	 * // => false
	 *
	 * _.isPlainObject({ 'x': 0, 'y': 0 });
	 * // => true
	 *
	 * _.isPlainObject(Object.create(null));
	 * // => true
	 */
	function isPlainObject(value) {
	  if (!isObjectLike(value) || baseGetTag(value) != objectTag) {
	    return false;
	  }
	  var proto = getPrototype(value);
	  if (proto === null) {
	    return true;
	  }
	  var Ctor = hasOwnProperty.call(proto, 'constructor') && proto.constructor;
	  return typeof Ctor == 'function' && Ctor instanceof Ctor &&
	    funcToString.call(Ctor) == objectCtorString;
	}

	module.exports = isPlainObject;


/***/ }),
/* 50 */
/***/ (function(module, exports) {

	/** Used for built-in method references. */
	var objectProto = Object.prototype;

	/**
	 * Used to resolve the
	 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
	 * of values.
	 */
	var nativeObjectToString = objectProto.toString;

	/**
	 * Converts `value` to a string using `Object.prototype.toString`.
	 *
	 * @private
	 * @param {*} value The value to convert.
	 * @returns {string} Returns the converted string.
	 */
	function objectToString(value) {
	  return nativeObjectToString.call(value);
	}

	module.exports = objectToString;


/***/ }),
/* 51 */
/***/ (function(module, exports) {

	/**
	 * Checks if `value` is object-like. A value is object-like if it's not `null`
	 * and has a `typeof` result of "object".
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
	 * @example
	 *
	 * _.isObjectLike({});
	 * // => true
	 *
	 * _.isObjectLike([1, 2, 3]);
	 * // => true
	 *
	 * _.isObjectLike(_.noop);
	 * // => false
	 *
	 * _.isObjectLike(null);
	 * // => false
	 */
	function isObjectLike(value) {
	  return value != null && typeof value == 'object';
	}

	module.exports = isObjectLike;


/***/ }),
/* 52 */
/***/ (function(module, exports, __webpack_require__) {

	var baseGetTag = __webpack_require__(50),
	    isObject = __webpack_require__(41);

	/** `Object#toString` result references. */
	var asyncTag = '[object AsyncFunction]',
	    funcTag = '[object Function]',
	    genTag = '[object GeneratorFunction]',
	    proxyTag = '[object Proxy]';

	/**
	 * Checks if `value` is classified as a `Function` object.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a function, else `false`.
	 * @example
	 *
	 * _.isFunction(_);
	 * // => true
	 *
	 * _.isFunction(/abc/);
	 * // => false
	 */
	function isFunction(value) {
	  if (!isObject(value)) {
	    return false;
	  }
	  // The use of `Object#toString` avoids issues with the `typeof` operator
	  // in Safari 9 which returns 'object' for typed arrays and other constructors.
	  var tag = baseGetTag(value);
	  return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
	}

	module.exports = isFunction;


/***/ }),
/* 53 */
/***/ (function(module, exports, __webpack_require__) {

	var baseSet = __webpack_require__(54);

	/**
	 * Sets the value at `path` of `object`. If a portion of `path` doesn't exist,
	 * it's created. Arrays are created for missing index properties while objects
	 * are created for all other missing properties. Use `_.setWith` to customize
	 * `path` creation.
	 *
	 * **Note:** This method mutates `object`.
	 *
	 * @static
	 * @memberOf _
	 * @since 3.7.0
	 * @category Object
	 * @param {Object} object The object to modify.
	 * @param {Array|string} path The path of the property to set.
	 * @param {*} value The value to set.
	 * @returns {Object} Returns `object`.
	 * @example
	 *
	 * var object = { 'a': [{ 'b': { 'c': 3 } }] };
	 *
	 * _.set(object, 'a[0].b.c', 4);
	 * console.log(object.a[0].b.c);
	 * // => 4
	 *
	 * _.set(object, ['x', '0', 'y', 'z'], 5);
	 * console.log(object.x[0].y.z);
	 * // => 5
	 */
	function set(object, path, value) {
	  return object == null ? object : baseSet(object, path, value);
	}

	module.exports = set;


/***/ }),
/* 54 */
/***/ (function(module, exports, __webpack_require__) {

	var assignValue = __webpack_require__(15),
	    castPath = __webpack_require__(55),
	    isIndex = __webpack_require__(61),
	    isObject = __webpack_require__(41),
	    toKey = __webpack_require__(62);

	/**
	 * The base implementation of `_.set`.
	 *
	 * @private
	 * @param {Object} object The object to modify.
	 * @param {Array|string} path The path of the property to set.
	 * @param {*} value The value to set.
	 * @param {Function} [customizer] The function to customize path creation.
	 * @returns {Object} Returns `object`.
	 */
	function baseSet(object, path, value, customizer) {
	  if (!isObject(object)) {
	    return object;
	  }
	  path = castPath(path, object);

	  var index = -1,
	      length = path.length,
	      lastIndex = length - 1,
	      nested = object;

	  while (nested != null && ++index < length) {
	    var key = toKey(path[index]),
	        newValue = value;

	    if (index != lastIndex) {
	      var objValue = nested[key];
	      newValue = customizer ? customizer(objValue, key, nested) : undefined;
	      if (newValue === undefined) {
	        newValue = isObject(objValue)
	          ? objValue
	          : (isIndex(path[index + 1]) ? [] : {});
	      }
	    }
	    assignValue(nested, key, newValue);
	    nested = nested[key];
	  }
	  return object;
	}

	module.exports = baseSet;


/***/ }),
/* 55 */
/***/ (function(module, exports, __webpack_require__) {

	var isArray = __webpack_require__(44),
	    isKey = __webpack_require__(56),
	    stringToPath = __webpack_require__(58),
	    toString = __webpack_require__(60);

	/**
	 * Casts `value` to a path array if it's not one.
	 *
	 * @private
	 * @param {*} value The value to inspect.
	 * @param {Object} [object] The object to query keys on.
	 * @returns {Array} Returns the cast property path array.
	 */
	function castPath(value, object) {
	  if (isArray(value)) {
	    return value;
	  }
	  return isKey(value, object) ? [value] : stringToPath(toString(value));
	}

	module.exports = castPath;


/***/ }),
/* 56 */
/***/ (function(module, exports, __webpack_require__) {

	var isArray = __webpack_require__(44),
	    isSymbol = __webpack_require__(57);

	/** Used to match property names within property paths. */
	var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,
	    reIsPlainProp = /^\w*$/;

	/**
	 * Checks if `value` is a property name and not a property path.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @param {Object} [object] The object to query keys on.
	 * @returns {boolean} Returns `true` if `value` is a property name, else `false`.
	 */
	function isKey(value, object) {
	  if (isArray(value)) {
	    return false;
	  }
	  var type = typeof value;
	  if (type == 'number' || type == 'symbol' || type == 'boolean' ||
	      value == null || isSymbol(value)) {
	    return true;
	  }
	  return reIsPlainProp.test(value) || !reIsDeepProp.test(value) ||
	    (object != null && value in Object(object));
	}

	module.exports = isKey;


/***/ }),
/* 57 */
/***/ (function(module, exports) {

	/**
	 * This method returns `false`.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.13.0
	 * @category Util
	 * @returns {boolean} Returns `false`.
	 * @example
	 *
	 * _.times(2, _.stubFalse);
	 * // => [false, false]
	 */
	function stubFalse() {
	  return false;
	}

	module.exports = stubFalse;


/***/ }),
/* 58 */
/***/ (function(module, exports, __webpack_require__) {

	var memoizeCapped = __webpack_require__(59);

	/** Used to match property names within property paths. */
	var rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;

	/** Used to match backslashes in property paths. */
	var reEscapeChar = /\\(\\)?/g;

	/**
	 * Converts `string` to a property path array.
	 *
	 * @private
	 * @param {string} string The string to convert.
	 * @returns {Array} Returns the property path array.
	 */
	var stringToPath = memoizeCapped(function(string) {
	  var result = [];
	  if (string.charCodeAt(0) === 46 /* . */) {
	    result.push('');
	  }
	  string.replace(rePropName, function(match, number, quote, subString) {
	    result.push(quote ? subString.replace(reEscapeChar, '$1') : (number || match));
	  });
	  return result;
	});

	module.exports = stringToPath;


/***/ }),
/* 59 */
/***/ (function(module, exports) {

	/**
	 * This method returns the first argument it receives.
	 *
	 * @static
	 * @since 0.1.0
	 * @memberOf _
	 * @category Util
	 * @param {*} value Any value.
	 * @returns {*} Returns `value`.
	 * @example
	 *
	 * var object = { 'a': 1 };
	 *
	 * console.log(_.identity(object) === object);
	 * // => true
	 */
	function identity(value) {
	  return value;
	}

	module.exports = identity;


/***/ }),
/* 60 */
/***/ (function(module, exports) {

	/**
	 * This method returns the first argument it receives.
	 *
	 * @static
	 * @since 0.1.0
	 * @memberOf _
	 * @category Util
	 * @param {*} value Any value.
	 * @returns {*} Returns `value`.
	 * @example
	 *
	 * var object = { 'a': 1 };
	 *
	 * console.log(_.identity(object) === object);
	 * // => true
	 */
	function identity(value) {
	  return value;
	}

	module.exports = identity;


/***/ }),
/* 61 */
/***/ (function(module, exports) {

	/** Used as references for various `Number` constants. */
	var MAX_SAFE_INTEGER = 9007199254740991;

	/** Used to detect unsigned integer values. */
	var reIsUint = /^(?:0|[1-9]\d*)$/;

	/**
	 * Checks if `value` is a valid array-like index.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
	 * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
	 */
	function isIndex(value, length) {
	  var type = typeof value;
	  length = length == null ? MAX_SAFE_INTEGER : length;

	  return !!length &&
	    (type == 'number' ||
	      (type != 'symbol' && reIsUint.test(value))) &&
	        (value > -1 && value % 1 == 0 && value < length);
	}

	module.exports = isIndex;


/***/ }),
/* 62 */
/***/ (function(module, exports) {

	/**
	 * This method returns the first argument it receives.
	 *
	 * @static
	 * @since 0.1.0
	 * @memberOf _
	 * @category Util
	 * @param {*} value Any value.
	 * @returns {*} Returns `value`.
	 * @example
	 *
	 * var object = { 'a': 1 };
	 *
	 * console.log(_.identity(object) === object);
	 * // => true
	 */
	function identity(value) {
	  return value;
	}

	module.exports = identity;


/***/ }),
/* 63 */
/***/ (function(module, exports, __webpack_require__) {

	var baseRest = __webpack_require__(64),
	    eq = __webpack_require__(10),
	    isIterateeCall = __webpack_require__(69),
	    keysIn = __webpack_require__(24);

	/** Used for built-in method references. */
	var objectProto = Object.prototype;

	/** Used to check objects for own properties. */
	var hasOwnProperty = objectProto.hasOwnProperty;

	/**
	 * Assigns own and inherited enumerable string keyed properties of source
	 * objects to the destination object for all destination properties that
	 * resolve to `undefined`. Source objects are applied from left to right.
	 * Once a property is set, additional values of the same property are ignored.
	 *
	 * **Note:** This method mutates `object`.
	 *
	 * @static
	 * @since 0.1.0
	 * @memberOf _
	 * @category Object
	 * @param {Object} object The destination object.
	 * @param {...Object} [sources] The source objects.
	 * @returns {Object} Returns `object`.
	 * @see _.defaultsDeep
	 * @example
	 *
	 * _.defaults({ 'a': 1 }, { 'b': 2 }, { 'a': 3 });
	 * // => { 'a': 1, 'b': 2 }
	 */
	var defaults = baseRest(function(object, sources) {
	  object = Object(object);

	  var index = -1;
	  var length = sources.length;
	  var guard = length > 2 ? sources[2] : undefined;

	  if (guard && isIterateeCall(sources[0], sources[1], guard)) {
	    length = 1;
	  }

	  while (++index < length) {
	    var source = sources[index];
	    var props = keysIn(source);
	    var propsIndex = -1;
	    var propsLength = props.length;

	    while (++propsIndex < propsLength) {
	      var key = props[propsIndex];
	      var value = object[key];

	      if (value === undefined ||
	          (eq(value, objectProto[key]) && !hasOwnProperty.call(object, key))) {
	        object[key] = source[key];
	      }
	    }
	  }

	  return object;
	});

	module.exports = defaults;


/***/ }),
/* 64 */
/***/ (function(module, exports, __webpack_require__) {

	var identity = __webpack_require__(65),
	    overRest = __webpack_require__(66),
	    setToString = __webpack_require__(68);

	/**
	 * The base implementation of `_.rest` which doesn't validate or coerce arguments.
	 *
	 * @private
	 * @param {Function} func The function to apply a rest parameter to.
	 * @param {number} [start=func.length-1] The start position of the rest parameter.
	 * @returns {Function} Returns the new function.
	 */
	function baseRest(func, start) {
	  return setToString(overRest(func, start, identity), func + '');
	}

	module.exports = baseRest;


/***/ }),
/* 65 */
/***/ (function(module, exports) {

	/**
	 * This method returns the first argument it receives.
	 *
	 * @static
	 * @since 0.1.0
	 * @memberOf _
	 * @category Util
	 * @param {*} value Any value.
	 * @returns {*} Returns `value`.
	 * @example
	 *
	 * var object = { 'a': 1 };
	 *
	 * console.log(_.identity(object) === object);
	 * // => true
	 */
	function identity(value) {
	  return value;
	}

	module.exports = identity;


/***/ }),
/* 66 */
/***/ (function(module, exports, __webpack_require__) {

	var apply = __webpack_require__(67);

	/* Built-in method references for those with the same name as other `lodash` methods. */
	var nativeMax = Math.max;

	/**
	 * A specialized version of `baseRest` which transforms the rest array.
	 *
	 * @private
	 * @param {Function} func The function to apply a rest parameter to.
	 * @param {number} [start=func.length-1] The start position of the rest parameter.
	 * @param {Function} transform The rest array transform.
	 * @returns {Function} Returns the new function.
	 */
	function overRest(func, start, transform) {
	  start = nativeMax(start === undefined ? (func.length - 1) : start, 0);
	  return function() {
	    var args = arguments,
	        index = -1,
	        length = nativeMax(args.length - start, 0),
	        array = Array(length);

	    while (++index < length) {
	      array[index] = args[start + index];
	    }
	    index = -1;
	    var otherArgs = Array(start + 1);
	    while (++index < start) {
	      otherArgs[index] = args[index];
	    }
	    otherArgs[start] = transform(array);
	    return apply(func, this, otherArgs);
	  };
	}

	module.exports = overRest;


/***/ }),
/* 67 */
/***/ (function(module, exports) {

	/**
	 * A faster alternative to `Function#apply`, this function invokes `func`
	 * with the `this` binding of `thisArg` and the arguments of `args`.
	 *
	 * @private
	 * @param {Function} func The function to invoke.
	 * @param {*} thisArg The `this` binding of `func`.
	 * @param {Array} args The arguments to invoke `func` with.
	 * @returns {*} Returns the result of `func`.
	 */
	function apply(func, thisArg, args) {
	  switch (args.length) {
	    case 0: return func.call(thisArg);
	    case 1: return func.call(thisArg, args[0]);
	    case 2: return func.call(thisArg, args[0], args[1]);
	    case 3: return func.call(thisArg, args[0], args[1], args[2]);
	  }
	  return func.apply(thisArg, args);
	}

	module.exports = apply;


/***/ }),
/* 68 */
/***/ (function(module, exports) {

	/**
	 * This method returns the first argument it receives.
	 *
	 * @static
	 * @since 0.1.0
	 * @memberOf _
	 * @category Util
	 * @param {*} value Any value.
	 * @returns {*} Returns `value`.
	 * @example
	 *
	 * var object = { 'a': 1 };
	 *
	 * console.log(_.identity(object) === object);
	 * // => true
	 */
	function identity(value) {
	  return value;
	}

	module.exports = identity;


/***/ }),
/* 69 */
/***/ (function(module, exports) {

	/**
	 * This method returns `false`.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.13.0
	 * @category Util
	 * @returns {boolean} Returns `false`.
	 * @example
	 *
	 * _.times(2, _.stubFalse);
	 * // => [false, false]
	 */
	function stubFalse() {
	  return false;
	}

	module.exports = stubFalse;


/***/ }),
/* 70 */
/***/ (function(module, exports, __webpack_require__) {

	var baseMerge = __webpack_require__(71),
	    createAssigner = __webpack_require__(86);

	/**
	 * This method is like `_.assign` except that it recursively merges own and
	 * inherited enumerable string keyed properties of source objects into the
	 * destination object. Source properties that resolve to `undefined` are
	 * skipped if a destination value exists. Array and plain object properties
	 * are merged recursively. Other objects and value types are overridden by
	 * assignment. Source objects are applied from left to right. Subsequent
	 * sources overwrite property assignments of previous sources.
	 *
	 * **Note:** This method mutates `object`.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.5.0
	 * @category Object
	 * @param {Object} object The destination object.
	 * @param {...Object} [sources] The source objects.
	 * @returns {Object} Returns `object`.
	 * @example
	 *
	 * var object = {
	 *   'a': [{ 'b': 2 }, { 'd': 4 }]
	 * };
	 *
	 * var other = {
	 *   'a': [{ 'c': 3 }, { 'e': 5 }]
	 * };
	 *
	 * _.merge(object, other);
	 * // => { 'a': [{ 'b': 2, 'c': 3 }, { 'd': 4, 'e': 5 }] }
	 */
	var merge = createAssigner(function(object, source, srcIndex) {
	  baseMerge(object, source, srcIndex);
	});

	module.exports = merge;


/***/ }),
/* 71 */
/***/ (function(module, exports, __webpack_require__) {

	var Stack = __webpack_require__(6),
	    assignMergeValue = __webpack_require__(72),
	    baseFor = __webpack_require__(73),
	    baseMergeDeep = __webpack_require__(75),
	    isObject = __webpack_require__(41),
	    keysIn = __webpack_require__(24),
	    safeGet = __webpack_require__(84);

	/**
	 * The base implementation of `_.merge` without support for multiple sources.
	 *
	 * @private
	 * @param {Object} object The destination object.
	 * @param {Object} source The source object.
	 * @param {number} srcIndex The index of `source`.
	 * @param {Function} [customizer] The function to customize merged values.
	 * @param {Object} [stack] Tracks traversed source values and their merged
	 *  counterparts.
	 */
	function baseMerge(object, source, srcIndex, customizer, stack) {
	  if (object === source) {
	    return;
	  }
	  baseFor(source, function(srcValue, key) {
	    stack || (stack = new Stack);
	    if (isObject(srcValue)) {
	      baseMergeDeep(object, source, key, srcIndex, baseMerge, customizer, stack);
	    }
	    else {
	      var newValue = customizer
	        ? customizer(safeGet(object, key), srcValue, (key + ''), object, source, stack)
	        : undefined;

	      if (newValue === undefined) {
	        newValue = srcValue;
	      }
	      assignMergeValue(object, key, newValue);
	    }
	  }, keysIn);
	}

	module.exports = baseMerge;


/***/ }),
/* 72 */
/***/ (function(module, exports, __webpack_require__) {

	var baseAssignValue = __webpack_require__(16),
	    eq = __webpack_require__(10);

	/**
	 * This function is like `assignValue` except that it doesn't assign
	 * `undefined` values.
	 *
	 * @private
	 * @param {Object} object The object to modify.
	 * @param {string} key The key of the property to assign.
	 * @param {*} value The value to assign.
	 */
	function assignMergeValue(object, key, value) {
	  if ((value !== undefined && !eq(object[key], value)) ||
	      (value === undefined && !(key in object))) {
	    baseAssignValue(object, key, value);
	  }
	}

	module.exports = assignMergeValue;


/***/ }),
/* 73 */
/***/ (function(module, exports, __webpack_require__) {

	var createBaseFor = __webpack_require__(74);

	/**
	 * The base implementation of `baseForOwn` which iterates over `object`
	 * properties returned by `keysFunc` and invokes `iteratee` for each property.
	 * Iteratee functions may exit iteration early by explicitly returning `false`.
	 *
	 * @private
	 * @param {Object} object The object to iterate over.
	 * @param {Function} iteratee The function invoked per iteration.
	 * @param {Function} keysFunc The function to get the keys of `object`.
	 * @returns {Object} Returns `object`.
	 */
	var baseFor = createBaseFor();

	module.exports = baseFor;


/***/ }),
/* 74 */
/***/ (function(module, exports) {

	/**
	 * Creates a base function for methods like `_.forIn` and `_.forOwn`.
	 *
	 * @private
	 * @param {boolean} [fromRight] Specify iterating from right to left.
	 * @returns {Function} Returns the new base function.
	 */
	function createBaseFor(fromRight) {
	  return function(object, iteratee, keysFunc) {
	    var index = -1,
	        iterable = Object(object),
	        props = keysFunc(object),
	        length = props.length;

	    while (length--) {
	      var key = props[fromRight ? length : ++index];
	      if (iteratee(iterable[key], key, iterable) === false) {
	        break;
	      }
	    }
	    return object;
	  };
	}

	module.exports = createBaseFor;


/***/ }),
/* 75 */
/***/ (function(module, exports, __webpack_require__) {

	var assignMergeValue = __webpack_require__(72),
	    cloneBuffer = __webpack_require__(25),
	    cloneTypedArray = __webpack_require__(76),
	    copyArray = __webpack_require__(29),
	    initCloneObject = __webpack_require__(39),
	    isArguments = __webpack_require__(79),
	    isArray = __webpack_require__(44),
	    isArrayLikeObject = __webpack_require__(80),
	    isBuffer = __webpack_require__(45),
	    isFunction = __webpack_require__(52),
	    isObject = __webpack_require__(41),
	    isPlainObject = __webpack_require__(49),
	    isTypedArray = __webpack_require__(83),
	    safeGet = __webpack_require__(84),
	    toPlainObject = __webpack_require__(85);

	/**
	 * A specialized version of `baseMerge` for arrays and objects which performs
	 * deep merges and tracks traversed objects enabling objects with circular
	 * references to be merged.
	 *
	 * @private
	 * @param {Object} object The destination object.
	 * @param {Object} source The source object.
	 * @param {string} key The key of the value to merge.
	 * @param {number} srcIndex The index of `source`.
	 * @param {Function} mergeFunc The function to merge values.
	 * @param {Function} [customizer] The function to customize assigned values.
	 * @param {Object} [stack] Tracks traversed source values and their merged
	 *  counterparts.
	 */
	function baseMergeDeep(object, source, key, srcIndex, mergeFunc, customizer, stack) {
	  var objValue = safeGet(object, key),
	      srcValue = safeGet(source, key),
	      stacked = stack.get(srcValue);

	  if (stacked) {
	    assignMergeValue(object, key, stacked);
	    return;
	  }
	  var newValue = customizer
	    ? customizer(objValue, srcValue, (key + ''), object, source, stack)
	    : undefined;

	  var isCommon = newValue === undefined;

	  if (isCommon) {
	    var isArr = isArray(srcValue),
	        isBuff = !isArr && isBuffer(srcValue),
	        isTyped = !isArr && !isBuff && isTypedArray(srcValue);

	    newValue = srcValue;
	    if (isArr || isBuff || isTyped) {
	      if (isArray(objValue)) {
	        newValue = objValue;
	      }
	      else if (isArrayLikeObject(objValue)) {
	        newValue = copyArray(objValue);
	      }
	      else if (isBuff) {
	        isCommon = false;
	        newValue = cloneBuffer(srcValue, true);
	      }
	      else if (isTyped) {
	        isCommon = false;
	        newValue = cloneTypedArray(srcValue, true);
	      }
	      else {
	        newValue = [];
	      }
	    }
	    else if (isPlainObject(srcValue) || isArguments(srcValue)) {
	      newValue = objValue;
	      if (isArguments(objValue)) {
	        newValue = toPlainObject(objValue);
	      }
	      else if (!isObject(objValue) || isFunction(objValue)) {
	        newValue = initCloneObject(srcValue);
	      }
	    }
	    else {
	      isCommon = false;
	    }
	  }
	  if (isCommon) {
	    // Recursively merge objects and arrays (susceptible to call stack limits).
	    stack.set(srcValue, newValue);
	    mergeFunc(newValue, srcValue, srcIndex, customizer, stack);
	    stack['delete'](srcValue);
	  }
	  assignMergeValue(object, key, newValue);
	}

	module.exports = baseMergeDeep;


/***/ }),
/* 76 */
/***/ (function(module, exports, __webpack_require__) {

	var cloneArrayBuffer = __webpack_require__(77);

	/**
	 * Creates a clone of `typedArray`.
	 *
	 * @private
	 * @param {Object} typedArray The typed array to clone.
	 * @param {boolean} [isDeep] Specify a deep clone.
	 * @returns {Object} Returns the cloned typed array.
	 */
	function cloneTypedArray(typedArray, isDeep) {
	  var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
	  return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
	}

	module.exports = cloneTypedArray;


/***/ }),
/* 77 */
/***/ (function(module, exports, __webpack_require__) {

	var Uint8Array = __webpack_require__(78);

	/**
	 * Creates a clone of `arrayBuffer`.
	 *
	 * @private
	 * @param {ArrayBuffer} arrayBuffer The array buffer to clone.
	 * @returns {ArrayBuffer} Returns the cloned array buffer.
	 */
	function cloneArrayBuffer(arrayBuffer) {
	  var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
	  new Uint8Array(result).set(new Uint8Array(arrayBuffer));
	  return result;
	}

	module.exports = cloneArrayBuffer;


/***/ }),
/* 78 */
/***/ (function(module, exports, __webpack_require__) {

	var root = __webpack_require__(27);

	/** Built-in value references. */
	var Uint8Array = root.Uint8Array;

	module.exports = Uint8Array;


/***/ }),
/* 79 */
/***/ (function(module, exports) {

	/**
	 * This method returns `false`.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.13.0
	 * @category Util
	 * @returns {boolean} Returns `false`.
	 * @example
	 *
	 * _.times(2, _.stubFalse);
	 * // => [false, false]
	 */
	function stubFalse() {
	  return false;
	}

	module.exports = stubFalse;


/***/ }),
/* 80 */
/***/ (function(module, exports, __webpack_require__) {

	var isArrayLike = __webpack_require__(81),
	    isObjectLike = __webpack_require__(51);

	/**
	 * This method is like `_.isArrayLike` except that it also checks if `value`
	 * is an object.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is an array-like object,
	 *  else `false`.
	 * @example
	 *
	 * _.isArrayLikeObject([1, 2, 3]);
	 * // => true
	 *
	 * _.isArrayLikeObject(document.body.children);
	 * // => true
	 *
	 * _.isArrayLikeObject('abc');
	 * // => false
	 *
	 * _.isArrayLikeObject(_.noop);
	 * // => false
	 */
	function isArrayLikeObject(value) {
	  return isObjectLike(value) && isArrayLike(value);
	}

	module.exports = isArrayLikeObject;


/***/ }),
/* 81 */
/***/ (function(module, exports, __webpack_require__) {

	var isFunction = __webpack_require__(52),
	    isLength = __webpack_require__(82);

	/**
	 * Checks if `value` is array-like. A value is considered array-like if it's
	 * not a function and has a `value.length` that's an integer greater than or
	 * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
	 * @example
	 *
	 * _.isArrayLike([1, 2, 3]);
	 * // => true
	 *
	 * _.isArrayLike(document.body.children);
	 * // => true
	 *
	 * _.isArrayLike('abc');
	 * // => true
	 *
	 * _.isArrayLike(_.noop);
	 * // => false
	 */
	function isArrayLike(value) {
	  return value != null && isLength(value.length) && !isFunction(value);
	}

	module.exports = isArrayLike;


/***/ }),
/* 82 */
/***/ (function(module, exports) {

	/** Used as references for various `Number` constants. */
	var MAX_SAFE_INTEGER = 9007199254740991;

	/**
	 * Checks if `value` is a valid array-like length.
	 *
	 * **Note:** This method is loosely based on
	 * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
	 * @example
	 *
	 * _.isLength(3);
	 * // => true
	 *
	 * _.isLength(Number.MIN_VALUE);
	 * // => false
	 *
	 * _.isLength(Infinity);
	 * // => false
	 *
	 * _.isLength('3');
	 * // => false
	 */
	function isLength(value) {
	  return typeof value == 'number' &&
	    value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
	}

	module.exports = isLength;


/***/ }),
/* 83 */
/***/ (function(module, exports) {

	/**
	 * This method returns `false`.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.13.0
	 * @category Util
	 * @returns {boolean} Returns `false`.
	 * @example
	 *
	 * _.times(2, _.stubFalse);
	 * // => [false, false]
	 */
	function stubFalse() {
	  return false;
	}

	module.exports = stubFalse;


/***/ }),
/* 84 */
/***/ (function(module, exports) {

	/**
	 * Gets the value at `key`, unless `key` is "__proto__" or "constructor".
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @param {string} key The key of the property to get.
	 * @returns {*} Returns the property value.
	 */
	function safeGet(object, key) {
	  if (key === 'constructor' && typeof object[key] === 'function') {
	    return;
	  }

	  if (key == '__proto__') {
	    return;
	  }

	  return object[key];
	}

	module.exports = safeGet;


/***/ }),
/* 85 */
/***/ (function(module, exports, __webpack_require__) {

	var copyObject = __webpack_require__(20),
	    keysIn = __webpack_require__(24);

	/**
	 * Converts `value` to a plain object flattening inherited enumerable string
	 * keyed properties of `value` to own properties of the plain object.
	 *
	 * @static
	 * @memberOf _
	 * @since 3.0.0
	 * @category Lang
	 * @param {*} value The value to convert.
	 * @returns {Object} Returns the converted plain object.
	 * @example
	 *
	 * function Foo() {
	 *   this.b = 2;
	 * }
	 *
	 * Foo.prototype.c = 3;
	 *
	 * _.assign({ 'a': 1 }, new Foo);
	 * // => { 'a': 1, 'b': 2 }
	 *
	 * _.assign({ 'a': 1 }, _.toPlainObject(new Foo));
	 * // => { 'a': 1, 'b': 2, 'c': 3 }
	 */
	function toPlainObject(value) {
	  return copyObject(value, keysIn(value));
	}

	module.exports = toPlainObject;


/***/ }),
/* 86 */
/***/ (function(module, exports, __webpack_require__) {

	var baseRest = __webpack_require__(64),
	    isIterateeCall = __webpack_require__(69);

	/**
	 * Creates a function like `_.assign`.
	 *
	 * @private
	 * @param {Function} assigner The function to assign values.
	 * @returns {Function} Returns the new assigner function.
	 */
	function createAssigner(assigner) {
	  return baseRest(function(object, sources) {
	    var index = -1,
	        length = sources.length,
	        customizer = length > 1 ? sources[length - 1] : undefined,
	        guard = length > 2 ? sources[2] : undefined;

	    customizer = (assigner.length > 3 && typeof customizer == 'function')
	      ? (length--, customizer)
	      : undefined;

	    if (guard && isIterateeCall(sources[0], sources[1], guard)) {
	      customizer = length < 3 ? undefined : customizer;
	      length = 1;
	    }
	    object = Object(object);
	    while (++index < length) {
	      var source = sources[index];
	      if (source) {
	        assigner(object, source, index, customizer);
	      }
	    }
	    return object;
	  });
	}

	module.exports = createAssigner;


/***/ }),
/* 87 */
/***/ (function(module, exports, __webpack_require__) {

	var castPath = __webpack_require__(55),
	    isFunction = __webpack_require__(52),
	    toKey = __webpack_require__(62);

	/**
	 * This method is like `_.get` except that if the resolved value is a
	 * function it's invoked with the `this` binding of its parent object and
	 * its result is returned.
	 *
	 * @static
	 * @since 0.1.0
	 * @memberOf _
	 * @category Object
	 * @param {Object} object The object to query.
	 * @param {Array|string} path The path of the property to resolve.
	 * @param {*} [defaultValue] The value returned for `undefined` resolved values.
	 * @returns {*} Returns the resolved value.
	 * @example
	 *
	 * var object = { 'a': [{ 'b': { 'c1': 3, 'c2': _.constant(4) } }] };
	 *
	 * _.result(object, 'a[0].b.c1');
	 * // => 3
	 *
	 * _.result(object, 'a[0].b.c2');
	 * // => 4
	 *
	 * _.result(object, 'a[0].b.c3', 'default');
	 * // => 'default'
	 *
	 * _.result(object, 'a[0].b.c3', _.constant('default'));
	 * // => 'default'
	 */
	function result(object, path, defaultValue) {
	  path = castPath(path, object);

	  var index = -1,
	      length = path.length;

	  // Ensure the loop is entered when path is empty.
	  if (!length) {
	    length = 1;
	    object = undefined;
	  }
	  while (++index < length) {
	    var value = object == null ? undefined : object[toKey(path[index])];
	    if (value === undefined) {
	      index = length;
	      value = defaultValue;
	    }
	    object = isFunction(value) ? value.call(object) : value;
	  }
	  return object;
	}

	module.exports = result;


/***/ }),
/* 88 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var __assign = (this && this.__assign) || function () {
	    __assign = Object.assign || function(t) {
	        for (var s, i = 1, n = arguments.length; i < n; i++) {
	            s = arguments[i];
	            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
	                t[p] = s[p];
	        }
	        return t;
	    };
	    return __assign.apply(this, arguments);
	};
	var __importDefault = (this && this.__importDefault) || function (mod) {
	    return (mod && mod.__esModule) ? mod : { "default": mod };
	};
	Object.defineProperty(exports, "__esModule", { value: true });
	// (C) 2007-2019 GoodData Corporation
	var get_1 = __importDefault(__webpack_require__(89));
	var promise_1 = __webpack_require__(91);
	var xhr_1 = __webpack_require__(48);
	var package_json_1 = __webpack_require__(92);
	/**
	 * Utility methods. Mostly private
	 *
	 * @module util
	 * @class util
	 *
	 */
	/**
	 * Gooddata-js package signature
	 * @private
	 */
	exports.thisPackage = { name: package_json_1.name, version: package_json_1.version };
	/**
	 * Create getter function for accessing nested objects
	 *
	 * @param {String} path Target path to nested object
	 * @method getIn
	 * @private
	 */
	exports.getIn = function (path) { return function (object) { return get_1.default(object, path); }; };
	/**
	 * Helper for polling
	 *
	 * @param xhrRequest xhr module
	 * @param {String} uri
	 * @param {Function} isPollingDone
	 * @param {Object} options for polling (maxAttempts, pollStep)
	 * @private
	 */
	exports.handlePolling = function (xhrRequest, uri, isPollingDone, options) {
	    if (options === void 0) { options = {}; }
	    // TODO
	    var _a = options.attempts, attempts = _a === void 0 ? 0 : _a, _b = options.maxAttempts, maxAttempts = _b === void 0 ? 50 : _b, _c = options.pollStep, pollStep = _c === void 0 ? 5000 : _c;
	    return xhrRequest(uri)
	        .then(function (r) { return r.getData(); })
	        .then(function (response) {
	        if (attempts > maxAttempts) {
	            return Promise.reject(new Error(response));
	        }
	        return isPollingDone(response)
	            ? Promise.resolve(response)
	            : promise_1.delay(pollStep).then(function () {
	                return exports.handlePolling(xhrRequest, uri, isPollingDone, __assign({}, options, { attempts: attempts + 1 }));
	            });
	    });
	};
	/**
	 * Helper for polling with header status
	 *
	 * @param xhrRequest xhr module
	 * @param {String} uri
	 * @param {Function} isPollingDone
	 * @param {Object} options for polling (maxAttempts, pollStep)
	 * @private
	 */
	exports.handleHeadPolling = function (xhrRequest, uri, isPollingDone, options) {
	    if (options === void 0) { options = {}; }
	    var _a = options.attempts, attempts = _a === void 0 ? 0 : _a, _b = options.maxAttempts, maxAttempts = _b === void 0 ? 50 : _b, _c = options.pollStep, pollStep = _c === void 0 ? 5000 : _c;
	    return xhrRequest(uri).then(function (response) {
	        if (attempts > maxAttempts) {
	            return Promise.reject(new Error("Export timeout!!!"));
	        }
	        var responseHeaders = response.getHeaders();
	        if (isPollingDone(responseHeaders, response)) {
	            if (responseHeaders.status === 200) {
	                return Promise.resolve({ uri: uri });
	            }
	            return Promise.reject(new xhr_1.ApiResponseError(response.statusText, response, response.getData()));
	        }
	        else {
	            return promise_1.delay(pollStep).then(function () {
	                return exports.handleHeadPolling(xhrRequest, uri, isPollingDone, __assign({}, options, { attempts: attempts + 1 }));
	            });
	        }
	    });
	};
	/**
	 * Builds query string from plain object
	 * (Refactored from admin/routes.js)
	 *
	 * @param {Object} query parameters possibly including arrays inside
	 * @returns {string} querystring
	 */
	function queryString(query) {
	    function getSingleParam(key, value) {
	        return Array.isArray(value)
	            ? value.map(function (item) { return encodeURIComponent(key) + "=" + encodeURIComponent(item); }).join("&")
	            : encodeURIComponent(key) + "=" + encodeURIComponent(value);
	    }
	    return query
	        ? "?" + Object.keys(query)
	            .map(function (k) { return getSingleParam(k, query[k]); })
	            .join("&")
	        : "";
	}
	exports.queryString = queryString;
	/**
	 * Get all results from paged api by traversing all resulting pages
	 * This is usable for apis which support offset and limit (i.e. not those with next paging links)
	 *
	 * @param xhrGet xhr module
	 * @param {string} uri uri to be fetched, will append offset and limit for next pages
	 * @param {string} itemKey key under which to look for results (differs for different apis)
	 * @param {number} optional offset starting offset, default 0
	 * @param pagesData optional data to be pre-filled
	 */
	function getAllPagesByOffsetLimit(xhr, uri, itemKey, offset, pagesData) {
	    if (offset === void 0) { offset = 0; }
	    if (pagesData === void 0) { pagesData = []; }
	    var PAGE_LIMIT = 100;
	    return new Promise(function (resolve, reject) {
	        xhr.get(uri + "?offset=" + offset + "&limit=" + PAGE_LIMIT)
	            .then(function (r) { return r.getData(); })
	            .then(function (dataObjects) {
	            var projects = get_1.default(dataObjects, itemKey);
	            var data = pagesData.concat(projects.items);
	            var totalCount = get_1.default(projects, "paging.totalCount", 0);
	            var nextPage = offset + PAGE_LIMIT;
	            if (nextPage > totalCount) {
	                resolve(data);
	            }
	            else {
	                resolve(getAllPagesByOffsetLimit(xhr, uri, itemKey, nextPage, data));
	            }
	        }, reject);
	    });
	}
	exports.getAllPagesByOffsetLimit = getAllPagesByOffsetLimit;


/***/ }),
/* 89 */
/***/ (function(module, exports, __webpack_require__) {

	var baseGet = __webpack_require__(90);

	/**
	 * Gets the value at `path` of `object`. If the resolved value is
	 * `undefined`, the `defaultValue` is returned in its place.
	 *
	 * @static
	 * @memberOf _
	 * @since 3.7.0
	 * @category Object
	 * @param {Object} object The object to query.
	 * @param {Array|string} path The path of the property to get.
	 * @param {*} [defaultValue] The value returned for `undefined` resolved values.
	 * @returns {*} Returns the resolved value.
	 * @example
	 *
	 * var object = { 'a': [{ 'b': { 'c': 3 } }] };
	 *
	 * _.get(object, 'a[0].b.c');
	 * // => 3
	 *
	 * _.get(object, ['a', '0', 'b', 'c']);
	 * // => 3
	 *
	 * _.get(object, 'a.b.c', 'default');
	 * // => 'default'
	 */
	function get(object, path, defaultValue) {
	  var result = object == null ? undefined : baseGet(object, path);
	  return result === undefined ? defaultValue : result;
	}

	module.exports = get;


/***/ }),
/* 90 */
/***/ (function(module, exports, __webpack_require__) {

	var castPath = __webpack_require__(55),
	    toKey = __webpack_require__(62);

	/**
	 * The base implementation of `_.get` without support for default values.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @param {Array|string} path The path of the property to get.
	 * @returns {*} Returns the resolved value.
	 */
	function baseGet(object, path) {
	  path = castPath(path, object);

	  var index = 0,
	      length = path.length;

	  while (object != null && index < length) {
	    object = object[toKey(path[index++])];
	  }
	  return (index && index == length) ? object : undefined;
	}

	module.exports = baseGet;


/***/ }),
/* 91 */
/***/ (function(module, exports) {

	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	// (C) 2007-2018 GoodData Corporation
	/**
	 * Return promise that will resolve after `ms` miliseconds
	 *
	 * @param {Number} ms time in miliseconds
	 * @return {Promise}
	 */
	function delay(ms) {
	    return new Promise(function (resolve) {
	        setTimeout(function () { return resolve(); }, ms);
	    });
	}
	exports.delay = delay;


/***/ }),
/* 92 */
/***/ (function(module, exports) {

	module.exports = {
		"name": "@gooddata/gooddata-js",
		"version": "13.0.4",
		"author": "GoodData",
		"description": "GoodData JavaScript SDK",
		"license": "BSD-3-Clause",
		"main": "lib/gooddata-node.js",
		"browser": "lib/gooddata-browser.js",
		"typings": "lib/gooddata-browser.d.ts",
		"files": [
			"dist",
			"lib",
			"src",
			"LICENSE"
		],
		"config": {
			"tslint": "./{src,test}/**/*.ts"
		},
		"scripts": {
			"dev": "tsc --watch",
			"build": "yarn run build:lib && yarn run build:dist",
			"build:lib": "rm -rf lib && tsc -p tsconfig.build.json",
			"build:dist": "rm -rf dist && grunt dist",
			"prepublishOnly": "yarn run build",
			"test": "jest --watch",
			"test-once": "jest",
			"test-ci": "JEST_JUNIT_OUTPUT=./ci/results/test-results.xml jest --config jest.ci.json",
			"run-tslint": "tslint -p tsconfig.json",
			"tslint": "yarn run-tslint -t verbose $npm_package_config_tslint",
			"tslint-ci": "mkdir -p ./ci/results && yarn run-tslint -t checkstyle -o ./ci/results/tslint-results.xml $npm_package_config_tslint",
			"prettier-check": "prettier --check '{src,test}/**/*.{ts,tsx,json,scss,md,yaml,html}'",
			"prettier-write": "prettier --write '{src,test}/**/*.{ts,tsx,json,scss,md,yaml,html}'",
			"validate": "tsc --noEmit && yarn tslint && yarn prettier-check",
			"validate-ci": "tsc --noEmit && yarn tslint-ci && yarn prettier-check"
		},
		"repository": {
			"type": "git",
			"url": "git@github.com:gooddata/gooddata-js.git"
		},
		"jest": {
			"setupFilesAfterEnv": [
				"<rootDir>/jest.setup.js"
			],
			"transform": {
				".(ts|tsx)": "ts-jest"
			},
			"testRegex": "(/__tests__/.*|\\.(test|spec))\\.(tsx?)$",
			"collectCoverageFrom": [
				"src/**/*.{ts,tsx}",
				"!**/*.d.ts"
			],
			"collectCoverage": false,
			"coverageReporters": [
				"html"
			],
			"moduleFileExtensions": [
				"ts",
				"tsx",
				"js"
			]
		},
		"devDependencies": {
			"@gooddata/frontend-npm-scripts": "1.2.0",
			"@gooddata/tslint-config": "^1.0.0",
			"@types/fast-levenshtein": "0.0.1",
			"@types/fetch-mock": "5.*",
			"@types/invariant": "^2.2.29",
			"@types/isomorphic-fetch": "^0.0.34",
			"@types/jest": "24.0.6",
			"@types/json-stable-stringify": "^1.0.32",
			"@types/lodash": "^4.14.121",
			"@types/md5": "^2.1.32",
			"@types/node-fetch": "1.6.7",
			"@types/qs": "^6.5.1",
			"@types/uuid": "^3.4.4",
			"async": "2.1.5",
			"exports-loader": "0.6.3",
			"fast-levenshtein": "2.0.6",
			"fetch-mock": "5.12.2",
			"grunt": "1.0.4",
			"grunt-cli": "1.2.0",
			"grunt-contrib-copy": "0.8.2",
			"grunt-contrib-watch": "1.1.0",
			"grunt-contrib-yuidoc": "1.0.0",
			"grunt-gh-pages": "2.0.0",
			"grunt-grizzly": "0.17.0",
			"grunt-run": "0.8.0",
			"grunt-webpack": "1.0.14",
			"husky": "3.0.0",
			"imports-loader": "0.7.0",
			"istanbul-instrumenter-loader": "0.2.0",
			"jest": "^25.5.4",
			"jest-junit": "3.0.0",
			"js-object-pretty-print": "0.2.0",
			"json-loader": "0.5.4",
			"lint-staged": "9.1.0",
			"lodash-webpack-plugin": "0.11.0",
			"prettier": "^1.18.2",
			"ts-jest": "25.3.1",
			"ts-loader": "3.5.0",
			"tslint-config-prettier": "^1.18.0",
			"typescript": "3.3.4000",
			"webpack": "^1.15.0",
			"webpack-dev-server": "^1.16.5"
		},
		"dependencies": {
			"@gooddata/typings": "^2.26.0",
			"es6-promise": "^3.0.2",
			"fetch-cookie": "^0.7.0",
			"invariant": "^2.2.2",
			"isomorphic-fetch": "^2.2.1",
			"json-stable-stringify": "^1.0.1",
			"lodash": "^4.7.11",
			"md5": "^2.2.1",
			"node-fetch": "^1.7.3",
			"qs": "^6.5.1",
			"rxjs": "^5.5.6",
			"uuid": "^3.2.1"
		},
		"husky": {
			"hooks": {
				"pre-commit": "lint-staged"
			}
		},
		"lint-staged": {
			"{src,test}/**/*.{ts,tsx,json,scss,md,yaml,html}": [
				"prettier --write",
				"git add"
			],
			"{src,test}/**/*.{ts,js,tsx,jsx,scss}": [
				"npx gdc-fix-copyright",
				"git add"
			]
		}
	};

/***/ }),
/* 93 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var __importDefault = (this && this.__importDefault) || function (mod) {
	    return (mod && mod.__esModule) ? mod : { "default": mod };
	};
	Object.defineProperty(exports, "__esModule", { value: true });
	var project_1 = __webpack_require__(94);
	var qs_1 = __importDefault(__webpack_require__(95));
	var UserModule = /** @class */ (function () {
	    function UserModule(xhr) {
	        this.xhr = xhr;
	    }
	    /**
	     * Find out whether a user is logged in
	     *
	     * @return {Promise} resolves with true if user logged in, false otherwise
	     * @method isLoggedIn
	     */
	    UserModule.prototype.isLoggedIn = function () {
	        var _this = this;
	        return new Promise(function (resolve, reject) {
	            _this.xhr.get("/gdc/account/token").then(function (r) {
	                if (r.response.ok) {
	                    resolve(true);
	                }
	                resolve(false);
	            }, function (err) {
	                if (err.response.status === 401) {
	                    resolve(false);
	                }
	                else {
	                    reject(err);
	                }
	            });
	        });
	    };
	    /**
	     * Find out whether a specified project is available to a currently logged user
	     *
	     * @method isLoggedInProject
	     * @param {String} projectId A project identifier
	     * @return {Promise} Resolves with true if user logged in and project available,
	     *                   resolves with false if user logged in and project not available,
	     *                   rejects if user not logged in
	     */
	    UserModule.prototype.isLoggedInProject = function (projectId) {
	        var _this = this;
	        return this.getCurrentProfile().then(function (profile) {
	            return new Promise(function (resolve, reject) {
	                var projectModule = new project_1.ProjectModule(_this.xhr);
	                projectModule.getProjects(profile.links.self.split("/")[4]).then(function (projects) {
	                    if (projects.find(function (p) { return p.links.self === "/gdc/projects/" + projectId; })) {
	                        resolve(true);
	                    }
	                    else {
	                        resolve(false);
	                    }
	                }, function (err) {
	                    reject(err);
	                });
	            });
	        });
	    };
	    /**
	     * This function provides an authentication entry point to the GD API. It is needed to authenticate
	     * by calling this function prior any other API calls. After providing valid credentials
	     * every subsequent API call in a current session will be authenticated.
	     *
	     * @method login
	     * @param {String} username
	     * @param {String} password
	     */
	    UserModule.prototype.login = function (username, password) {
	        return this.xhr
	            .post("/gdc/account/login", {
	            body: JSON.stringify({
	                postUserLogin: {
	                    login: username,
	                    password: password,
	                    remember: 1,
	                    captcha: "",
	                    verifyCaptcha: "",
	                },
	            }),
	        })
	            .then(function (r) { return r.getData(); });
	    };
	    /**
	     * This function provides an authentication entry point to the GD API via SSO
	     * https://help.gooddata.com/display/developer/GoodData+PGP+Single+Sign-On
	     *
	     * @method loginSso
	     * @param {String} encryptedClaims PGP message
	     * @param {String} ssoProvider
	     * @param {String} targetUrl
	     */
	    UserModule.prototype.loginSso = function (encryptedClaims, ssoProvider, targetUrl) {
	        return this.xhr.post("/gdc/account/customerlogin", {
	            data: {
	                pgpLoginRequest: {
	                    targetUrl: targetUrl,
	                    ssoProvider: ssoProvider,
	                    encryptedClaims: encryptedClaims,
	                },
	            },
	        });
	    };
	    /**
	     * Logs out current user
	     * @method logout
	     */
	    UserModule.prototype.logout = function () {
	        var _this = this;
	        return this.isLoggedIn().then(function (loggedIn) {
	            if (loggedIn) {
	                return _this.xhr.get("/gdc/app/account/bootstrap").then(function (result) {
	                    var data = result.getData();
	                    var userUri = data.bootstrapResource.accountSetting.links.self;
	                    var userId = userUri.match(/([^\/]+)\/?$/)[1];
	                    return _this.xhr.del("/gdc/account/login/" + userId);
	                });
	            }
	            return Promise.resolve();
	        }, function (err) { return Promise.reject(err); });
	    };
	    /**
	     * Gets current user's profile
	     * @method getCurrentProfile
	     * @return {Promise} Resolves with account setting object
	     */
	    UserModule.prototype.getCurrentProfile = function () {
	        return this.xhr.get("/gdc/account/profile/current").then(function (r) { return r.getData().accountSetting; });
	    };
	    /**
	     * Updates user's profile settings
	     * @method updateProfileSettings
	     * @param {String} profileId - User profile identifier
	     * @param {Object} profileSetting
	     */
	    UserModule.prototype.updateProfileSettings = function (profileId, profileSetting) {
	        // TODO
	        return this.xhr.put("/gdc/account/profile/" + profileId + "/settings", {
	            body: profileSetting,
	        });
	    };
	    /**
	     * Returns info about currently logged in user from bootstrap resource
	     * @method getAccountInfo
	     */
	    UserModule.prototype.getAccountInfo = function () {
	        var _this = this;
	        return this.xhr.get("/gdc/app/account/bootstrap").then(function (result) {
	            var data = result.getData();
	            return _this.getAccountInfoInBootstrap(data);
	        });
	    };
	    /**
	     * Returns current user info from bootstrapData
	     * @method getAccountInfoInBootstrap
	     * @param bootstrapData - data was got from bootstrap resource
	     */
	    UserModule.prototype.getAccountInfoInBootstrap = function (bootstrapData) {
	        var _a = bootstrapData.bootstrapResource, _b = _a.accountSetting, login = _b.login, firstName = _b.firstName, lastName = _b.lastName, profileUri = _b.links.self, loginMD5 = _a.current.loginMD5, organizationName = _a.settings.organizationName;
	        return {
	            login: login,
	            loginMD5: loginMD5,
	            firstName: firstName,
	            lastName: lastName,
	            organizationName: organizationName,
	            profileUri: profileUri,
	        };
	    };
	    /**
	     * Gets user configs including user specific feature flags
	     *
	     * @param {String} userId - A user identifier
	     * @return {IUserConfigsSettingItem[]} An array of user configs setting item
	     */
	    UserModule.prototype.getUserConfigs = function (userId) {
	        return this.xhr.get("/gdc/account/profile/" + userId + "/config").then(function (apiResponse) {
	            var userConfigs = apiResponse.getData();
	            var items = userConfigs.settings.items;
	            return items || [];
	        });
	    };
	    /**
	     * Returns the feature flags valid for the currently logged in user.
	     * @method getFeatureFlags
	     */
	    UserModule.prototype.getFeatureFlags = function () {
	        return this.xhr
	            .get("/gdc/app/account/bootstrap")
	            .then(function (r) { return r.getData(); })
	            .then(function (result) { return result.bootstrapResource.current.featureFlags; });
	    };
	    /**
	     * Initiates SPI SAML SSO
	     * @param relayState URL of the page where the user is redirected after a successful login
	     */
	    UserModule.prototype.initiateSamlSso = function (relayState) {
	        this.xhr
	            .get("/gdc/account/samlrequest?" + qs_1.default.stringify({ relayState: relayState }))
	            .then(function (data) { return data.getData(); })
	            .then(function (response) {
	            var loginUrl = response.samlRequests.items[0].samlRequest.loginUrl;
	            window.location.assign(loginUrl);
	        });
	    };
	    return UserModule;
	}());
	exports.UserModule = UserModule;


/***/ }),
/* 94 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	// (C) 2007-2020 GoodData Corporation
	var util_1 = __webpack_require__(88);
	var DEFAULT_PALETTE = [
	    { r: 0x2b, g: 0x6b, b: 0xae },
	    { r: 0x69, g: 0xaa, b: 0x51 },
	    { r: 0xee, g: 0xb1, b: 0x4c },
	    { r: 0xd5, g: 0x3c, b: 0x38 },
	    { r: 0x89, g: 0x4d, b: 0x94 },
	    { r: 0x73, g: 0x73, b: 0x73 },
	    { r: 0x44, g: 0xa9, b: 0xbe },
	    { r: 0x96, g: 0xbd, b: 0x5f },
	    { r: 0xfd, g: 0x93, b: 0x69 },
	    { r: 0xe1, g: 0x5d, b: 0x86 },
	    { r: 0x7c, g: 0x6f, b: 0xad },
	    { r: 0xa5, g: 0xa5, b: 0xa5 },
	    { r: 0x7a, g: 0xa6, b: 0xd5 },
	    { r: 0x82, g: 0xd0, b: 0x8d },
	    { r: 0xff, g: 0xd2, b: 0x89 },
	    { r: 0xf1, g: 0x84, b: 0x80 },
	    { r: 0xbf, g: 0x90, b: 0xc6 },
	    { r: 0xbf, g: 0xbf, b: 0xbf },
	];
	var isProjectCreated = function (project) {
	    // TODO
	    var projectState = project.content.state;
	    return projectState === "ENABLED" || projectState === "DELETED";
	};
	// Parses string values to boolean, number and string
	exports.parseSettingItemValue = function (value) {
	    if (value === "true") {
	        return true;
	    }
	    if (value === "false") {
	        return false;
	    }
	    var nr = Number(value);
	    if (nr.toString() === value) {
	        return nr;
	    }
	    return value;
	};
	/**
	 * Functions for working with projects
	 *
	 * @class project
	 * @module project
	 */
	var ProjectModule = /** @class */ (function () {
	    function ProjectModule(xhr) {
	        this.xhr = xhr;
	    }
	    /**
	     * Get current project id
	     *
	     * @method getCurrentProjectId
	     * @return {String} current project identifier
	     */
	    ProjectModule.prototype.getCurrentProjectId = function () {
	        return this.xhr
	            .get("/gdc/app/account/bootstrap")
	            .then(function (r) { return r.getData(); })
	            .then(this.getCurrentProjectIdInBootstrap);
	    };
	    /**
	     * Return current project id in bootstrap
	     * @method getCurrentProjectIdInBootstrap
	     * @param bootstrapData - data was got from bootstrap resource
	     */
	    ProjectModule.prototype.getCurrentProjectIdInBootstrap = function (bootstrapData) {
	        var currentProject = bootstrapData.bootstrapResource.current.project;
	        // handle situation in which current project is missing (e.g. new user)
	        if (!currentProject) {
	            return null;
	        }
	        return bootstrapData.bootstrapResource.current.project.links.self.split("/").pop();
	    };
	    /**
	     * Fetches projects available for the user represented by the given profileId
	     *
	     * @method getProjects
	     * @param {String} profileId - User profile identifier
	     * @return {Array} An Array of projects
	     */
	    ProjectModule.prototype.getProjects = function (profileId) {
	        return util_1.getAllPagesByOffsetLimit(this.xhr, "/gdc/account/profile/" + profileId + "/projects", "projects").then(function (result) { return result.map(function (p) { return p.project; }); });
	    };
	    /**
	     * Fetches all datasets for the given project
	     *
	     * @method getDatasets
	     * @param {String} projectId - GD project identifier
	     * @return {Array} An array of objects containing datasets metadata
	     */
	    ProjectModule.prototype.getDatasets = function (projectId) {
	        return this.xhr
	            .get("/gdc/md/" + projectId + "/query/datasets")
	            .then(function (r) { return r.getData(); })
	            .then(util_1.getIn("query.entries"));
	    };
	    /**
	     * Fetches a chart color palette for a project represented by the given
	     * projectId parameter.
	     *
	     * @method getColorPalette
	     * @param {String} projectId - A project identifier
	     * @return {Array} An array of objects with r, g, b fields representing a project's
	     * color palette
	     */
	    ProjectModule.prototype.getColorPalette = function (projectId) {
	        return this.xhr
	            .get("/gdc/projects/" + projectId + "/styleSettings")
	            .then(function (r) { return r.getData(); })
	            .then(function (result) {
	            return result.styleSettings.chartPalette.map(function (c) {
	                return {
	                    r: c.fill.r,
	                    g: c.fill.g,
	                    b: c.fill.b,
	                };
	            });
	        }, function (err) {
	            if (err.status === 200) {
	                return DEFAULT_PALETTE;
	            }
	            throw new Error(err.statusText);
	        });
	    };
	    /**
	     * Fetches a chart color palette for a project represented by the given
	     * projectId parameter.
	     *
	     * @method getColorPaletteWithGuids
	     * @param {String} projectId - A project identifier
	     * @return {Array} An array of objects representing a project's
	     * color palette with color guid or undefined
	     */
	    ProjectModule.prototype.getColorPaletteWithGuids = function (projectId) {
	        return this.xhr
	            .get("/gdc/projects/" + projectId + "/styleSettings")
	            .then(function (apiResponse) {
	            return apiResponse.getData();
	        })
	            .then(function (result) {
	            if (result && result.styleSettings) {
	                return result.styleSettings.chartPalette;
	            }
	            else {
	                return undefined;
	            }
	        });
	    };
	    /**
	     * Sets given colors as a color palette for a given project.
	     *
	     * @method setColorPalette
	     * @param {String} projectId - GD project identifier
	     * @param {Array} colors - An array of colors that we want to use within the project.
	     * Each color should be an object with r, g, b fields. // TODO really object?
	     */
	    ProjectModule.prototype.setColorPalette = function (projectId, colors) {
	        return this.xhr.put("/gdc/projects/" + projectId + "/styleSettings", {
	            body: {
	                styleSettings: {
	                    chartPalette: colors.map(function (fill, idx) {
	                        return { fill: fill, guid: "guid" + idx };
	                    }),
	                },
	            },
	        });
	    };
	    /**
	     * Gets current timezone and its offset. Example output:
	     *
	     *     {
	     *         id: 'Europe/Prague',
	     *         displayName: 'Central European Time',
	     *         currentOffsetMs: 3600000
	     *     }
	     *
	     * @method getTimezone
	     * @param {String} projectId - GD project identifier
	     */
	    ProjectModule.prototype.getTimezone = function (projectId) {
	        var bootstrapUrl = "/gdc/app/account/bootstrap?projectId=" + projectId;
	        return this.xhr
	            .get(bootstrapUrl)
	            .then(function (r) { return r.getData(); })
	            .then(function (result) {
	            return result.bootstrapResource.current.timezone;
	        });
	    };
	    ProjectModule.prototype.setTimezone = function (projectId, timezone) {
	        var timezoneServiceUrl = "/gdc/md/" + projectId + "/service/timezone";
	        var data = {
	            service: { timezone: timezone },
	        };
	        return this.xhr
	            .post(timezoneServiceUrl, {
	            body: data,
	        })
	            .then(function (r) { return r.getData(); });
	    };
	    /**
	     * Create project
	     * Note: returns a promise which is resolved when the project creation is finished
	     *
	     * @experimental
	     * @method createProject
	     * @param {String} title
	     * @param {String} authorizationToken
	     * @param {Object} options for project creation (summary, projectTemplate, ...)
	     * @return {Object} created project object
	     */
	    ProjectModule.prototype.createProject = function (title, authorizationToken, options) {
	        var _this = this;
	        if (options === void 0) { options = {}; }
	        var summary = options.summary, projectTemplate = options.projectTemplate, _a = options.driver, driver = _a === void 0 ? "Pg" : _a, _b = options.environment, environment = _b === void 0 ? "TESTING" : _b, _c = options.guidedNavigation, guidedNavigation = _c === void 0 ? 1 : _c;
	        return this.xhr
	            .post("/gdc/projects", {
	            body: JSON.stringify({
	                project: {
	                    content: {
	                        guidedNavigation: guidedNavigation,
	                        driver: driver,
	                        authorizationToken: authorizationToken,
	                        environment: environment,
	                    },
	                    meta: {
	                        title: title,
	                        summary: summary,
	                        projectTemplate: projectTemplate,
	                    },
	                },
	            }),
	        })
	            .then(function (r) { return r.getData(); })
	            .then(function (project) {
	            return util_1.handlePolling(_this.xhr.get.bind(_this.xhr), project.uri, function (response) {
	                // TODO project response
	                return isProjectCreated(response.project);
	            }, options);
	        });
	    };
	    /**
	     * Delete project
	     *
	     * @method deleteProject
	     * @param {String} projectId
	     */
	    ProjectModule.prototype.deleteProject = function (projectId) {
	        return this.xhr.del("/gdc/projects/" + projectId);
	    };
	    /**
	     * Gets aggregated feature flags for given project and current user
	     *
	     * @method getFeatureFlags
	     * @param {String} projectId - A project identifier
	     * @return {IFeatureFlags} Hash table of feature flags and theirs values where feature flag is as key
	     */
	    ProjectModule.prototype.getFeatureFlags = function (projectId) {
	        return this.xhr
	            .get("/gdc/app/projects/" + projectId + "/featureFlags")
	            .then(function (apiResponse) {
	            return apiResponse.getData();
	        })
	            .then(function (result) {
	            if (result && result.featureFlags) {
	                return result.featureFlags;
	            }
	            return {};
	        });
	    };
	    /**
	     * Gets project config including project specific feature flags
	     *
	     * @param {String} projectId - A project identifier
	     * @return {IProjectConfigSettingItem[]} An array of project config setting items
	     */
	    ProjectModule.prototype.getConfig = function (projectId) {
	        return this.xhr
	            .get("/gdc/app/projects/" + projectId + "/config")
	            .then(function (apiResponse) {
	            var projectConfig = apiResponse.getData();
	            return projectConfig;
	        })
	            .then(function (result) {
	            if (result && result.settings && result.settings.items) {
	                return result.settings.items;
	            }
	            return [];
	        });
	    };
	    /**
	     * Gets project specific feature flags
	     *
	     * @param {String} projectId - A project identifier
	     * @param {String} source - optional filter settingItems with specific source
	     * @return {IFeatureFlags} Hash table of feature flags and theirs values where feature flag is as key
	     */
	    ProjectModule.prototype.getProjectFeatureFlags = function (projectId, source) {
	        return this.getConfig(projectId).then(function (settingItems) {
	            var filteredSettingItems = source
	                ? settingItems.filter(function (settingItem) { return settingItem.settingItem.source === source; })
	                : settingItems;
	            var featureFlags = {};
	            filteredSettingItems.forEach(function (settingItem) {
	                featureFlags[settingItem.settingItem.key] = exports.parseSettingItemValue(settingItem.settingItem.value);
	            });
	            return featureFlags;
	        });
	    };
	    return ProjectModule;
	}());
	exports.ProjectModule = ProjectModule;


/***/ }),
/* 95 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	var stringify = __webpack_require__(96);
	var parse = __webpack_require__(99);
	var formats = __webpack_require__(98);

	module.exports = {
	    formats: formats,
	    parse: parse,
	    stringify: stringify
	};


/***/ }),
/* 96 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	var utils = __webpack_require__(97);
	var formats = __webpack_require__(98);
	var has = Object.prototype.hasOwnProperty;

	var arrayPrefixGenerators = {
	    brackets: function brackets(prefix) {
	        return prefix + '[]';
	    },
	    comma: 'comma',
	    indices: function indices(prefix, key) {
	        return prefix + '[' + key + ']';
	    },
	    repeat: function repeat(prefix) {
	        return prefix;
	    }
	};

	var isArray = Array.isArray;
	var push = Array.prototype.push;
	var pushToArray = function (arr, valueOrArray) {
	    push.apply(arr, isArray(valueOrArray) ? valueOrArray : [valueOrArray]);
	};

	var toISO = Date.prototype.toISOString;

	var defaultFormat = formats['default'];
	var defaults = {
	    addQueryPrefix: false,
	    allowDots: false,
	    charset: 'utf-8',
	    charsetSentinel: false,
	    delimiter: '&',
	    encode: true,
	    encoder: utils.encode,
	    encodeValuesOnly: false,
	    format: defaultFormat,
	    formatter: formats.formatters[defaultFormat],
	    // deprecated
	    indices: false,
	    serializeDate: function serializeDate(date) {
	        return toISO.call(date);
	    },
	    skipNulls: false,
	    strictNullHandling: false
	};

	var isNonNullishPrimitive = function isNonNullishPrimitive(v) {
	    return typeof v === 'string'
	        || typeof v === 'number'
	        || typeof v === 'boolean'
	        || typeof v === 'symbol'
	        || typeof v === 'bigint';
	};

	var stringify = function stringify(
	    object,
	    prefix,
	    generateArrayPrefix,
	    strictNullHandling,
	    skipNulls,
	    encoder,
	    filter,
	    sort,
	    allowDots,
	    serializeDate,
	    formatter,
	    encodeValuesOnly,
	    charset
	) {
	    var obj = object;
	    if (typeof filter === 'function') {
	        obj = filter(prefix, obj);
	    } else if (obj instanceof Date) {
	        obj = serializeDate(obj);
	    } else if (generateArrayPrefix === 'comma' && isArray(obj)) {
	        obj = utils.maybeMap(obj, function (value) {
	            if (value instanceof Date) {
	                return serializeDate(value);
	            }
	            return value;
	        }).join(',');
	    }

	    if (obj === null) {
	        if (strictNullHandling) {
	            return encoder && !encodeValuesOnly ? encoder(prefix, defaults.encoder, charset, 'key') : prefix;
	        }

	        obj = '';
	    }

	    if (isNonNullishPrimitive(obj) || utils.isBuffer(obj)) {
	        if (encoder) {
	            var keyValue = encodeValuesOnly ? prefix : encoder(prefix, defaults.encoder, charset, 'key');
	            return [formatter(keyValue) + '=' + formatter(encoder(obj, defaults.encoder, charset, 'value'))];
	        }
	        return [formatter(prefix) + '=' + formatter(String(obj))];
	    }

	    var values = [];

	    if (typeof obj === 'undefined') {
	        return values;
	    }

	    var objKeys;
	    if (isArray(filter)) {
	        objKeys = filter;
	    } else {
	        var keys = Object.keys(obj);
	        objKeys = sort ? keys.sort(sort) : keys;
	    }

	    for (var i = 0; i < objKeys.length; ++i) {
	        var key = objKeys[i];
	        var value = obj[key];

	        if (skipNulls && value === null) {
	            continue;
	        }

	        var keyPrefix = isArray(obj)
	            ? typeof generateArrayPrefix === 'function' ? generateArrayPrefix(prefix, key) : prefix
	            : prefix + (allowDots ? '.' + key : '[' + key + ']');

	        pushToArray(values, stringify(
	            value,
	            keyPrefix,
	            generateArrayPrefix,
	            strictNullHandling,
	            skipNulls,
	            encoder,
	            filter,
	            sort,
	            allowDots,
	            serializeDate,
	            formatter,
	            encodeValuesOnly,
	            charset
	        ));
	    }

	    return values;
	};

	var normalizeStringifyOptions = function normalizeStringifyOptions(opts) {
	    if (!opts) {
	        return defaults;
	    }

	    if (opts.encoder !== null && opts.encoder !== undefined && typeof opts.encoder !== 'function') {
	        throw new TypeError('Encoder has to be a function.');
	    }

	    var charset = opts.charset || defaults.charset;
	    if (typeof opts.charset !== 'undefined' && opts.charset !== 'utf-8' && opts.charset !== 'iso-8859-1') {
	        throw new TypeError('The charset option must be either utf-8, iso-8859-1, or undefined');
	    }

	    var format = formats['default'];
	    if (typeof opts.format !== 'undefined') {
	        if (!has.call(formats.formatters, opts.format)) {
	            throw new TypeError('Unknown format option provided.');
	        }
	        format = opts.format;
	    }
	    var formatter = formats.formatters[format];

	    var filter = defaults.filter;
	    if (typeof opts.filter === 'function' || isArray(opts.filter)) {
	        filter = opts.filter;
	    }

	    return {
	        addQueryPrefix: typeof opts.addQueryPrefix === 'boolean' ? opts.addQueryPrefix : defaults.addQueryPrefix,
	        allowDots: typeof opts.allowDots === 'undefined' ? defaults.allowDots : !!opts.allowDots,
	        charset: charset,
	        charsetSentinel: typeof opts.charsetSentinel === 'boolean' ? opts.charsetSentinel : defaults.charsetSentinel,
	        delimiter: typeof opts.delimiter === 'undefined' ? defaults.delimiter : opts.delimiter,
	        encode: typeof opts.encode === 'boolean' ? opts.encode : defaults.encode,
	        encoder: typeof opts.encoder === 'function' ? opts.encoder : defaults.encoder,
	        encodeValuesOnly: typeof opts.encodeValuesOnly === 'boolean' ? opts.encodeValuesOnly : defaults.encodeValuesOnly,
	        filter: filter,
	        formatter: formatter,
	        serializeDate: typeof opts.serializeDate === 'function' ? opts.serializeDate : defaults.serializeDate,
	        skipNulls: typeof opts.skipNulls === 'boolean' ? opts.skipNulls : defaults.skipNulls,
	        sort: typeof opts.sort === 'function' ? opts.sort : null,
	        strictNullHandling: typeof opts.strictNullHandling === 'boolean' ? opts.strictNullHandling : defaults.strictNullHandling
	    };
	};

	module.exports = function (object, opts) {
	    var obj = object;
	    var options = normalizeStringifyOptions(opts);

	    var objKeys;
	    var filter;

	    if (typeof options.filter === 'function') {
	        filter = options.filter;
	        obj = filter('', obj);
	    } else if (isArray(options.filter)) {
	        filter = options.filter;
	        objKeys = filter;
	    }

	    var keys = [];

	    if (typeof obj !== 'object' || obj === null) {
	        return '';
	    }

	    var arrayFormat;
	    if (opts && opts.arrayFormat in arrayPrefixGenerators) {
	        arrayFormat = opts.arrayFormat;
	    } else if (opts && 'indices' in opts) {
	        arrayFormat = opts.indices ? 'indices' : 'repeat';
	    } else {
	        arrayFormat = 'indices';
	    }

	    var generateArrayPrefix = arrayPrefixGenerators[arrayFormat];

	    if (!objKeys) {
	        objKeys = Object.keys(obj);
	    }

	    if (options.sort) {
	        objKeys.sort(options.sort);
	    }

	    for (var i = 0; i < objKeys.length; ++i) {
	        var key = objKeys[i];

	        if (options.skipNulls && obj[key] === null) {
	            continue;
	        }
	        pushToArray(keys, stringify(
	            obj[key],
	            key,
	            generateArrayPrefix,
	            options.strictNullHandling,
	            options.skipNulls,
	            options.encode ? options.encoder : null,
	            options.filter,
	            options.sort,
	            options.allowDots,
	            options.serializeDate,
	            options.formatter,
	            options.encodeValuesOnly,
	            options.charset
	        ));
	    }

	    var joined = keys.join(options.delimiter);
	    var prefix = options.addQueryPrefix === true ? '?' : '';

	    if (options.charsetSentinel) {
	        if (options.charset === 'iso-8859-1') {
	            // encodeURIComponent('&#10003;'), the "numeric entity" representation of a checkmark
	            prefix += 'utf8=%26%2310003%3B&';
	        } else {
	            // encodeURIComponent('✓')
	            prefix += 'utf8=%E2%9C%93&';
	        }
	    }

	    return joined.length > 0 ? prefix + joined : '';
	};


/***/ }),
/* 97 */
/***/ (function(module, exports) {

	'use strict';

	var has = Object.prototype.hasOwnProperty;
	var isArray = Array.isArray;

	var hexTable = (function () {
	    var array = [];
	    for (var i = 0; i < 256; ++i) {
	        array.push('%' + ((i < 16 ? '0' : '') + i.toString(16)).toUpperCase());
	    }

	    return array;
	}());

	var compactQueue = function compactQueue(queue) {
	    while (queue.length > 1) {
	        var item = queue.pop();
	        var obj = item.obj[item.prop];

	        if (isArray(obj)) {
	            var compacted = [];

	            for (var j = 0; j < obj.length; ++j) {
	                if (typeof obj[j] !== 'undefined') {
	                    compacted.push(obj[j]);
	                }
	            }

	            item.obj[item.prop] = compacted;
	        }
	    }
	};

	var arrayToObject = function arrayToObject(source, options) {
	    var obj = options && options.plainObjects ? Object.create(null) : {};
	    for (var i = 0; i < source.length; ++i) {
	        if (typeof source[i] !== 'undefined') {
	            obj[i] = source[i];
	        }
	    }

	    return obj;
	};

	var merge = function merge(target, source, options) {
	    /* eslint no-param-reassign: 0 */
	    if (!source) {
	        return target;
	    }

	    if (typeof source !== 'object') {
	        if (isArray(target)) {
	            target.push(source);
	        } else if (target && typeof target === 'object') {
	            if ((options && (options.plainObjects || options.allowPrototypes)) || !has.call(Object.prototype, source)) {
	                target[source] = true;
	            }
	        } else {
	            return [target, source];
	        }

	        return target;
	    }

	    if (!target || typeof target !== 'object') {
	        return [target].concat(source);
	    }

	    var mergeTarget = target;
	    if (isArray(target) && !isArray(source)) {
	        mergeTarget = arrayToObject(target, options);
	    }

	    if (isArray(target) && isArray(source)) {
	        source.forEach(function (item, i) {
	            if (has.call(target, i)) {
	                var targetItem = target[i];
	                if (targetItem && typeof targetItem === 'object' && item && typeof item === 'object') {
	                    target[i] = merge(targetItem, item, options);
	                } else {
	                    target.push(item);
	                }
	            } else {
	                target[i] = item;
	            }
	        });
	        return target;
	    }

	    return Object.keys(source).reduce(function (acc, key) {
	        var value = source[key];

	        if (has.call(acc, key)) {
	            acc[key] = merge(acc[key], value, options);
	        } else {
	            acc[key] = value;
	        }
	        return acc;
	    }, mergeTarget);
	};

	var assign = function assignSingleSource(target, source) {
	    return Object.keys(source).reduce(function (acc, key) {
	        acc[key] = source[key];
	        return acc;
	    }, target);
	};

	var decode = function (str, decoder, charset) {
	    var strWithoutPlus = str.replace(/\+/g, ' ');
	    if (charset === 'iso-8859-1') {
	        // unescape never throws, no try...catch needed:
	        return strWithoutPlus.replace(/%[0-9a-f]{2}/gi, unescape);
	    }
	    // utf-8
	    try {
	        return decodeURIComponent(strWithoutPlus);
	    } catch (e) {
	        return strWithoutPlus;
	    }
	};

	var encode = function encode(str, defaultEncoder, charset) {
	    // This code was originally written by Brian White (mscdex) for the io.js core querystring library.
	    // It has been adapted here for stricter adherence to RFC 3986
	    if (str.length === 0) {
	        return str;
	    }

	    var string = str;
	    if (typeof str === 'symbol') {
	        string = Symbol.prototype.toString.call(str);
	    } else if (typeof str !== 'string') {
	        string = String(str);
	    }

	    if (charset === 'iso-8859-1') {
	        return escape(string).replace(/%u[0-9a-f]{4}/gi, function ($0) {
	            return '%26%23' + parseInt($0.slice(2), 16) + '%3B';
	        });
	    }

	    var out = '';
	    for (var i = 0; i < string.length; ++i) {
	        var c = string.charCodeAt(i);

	        if (
	            c === 0x2D // -
	            || c === 0x2E // .
	            || c === 0x5F // _
	            || c === 0x7E // ~
	            || (c >= 0x30 && c <= 0x39) // 0-9
	            || (c >= 0x41 && c <= 0x5A) // a-z
	            || (c >= 0x61 && c <= 0x7A) // A-Z
	        ) {
	            out += string.charAt(i);
	            continue;
	        }

	        if (c < 0x80) {
	            out = out + hexTable[c];
	            continue;
	        }

	        if (c < 0x800) {
	            out = out + (hexTable[0xC0 | (c >> 6)] + hexTable[0x80 | (c & 0x3F)]);
	            continue;
	        }

	        if (c < 0xD800 || c >= 0xE000) {
	            out = out + (hexTable[0xE0 | (c >> 12)] + hexTable[0x80 | ((c >> 6) & 0x3F)] + hexTable[0x80 | (c & 0x3F)]);
	            continue;
	        }

	        i += 1;
	        c = 0x10000 + (((c & 0x3FF) << 10) | (string.charCodeAt(i) & 0x3FF));
	        out += hexTable[0xF0 | (c >> 18)]
	            + hexTable[0x80 | ((c >> 12) & 0x3F)]
	            + hexTable[0x80 | ((c >> 6) & 0x3F)]
	            + hexTable[0x80 | (c & 0x3F)];
	    }

	    return out;
	};

	var compact = function compact(value) {
	    var queue = [{ obj: { o: value }, prop: 'o' }];
	    var refs = [];

	    for (var i = 0; i < queue.length; ++i) {
	        var item = queue[i];
	        var obj = item.obj[item.prop];

	        var keys = Object.keys(obj);
	        for (var j = 0; j < keys.length; ++j) {
	            var key = keys[j];
	            var val = obj[key];
	            if (typeof val === 'object' && val !== null && refs.indexOf(val) === -1) {
	                queue.push({ obj: obj, prop: key });
	                refs.push(val);
	            }
	        }
	    }

	    compactQueue(queue);

	    return value;
	};

	var isRegExp = function isRegExp(obj) {
	    return Object.prototype.toString.call(obj) === '[object RegExp]';
	};

	var isBuffer = function isBuffer(obj) {
	    if (!obj || typeof obj !== 'object') {
	        return false;
	    }

	    return !!(obj.constructor && obj.constructor.isBuffer && obj.constructor.isBuffer(obj));
	};

	var combine = function combine(a, b) {
	    return [].concat(a, b);
	};

	var maybeMap = function maybeMap(val, fn) {
	    if (isArray(val)) {
	        var mapped = [];
	        for (var i = 0; i < val.length; i += 1) {
	            mapped.push(fn(val[i]));
	        }
	        return mapped;
	    }
	    return fn(val);
	};

	module.exports = {
	    arrayToObject: arrayToObject,
	    assign: assign,
	    combine: combine,
	    compact: compact,
	    decode: decode,
	    encode: encode,
	    isBuffer: isBuffer,
	    isRegExp: isRegExp,
	    maybeMap: maybeMap,
	    merge: merge
	};


/***/ }),
/* 98 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	var replace = String.prototype.replace;
	var percentTwenties = /%20/g;

	var util = __webpack_require__(97);

	var Format = {
	    RFC1738: 'RFC1738',
	    RFC3986: 'RFC3986'
	};

	module.exports = util.assign(
	    {
	        'default': Format.RFC3986,
	        formatters: {
	            RFC1738: function (value) {
	                return replace.call(value, percentTwenties, '+');
	            },
	            RFC3986: function (value) {
	                return String(value);
	            }
	        }
	    },
	    Format
	);


/***/ }),
/* 99 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	var utils = __webpack_require__(97);

	var has = Object.prototype.hasOwnProperty;
	var isArray = Array.isArray;

	var defaults = {
	    allowDots: false,
	    allowPrototypes: false,
	    arrayLimit: 20,
	    charset: 'utf-8',
	    charsetSentinel: false,
	    comma: false,
	    decoder: utils.decode,
	    delimiter: '&',
	    depth: 5,
	    ignoreQueryPrefix: false,
	    interpretNumericEntities: false,
	    parameterLimit: 1000,
	    parseArrays: true,
	    plainObjects: false,
	    strictNullHandling: false
	};

	var interpretNumericEntities = function (str) {
	    return str.replace(/&#(\d+);/g, function ($0, numberStr) {
	        return String.fromCharCode(parseInt(numberStr, 10));
	    });
	};

	var parseArrayValue = function (val, options) {
	    if (val && typeof val === 'string' && options.comma && val.indexOf(',') > -1) {
	        return val.split(',');
	    }

	    return val;
	};

	// This is what browsers will submit when the ✓ character occurs in an
	// application/x-www-form-urlencoded body and the encoding of the page containing
	// the form is iso-8859-1, or when the submitted form has an accept-charset
	// attribute of iso-8859-1. Presumably also with other charsets that do not contain
	// the ✓ character, such as us-ascii.
	var isoSentinel = 'utf8=%26%2310003%3B'; // encodeURIComponent('&#10003;')

	// These are the percent-encoded utf-8 octets representing a checkmark, indicating that the request actually is utf-8 encoded.
	var charsetSentinel = 'utf8=%E2%9C%93'; // encodeURIComponent('✓')

	var parseValues = function parseQueryStringValues(str, options) {
	    var obj = {};
	    var cleanStr = options.ignoreQueryPrefix ? str.replace(/^\?/, '') : str;
	    var limit = options.parameterLimit === Infinity ? undefined : options.parameterLimit;
	    var parts = cleanStr.split(options.delimiter, limit);
	    var skipIndex = -1; // Keep track of where the utf8 sentinel was found
	    var i;

	    var charset = options.charset;
	    if (options.charsetSentinel) {
	        for (i = 0; i < parts.length; ++i) {
	            if (parts[i].indexOf('utf8=') === 0) {
	                if (parts[i] === charsetSentinel) {
	                    charset = 'utf-8';
	                } else if (parts[i] === isoSentinel) {
	                    charset = 'iso-8859-1';
	                }
	                skipIndex = i;
	                i = parts.length; // The eslint settings do not allow break;
	            }
	        }
	    }

	    for (i = 0; i < parts.length; ++i) {
	        if (i === skipIndex) {
	            continue;
	        }
	        var part = parts[i];

	        var bracketEqualsPos = part.indexOf(']=');
	        var pos = bracketEqualsPos === -1 ? part.indexOf('=') : bracketEqualsPos + 1;

	        var key, val;
	        if (pos === -1) {
	            key = options.decoder(part, defaults.decoder, charset, 'key');
	            val = options.strictNullHandling ? null : '';
	        } else {
	            key = options.decoder(part.slice(0, pos), defaults.decoder, charset, 'key');
	            val = utils.maybeMap(
	                parseArrayValue(part.slice(pos + 1), options),
	                function (encodedVal) {
	                    return options.decoder(encodedVal, defaults.decoder, charset, 'value');
	                }
	            );
	        }

	        if (val && options.interpretNumericEntities && charset === 'iso-8859-1') {
	            val = interpretNumericEntities(val);
	        }

	        if (part.indexOf('[]=') > -1) {
	            val = isArray(val) ? [val] : val;
	        }

	        if (has.call(obj, key)) {
	            obj[key] = utils.combine(obj[key], val);
	        } else {
	            obj[key] = val;
	        }
	    }

	    return obj;
	};

	var parseObject = function (chain, val, options, valuesParsed) {
	    var leaf = valuesParsed ? val : parseArrayValue(val, options);

	    for (var i = chain.length - 1; i >= 0; --i) {
	        var obj;
	        var root = chain[i];

	        if (root === '[]' && options.parseArrays) {
	            obj = [].concat(leaf);
	        } else {
	            obj = options.plainObjects ? Object.create(null) : {};
	            var cleanRoot = root.charAt(0) === '[' && root.charAt(root.length - 1) === ']' ? root.slice(1, -1) : root;
	            var index = parseInt(cleanRoot, 10);
	            if (!options.parseArrays && cleanRoot === '') {
	                obj = { 0: leaf };
	            } else if (
	                !isNaN(index)
	                && root !== cleanRoot
	                && String(index) === cleanRoot
	                && index >= 0
	                && (options.parseArrays && index <= options.arrayLimit)
	            ) {
	                obj = [];
	                obj[index] = leaf;
	            } else {
	                obj[cleanRoot] = leaf;
	            }
	        }

	        leaf = obj; // eslint-disable-line no-param-reassign
	    }

	    return leaf;
	};

	var parseKeys = function parseQueryStringKeys(givenKey, val, options, valuesParsed) {
	    if (!givenKey) {
	        return;
	    }

	    // Transform dot notation to bracket notation
	    var key = options.allowDots ? givenKey.replace(/\.([^.[]+)/g, '[$1]') : givenKey;

	    // The regex chunks

	    var brackets = /(\[[^[\]]*])/;
	    var child = /(\[[^[\]]*])/g;

	    // Get the parent

	    var segment = options.depth > 0 && brackets.exec(key);
	    var parent = segment ? key.slice(0, segment.index) : key;

	    // Stash the parent if it exists

	    var keys = [];
	    if (parent) {
	        // If we aren't using plain objects, optionally prefix keys that would overwrite object prototype properties
	        if (!options.plainObjects && has.call(Object.prototype, parent)) {
	            if (!options.allowPrototypes) {
	                return;
	            }
	        }

	        keys.push(parent);
	    }

	    // Loop through children appending to the array until we hit depth

	    var i = 0;
	    while (options.depth > 0 && (segment = child.exec(key)) !== null && i < options.depth) {
	        i += 1;
	        if (!options.plainObjects && has.call(Object.prototype, segment[1].slice(1, -1))) {
	            if (!options.allowPrototypes) {
	                return;
	            }
	        }
	        keys.push(segment[1]);
	    }

	    // If there's a remainder, just add whatever is left

	    if (segment) {
	        keys.push('[' + key.slice(segment.index) + ']');
	    }

	    return parseObject(keys, val, options, valuesParsed);
	};

	var normalizeParseOptions = function normalizeParseOptions(opts) {
	    if (!opts) {
	        return defaults;
	    }

	    if (opts.decoder !== null && opts.decoder !== undefined && typeof opts.decoder !== 'function') {
	        throw new TypeError('Decoder has to be a function.');
	    }

	    if (typeof opts.charset !== 'undefined' && opts.charset !== 'utf-8' && opts.charset !== 'iso-8859-1') {
	        throw new TypeError('The charset option must be either utf-8, iso-8859-1, or undefined');
	    }
	    var charset = typeof opts.charset === 'undefined' ? defaults.charset : opts.charset;

	    return {
	        allowDots: typeof opts.allowDots === 'undefined' ? defaults.allowDots : !!opts.allowDots,
	        allowPrototypes: typeof opts.allowPrototypes === 'boolean' ? opts.allowPrototypes : defaults.allowPrototypes,
	        arrayLimit: typeof opts.arrayLimit === 'number' ? opts.arrayLimit : defaults.arrayLimit,
	        charset: charset,
	        charsetSentinel: typeof opts.charsetSentinel === 'boolean' ? opts.charsetSentinel : defaults.charsetSentinel,
	        comma: typeof opts.comma === 'boolean' ? opts.comma : defaults.comma,
	        decoder: typeof opts.decoder === 'function' ? opts.decoder : defaults.decoder,
	        delimiter: typeof opts.delimiter === 'string' || utils.isRegExp(opts.delimiter) ? opts.delimiter : defaults.delimiter,
	        // eslint-disable-next-line no-implicit-coercion, no-extra-parens
	        depth: (typeof opts.depth === 'number' || opts.depth === false) ? +opts.depth : defaults.depth,
	        ignoreQueryPrefix: opts.ignoreQueryPrefix === true,
	        interpretNumericEntities: typeof opts.interpretNumericEntities === 'boolean' ? opts.interpretNumericEntities : defaults.interpretNumericEntities,
	        parameterLimit: typeof opts.parameterLimit === 'number' ? opts.parameterLimit : defaults.parameterLimit,
	        parseArrays: opts.parseArrays !== false,
	        plainObjects: typeof opts.plainObjects === 'boolean' ? opts.plainObjects : defaults.plainObjects,
	        strictNullHandling: typeof opts.strictNullHandling === 'boolean' ? opts.strictNullHandling : defaults.strictNullHandling
	    };
	};

	module.exports = function (str, opts) {
	    var options = normalizeParseOptions(opts);

	    if (str === '' || str === null || typeof str === 'undefined') {
	        return options.plainObjects ? Object.create(null) : {};
	    }

	    var tempObj = typeof str === 'string' ? parseValues(str, options) : str;
	    var obj = options.plainObjects ? Object.create(null) : {};

	    // Iterate over the keys and setup the new object

	    var keys = Object.keys(tempObj);
	    for (var i = 0; i < keys.length; ++i) {
	        var key = keys[i];
	        var newObj = parseKeys(key, tempObj[key], options, typeof str === 'string');
	        obj = utils.merge(obj, newObj, options);
	    }

	    return utils.compact(obj);
	};


/***/ }),
/* 100 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var __assign = (this && this.__assign) || function () {
	    __assign = Object.assign || function(t) {
	        for (var s, i = 1, n = arguments.length; i < n; i++) {
	            s = arguments[i];
	            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
	                t[p] = s[p];
	        }
	        return t;
	    };
	    return __assign.apply(this, arguments);
	};
	var __importDefault = (this && this.__importDefault) || function (mod) {
	    return (mod && mod.__esModule) ? mod : { "default": mod };
	};
	Object.defineProperty(exports, "__esModule", { value: true });
	// (C) 2007-2020 GoodData Corporation
	var isPlainObject_1 = __importDefault(__webpack_require__(49));
	var get_1 = __importDefault(__webpack_require__(89));
	var chunk_1 = __importDefault(__webpack_require__(101));
	var flatten_1 = __importDefault(__webpack_require__(104));
	var pick_1 = __importDefault(__webpack_require__(109));
	var util_1 = __webpack_require__(88);
	var xhr_1 = __webpack_require__(48);
	var referenceHandling_1 = __webpack_require__(116);
	var execute_afm_convert_1 = __webpack_require__(136);
	/**
	 * Functions for working with metadata objects
	 *
	 * @class metadata
	 * @module metadata
	 */
	var MetadataModule = /** @class */ (function () {
	    function MetadataModule(xhr) {
	        this.xhr = xhr;
	    }
	    /**
	     * Load all objects with given uris
	     * (use bulk loading instead of getting objects one by one)
	     *
	     * @method getObjects
	     * @param {String} projectId id of the project
	     * @param {Array} objectUris array of uris for objects to be loaded
	     * @return {Array} array of loaded elements
	     */
	    MetadataModule.prototype.getObjects = function (projectId, objectUris) {
	        var _this = this;
	        var LIMIT = 50;
	        var uri = "/gdc/md/" + projectId + "/objects/get";
	        var objectsUrisChunks = chunk_1.default(objectUris, LIMIT);
	        var promises = objectsUrisChunks.map(function (objectUrisChunk) {
	            var body = {
	                get: {
	                    items: objectUrisChunk,
	                },
	            };
	            return _this.xhr
	                .post(uri, { body: body })
	                .then(function (r) {
	                if (!r.response.ok) {
	                    throw new xhr_1.ApiResponseError(r.response.statusText, r.response, r.responseBody);
	                }
	                return r.getData();
	            })
	                .then(function (result) {
	                return get_1.default(result, ["objects", "items"]).map(function (item) {
	                    if (item.visualizationObject) {
	                        return {
	                            visualizationObject: referenceHandling_1.convertReferencesToUris(item.visualizationObject),
	                        };
	                    }
	                    if (item.visualizationWidget) {
	                        return {
	                            visualizationWidget: referenceHandling_1.convertReferencesToUris(item.visualizationWidget),
	                        };
	                    }
	                    return item;
	                });
	            });
	        });
	        return Promise.all(promises).then(flatten_1.default);
	    };
	    /**
	     * Loads all objects by query (fetches all pages, one by one)
	     *
	     * @method getObjectsByQuery
	     * @param {String} projectId id of the project
	     * @param {Object} options (see https://developer.gooddata.com/api endpoint: /gdc/md/{project_id}/objects/query)
	     *        - category {String} for example 'dataSets' or 'projectDashboard'
	     *        - mode {String} 'enriched' or 'raw'
	     *        - author {String} the URI of the author of the metadata objects
	     *        - limit {number} default is 50 (also maximum)
	     *        - deprecated {boolean} show also deprecated objects
	     * @return {Promise<Array>} array of returned objects
	     */
	    MetadataModule.prototype.getObjectsByQuery = function (projectId, options) {
	        var _this = this;
	        var getOnePage = function (uri, items) {
	            if (items === void 0) { items = []; }
	            return _this.xhr
	                .get(uri)
	                .then(function (r) { return r.getData(); })
	                .then(function (_a) {
	                var objects = _a.objects;
	                items.push.apply(items, objects.items);
	                var nextUri = objects.paging.next;
	                return nextUri ? getOnePage(nextUri, items) : items;
	            });
	        };
	        var deprecated = options.deprecated ? { deprecated: 1 } : {};
	        var uri = "/gdc/md/" + projectId + "/objects/query";
	        var query = pick_1.default(__assign({ limit: 50 }, options, deprecated), [
	            "category",
	            "mode",
	            "author",
	            "limit",
	            "deprecated",
	        ]);
	        return getOnePage(uri + util_1.queryString(query));
	    };
	    /**
	     * Get MD objects from using2 resource. Include only objects of given types
	     * and take care about fetching only nearest objects if requested.
	     *
	     * @method getObjectUsing
	     * @param {String} projectId id of the project
	     * @param {String} uri uri of the object for which dependencies are to be found
	     * @param {Object} options objects with options:
	     *        - types {Array} array of strings with object types to be included
	     *        - nearest {Boolean} whether to include only nearest dependencies
	     * @return {jQuery promise} promise promise once resolved returns an array of
	     *         entries returned by using2 resource
	     */
	    MetadataModule.prototype.getObjectUsing = function (projectId, uri, options) {
	        if (options === void 0) { options = {}; }
	        var _a = options.types, types = _a === void 0 ? [] : _a, _b = options.nearest, nearest = _b === void 0 ? false : _b;
	        var resourceUri = "/gdc/md/" + projectId + "/using2";
	        var body = {
	            inUse: {
	                uri: uri,
	                types: types,
	                nearest: nearest ? 1 : 0,
	            },
	        };
	        return this.xhr
	            .post(resourceUri, { body: body })
	            .then(function (r) {
	            if (!r.response.ok) {
	                throw new xhr_1.ApiResponseError(r.response.statusText, r.response, r.getData());
	            }
	            return r.getData();
	        })
	            .then(function (result) { return result.entries; });
	    };
	    /**
	     * Get MD objects from using2 resource. Include only objects of given types
	     * and take care about fetching only nearest objects if requested.
	     *
	     * @method getObjectUsingMany
	     * @param {String} projectId id of the project
	     * @param {Array} uris uris of objects for which dependencies are to be found
	     * @param {Object} options objects with options:
	     *        - types {Array} array of strings with object types to be included
	     *        - nearest {Boolean} whether to include only nearest dependencies
	     * @return {jQuery promise} promise promise once resolved returns an array of
	     *         entries returned by using2 resource
	     */
	    MetadataModule.prototype.getObjectUsingMany = function (projectId, uris, options) {
	        if (options === void 0) { options = {}; }
	        var _a = options.types, types = _a === void 0 ? [] : _a, _b = options.nearest, nearest = _b === void 0 ? false : _b;
	        var resourceUri = "/gdc/md/" + projectId + "/using2";
	        var body = {
	            inUseMany: {
	                uris: uris,
	                types: types,
	                nearest: nearest ? 1 : 0,
	            },
	        };
	        return this.xhr
	            .post(resourceUri, { body: body })
	            .then(function (r) {
	            if (!r.response.ok) {
	                throw new xhr_1.ApiResponseError(r.response.statusText, r.response, r.getData());
	            }
	            return r.getData();
	        })
	            .then(function (result) { return result.useMany; });
	    };
	    /**
	     * Returns all visualizationObjects metadata in a project specified by projectId param
	     *
	     * @method getVisualizations
	     * @param {string} projectId Project identifier
	     * @return {Array} An array of visualization objects metadata
	     */
	    MetadataModule.prototype.getVisualizations = function (projectId) {
	        return this.xhr
	            .get("/gdc/md/" + projectId + "/query/visualizationobjects")
	            .then(function (apiResponse) {
	            return apiResponse.response.ok ? apiResponse.getData() : apiResponse.response;
	        })
	            .then(util_1.getIn("query.entries"));
	    };
	    /**
	     * Returns all attributes in a project specified by projectId param
	     *
	     * @method getAttributes
	     * @param {string} projectId Project identifier
	     * @return {Array} An array of attribute objects
	     */
	    MetadataModule.prototype.getAttributes = function (projectId) {
	        return this.xhr
	            .get("/gdc/md/" + projectId + "/query/attributes")
	            .then(function (apiResponse) {
	            return apiResponse.response.ok ? apiResponse.getData() : apiResponse.response;
	        })
	            .then(util_1.getIn("query.entries"));
	    };
	    /**
	     * Returns all dimensions in a project specified by projectId param
	     *
	     * @method getDimensions
	     * @param {string} projectId Project identifier
	     * @return {Array} An array of dimension objects
	     * @see getFolders
	     */
	    MetadataModule.prototype.getDimensions = function (projectId) {
	        return this.xhr
	            .get("/gdc/md/" + projectId + "/query/dimensions")
	            .then(function (apiResponse) {
	            return apiResponse.response.ok ? apiResponse.getData() : apiResponse.response;
	        })
	            .then(util_1.getIn("query.entries"));
	    };
	    /**
	     * Returns project folders. Folders can be of specific types and you can specify
	     * the type you need by passing and optional `type` parameter
	     *
	     * @method getFolders
	     * @param {String} projectId - Project identifier
	     * @param {String} type - Optional, possible values are `metric`, `fact`, `attribute`
	     * @return {Array} An array of dimension objects
	     */
	    MetadataModule.prototype.getFolders = function (projectId, type) {
	        var _this = this;
	        // TODO enum?
	        var getFolderEntries = function (pId, t) {
	            var typeURL = t ? "?type=" + t : "";
	            return _this.xhr
	                .get("/gdc/md/" + pId + "/query/folders" + typeURL)
	                .then(function (r) { return r.getData(); })
	                .then(util_1.getIn("query.entries"));
	        };
	        switch (type) {
	            case "fact":
	            case "metric":
	                return getFolderEntries(projectId, type);
	            case "attribute":
	                return this.getDimensions(projectId);
	            default:
	                return Promise.all([
	                    getFolderEntries(projectId, "fact"),
	                    getFolderEntries(projectId, "metric"),
	                    this.getDimensions(projectId),
	                ]).then(function (_a) {
	                    var fact = _a[0], metric = _a[1], attribute = _a[2];
	                    return { fact: fact, metric: metric, attribute: attribute };
	                });
	        }
	    };
	    /**
	     * Returns all facts in a project specified by the given projectId
	     *
	     * @method getFacts
	     * @param {string} projectId Project identifier
	     * @return {Array} An array of fact objects
	     */
	    MetadataModule.prototype.getFacts = function (projectId) {
	        return this.xhr
	            .get("/gdc/md/" + projectId + "/query/facts")
	            .then(function (apiResponse) {
	            return apiResponse.response.ok ? apiResponse.getData() : apiResponse.response;
	        })
	            .then(util_1.getIn("query.entries"));
	    };
	    /**
	     * Returns all metrics in a project specified by the given projectId
	     *
	     * @method getMetrics
	     * @param {string} projectId Project identifier
	     * @return {Array} An array of metric objects
	     */
	    MetadataModule.prototype.getMetrics = function (projectId) {
	        return this.xhr
	            .get("/gdc/md/" + projectId + "/query/metrics")
	            .then(function (apiResponse) {
	            return apiResponse.response.ok ? apiResponse.getData() : apiResponse.response;
	        })
	            .then(util_1.getIn("query.entries"));
	    };
	    /**
	     * Returns all metrics that are reachable (with respect to ldm of the project
	     * specified by the given projectId) for given attributes
	     *
	     * @method getAvailableMetrics
	     * @param {String} projectId - Project identifier
	     * @param {Array} attrs - An array of attribute uris for which we want to get
	     * available metrics
	     * @return {Array} An array of reachable metrics for the given attrs
	     * @see getAvailableAttributes
	     * @see getAvailableFacts
	     */
	    MetadataModule.prototype.getAvailableMetrics = function (projectId, attrs) {
	        if (attrs === void 0) { attrs = []; }
	        return this.xhr
	            .post("/gdc/md/" + projectId + "/availablemetrics", { body: attrs })
	            .then(function (apiResponse) {
	            return apiResponse.response.ok ? apiResponse.getData() : apiResponse.response;
	        })
	            .then(function (data) { return data.entries; });
	    };
	    /**
	     * Returns all attributes that are reachable (with respect to ldm of the project
	     * specified by the given projectId) for given metrics (also called as drillCrossPath)
	     *
	     * @method getAvailableAttributes
	     * @param {String} projectId - Project identifier
	     * @param {Array} metrics - An array of metric uris for which we want to get
	     * available attributes
	     * @return {Array} An array of reachable attributes for the given metrics
	     * @see getAvailableMetrics
	     * @see getAvailableFacts
	     */
	    MetadataModule.prototype.getAvailableAttributes = function (projectId, metrics) {
	        if (metrics === void 0) { metrics = []; }
	        return this.xhr
	            .post("/gdc/md/" + projectId + "/drillcrosspaths", { body: metrics })
	            .then(function (apiResponse) { return (apiResponse.response.ok ? apiResponse.getData() : apiResponse.response); })
	            .then(function (r) { return r.drillcrosspath.links; });
	    };
	    /**
	     * Returns all attributes that are reachable (with respect to ldm of the project
	     * specified by the given projectId) for given metrics (also called as drillCrossPath)
	     *
	     * @method getAvailableFacts
	     * @param {String} projectId - Project identifier
	     * @param {Array} items - An array of metric or attribute uris for which we want to get
	     * available facts
	     * @return {Array} An array of reachable facts for the given items
	     * @see getAvailableAttributes
	     * @see getAvailableMetrics
	     */
	    MetadataModule.prototype.getAvailableFacts = function (projectId, items) {
	        if (items === void 0) { items = []; }
	        return this.xhr
	            .post("/gdc/md/" + projectId + "/availablefacts", { body: items })
	            .then(function (r) { return (r.response.ok ? r.getData() : r.response); })
	            .then(function (r) { return r.entries; });
	    };
	    /**
	     * Get details of a metadata object specified by its uri
	     *
	     * @method getObjectDetails
	     * @param uri uri of the metadata object for which details are to be retrieved
	     * @return {Object} object details
	     */
	    MetadataModule.prototype.getObjectDetails = function (uri) {
	        return this.xhr.get(uri).then(function (r) { return r.getData(); });
	    };
	    /**
	     * Get folders with items.
	     * Returns array of folders, each having a title and items property which is an array of
	     * corresponding items. Each item is either a metric or attribute, keeping its original
	     * verbose structure.
	     *
	     * @method getFoldersWithItems
	     * @param {String} type type of folders to return
	     * @return {Array} Array of folder object, each containing title and
	     * corresponding items.
	     */
	    MetadataModule.prototype.getFoldersWithItems = function (projectId, type) {
	        var _this = this;
	        // fetch all folders of given type and process them
	        return this.getFolders(projectId, type).then(function (folders) {
	            // Helper public to get details for each metric in the given
	            // array of links to the metadata objects representing the metrics.
	            // @return the array of promises
	            var getMetricItemsDetails = function (array) {
	                return Promise.all(array.map(_this.getObjectDetails)).then(function (metricArgs) {
	                    return metricArgs.map(function (item) { return item.metric; });
	                });
	            };
	            // helper mapBy function
	            function mapBy(array, key) {
	                return array.map(function (item) {
	                    return item[key];
	                });
	            }
	            // helper for sorting folder tree structure
	            // sadly @returns void (sorting == mutating array in js)
	            var sortFolderTree = function (structure) {
	                structure.forEach(function (folder) {
	                    folder.items.sort(function (a, b) {
	                        if (a.meta.title < b.meta.title) {
	                            return -1;
	                        }
	                        else if (a.meta.title > b.meta.title) {
	                            return 1;
	                        }
	                        return 0;
	                    });
	                });
	                structure.sort(function (a, b) {
	                    if (a.title < b.title) {
	                        return -1;
	                    }
	                    else if (a.title > b.title) {
	                        return 1;
	                    }
	                    return 0;
	                });
	            };
	            var foldersLinks = mapBy(folders, "link");
	            var foldersTitles = mapBy(folders, "title");
	            // fetch details for each folder
	            return Promise.all(foldersLinks.map(_this.getObjectDetails)).then(function (folderDetails) {
	                // if attribute, just parse everything from what we've received
	                // and resolve. For metrics, lookup again each metric to get its
	                // identifier. If passing unsupported type, reject immediately.
	                if (type === "attribute") {
	                    // get all attributes, subtract what we have and add rest in unsorted folder
	                    return _this.getAttributes(projectId).then(function (attributes) {
	                        // get uris of attributes which are in some dimension folders
	                        var attributesInFolders = [];
	                        folderDetails.forEach(function (fd) {
	                            fd.dimension.content.attributes.forEach(function (attr) {
	                                attributesInFolders.push(attr.meta.uri);
	                            });
	                        });
	                        // unsortedUris now contains uris of all attributes which aren't in a folder
	                        var unsortedUris = attributes
	                            .filter(function (item) { return attributesInFolders.indexOf(item.link) === -1; })
	                            .map(function (item) { return item.link; });
	                        // now get details of attributes in no folders
	                        return Promise.all(unsortedUris.map(_this.getObjectDetails)).then(function (unsortedAttributeArgs) {
	                            // TODO add map to r.json
	                            // get unsorted attribute objects
	                            var unsortedAttributes = unsortedAttributeArgs.map(function (attr) { return attr.attribute; });
	                            // create structure of folders with attributes
	                            var structure = folderDetails.map(function (folderDetail) {
	                                return {
	                                    title: folderDetail.dimension.meta.title,
	                                    items: folderDetail.dimension.content.attributes,
	                                };
	                            });
	                            // and append "Unsorted" folder with attributes to the structure
	                            structure.push({
	                                title: "Unsorted",
	                                items: unsortedAttributes,
	                            });
	                            sortFolderTree(structure);
	                            return structure;
	                        });
	                    });
	                }
	                else if (type === "metric") {
	                    var entriesLinks_1 = folderDetails.map(function (entry) {
	                        return mapBy(entry.folder.content.entries, "link");
	                    });
	                    // get all metrics, subtract what we have and add rest in unsorted folder
	                    return _this.getMetrics(projectId).then(function (metrics) {
	                        // get uris of metrics which are in some dimension folders
	                        var metricsInFolders = [];
	                        folderDetails.forEach(function (fd) {
	                            fd.folder.content.entries.forEach(function (metric) {
	                                metricsInFolders.push(metric.link);
	                            });
	                        });
	                        // unsortedUris now contains uris of all metrics which aren't in a folder
	                        var unsortedUris = metrics
	                            .filter(function (item) { return metricsInFolders.indexOf(item.link) === -1; })
	                            .map(function (item) { return item.link; });
	                        // sadly order of parameters of concat matters! (we want unsorted last)
	                        entriesLinks_1.push(unsortedUris);
	                        // now get details of all metrics
	                        return Promise.all(entriesLinks_1.map(function (linkArray) { return getMetricItemsDetails(linkArray); })).then(function (tree) {
	                            // TODO add map to r.json
	                            // all promises resolved, i.e. details for each metric are available
	                            var structure = tree.map(function (treeItems, idx) {
	                                // if idx is not in folders list than metric is in "Unsorted" folder
	                                return {
	                                    title: foldersTitles[idx] || "Unsorted",
	                                    items: treeItems,
	                                };
	                            });
	                            sortFolderTree(structure);
	                            return structure;
	                        });
	                    });
	                }
	                return Promise.reject(null);
	            });
	        });
	    };
	    /**
	     * Get identifier of a metadata object identified by its uri
	     *
	     * @method getObjectIdentifier
	     * @param uri uri of the metadata object for which the identifier is to be retrieved
	     * @return {String} object identifier
	     */
	    MetadataModule.prototype.getObjectIdentifier = function (uri) {
	        function idFinder(obj) {
	            // TODO
	            if (obj.attribute) {
	                return obj.attribute.content.displayForms[0].meta.identifier;
	            }
	            else if (obj.dimension) {
	                return obj.dimension.content.attributes.content.displayForms[0].meta.identifier;
	            }
	            else if (obj.metric) {
	                return obj.metric.meta.identifier;
	            }
	            throw Error("Unknown object!");
	        }
	        if (!isPlainObject_1.default(uri)) {
	            return this.getObjectDetails(uri).then(function (data) { return idFinder(data); });
	        }
	        return Promise.resolve(idFinder(uri));
	    };
	    /**
	     * Get uri of an metadata object, specified by its identifier and project id it belongs to
	     *
	     * @method getObjectUri
	     * @param {string} projectId id of the project
	     * @param identifier identifier of the metadata object
	     * @return {String} uri of the metadata object
	     */
	    MetadataModule.prototype.getObjectUri = function (projectId, identifier) {
	        return this.xhr
	            .post("/gdc/md/" + projectId + "/identifiers", {
	            body: {
	                identifierToUri: [identifier],
	            },
	        })
	            .then(function (r) {
	            var data = r.getData();
	            var found = data.identifiers.find(function (pair) { return pair.identifier === identifier; });
	            if (found) {
	                return found.uri;
	            }
	            throw new xhr_1.ApiResponseError("Object with identifier " + identifier + " not found in project " + projectId, r.response, r.responseBody);
	        });
	    };
	    /**
	     * Get uris specified by identifiers
	     *
	     * @method getUrisFromIdentifiers
	     * @param {String} projectId id of the project
	     * @param {Array} identifiers identifiers of the metadata objects
	     * @return {Array} array of identifier + uri pairs
	     */
	    MetadataModule.prototype.getUrisFromIdentifiers = function (projectId, identifiers) {
	        return this.xhr
	            .post("/gdc/md/" + projectId + "/identifiers", {
	            body: {
	                identifierToUri: identifiers,
	            },
	        })
	            .then(function (r) { return r.getData(); })
	            .then(function (data) {
	            return data.identifiers;
	        });
	    };
	    /**
	     * Get identifiers specified by uris
	     *
	     * @method getIdentifiersFromUris
	     * @param {String} projectId id of the project
	     * @param {Array} uris of the metadata objects
	     * @return {Array} array of identifier + uri pairs
	     */
	    MetadataModule.prototype.getIdentifiersFromUris = function (projectId, uris) {
	        return this.xhr
	            .post("/gdc/md/" + projectId + "/identifiers", {
	            body: {
	                uriToIdentifier: uris,
	            },
	        })
	            .then(function (r) { return r.getData(); })
	            .then(function (data) {
	            return data.identifiers;
	        });
	    };
	    /**
	     * Get attribute elements with their labels and uris.
	     *
	     * @param {String} projectId id of the project
	     * @param {String} labelUri uri of the label (display form)
	     * @param {Array<String>} patterns elements labels/titles (for EXACT mode), or patterns (for WILD mode)
	     * @param {('EXACT'|'WILD')} mode match mode, currently only EXACT supported
	     * @return {Array} array of elementLabelUri objects
	     */
	    MetadataModule.prototype.translateElementLabelsToUris = function (projectId, labelUri, patterns, mode) {
	        if (mode === void 0) { mode = "EXACT"; }
	        return this.xhr
	            .post("/gdc/md/" + projectId + "/labels", {
	            body: {
	                elementLabelToUri: [
	                    {
	                        labelUri: labelUri,
	                        mode: mode,
	                        patterns: patterns,
	                    },
	                ],
	            },
	        })
	            .then(function (r) { return (r.response.ok ? get_1.default(r.getData(), "elementLabelUri") : r.response); });
	    };
	    /**
	     * Get valid elements of an attribute, specified by its identifier and project id it belongs to
	     *
	     * @method getValidElements
	     * @param {string} projectId id of the project
	     * @param id display form id of the metadata object
	     * @param {Object} options objects with options:
	     *      - limit {Number}
	     *      - offset {Number}
	     *      - order {String} 'asc' or 'desc'
	     *      - filter {String}
	     *      - prompt {String}
	     *      - uris {Array}
	     *      - complement {Boolean}
	     *      - includeTotalCountWithoutFilters {Boolean}
	     *      - restrictiveDefinition {String}
	     *      - afm {Object}
	     * @return {Object} ValidElements response with:
	     *      - items {Array} elements
	     *      - paging {Object}
	     *      - elementsMeta {Object}
	     */
	    MetadataModule.prototype.getValidElements = function (projectId, id, options) {
	        var _this = this;
	        if (options === void 0) { options = {}; }
	        var query = pick_1.default(options, ["limit", "offset", "order", "filter", "prompt"]);
	        var queryParams = util_1.queryString(query);
	        var pickedOptions = pick_1.default(options, [
	            "uris",
	            "complement",
	            "includeTotalCountWithoutFilters",
	            "restrictiveDefinition",
	        ]);
	        var afm = options.afm;
	        var getRequestBodyWithReportDefinition = function () {
	            return _this.xhr
	                .post("/gdc/app/projects/" + projectId + "/executeAfm/debug", {
	                body: {
	                    execution: {
	                        afm: execute_afm_convert_1.convertAfm(afm),
	                    },
	                },
	            })
	                .then(function (response) { return response.getData(); })
	                .then(function (reportDefinitionResult) { return (__assign({}, pickedOptions, { restrictiveDefinitionContent: reportDefinitionResult.reportDefinitionWithInlinedMetrics.content })); });
	        };
	        var getOptions = afm ? getRequestBodyWithReportDefinition : function () { return Promise.resolve(pickedOptions); };
	        return getOptions().then(function (requestBody) {
	            return _this.xhr
	                .post(("/gdc/md/" + projectId + "/obj/" + id + "/validElements" + queryParams).replace(/\?$/, ""), {
	                body: {
	                    validElementsRequest: requestBody,
	                },
	            })
	                .then(function (response) { return response.getData(); });
	        });
	    };
	    /**
	     * Get visualization by Uri and process data
	     *
	     * @method getVisualization
	     * @param {String} visualizationUri
	     */
	    MetadataModule.prototype.getVisualization = function (uri) {
	        return this.getObjectDetails(uri).then(function (visualizationObject) {
	            var mdObject = visualizationObject.visualizationObject;
	            return {
	                visualizationObject: referenceHandling_1.convertReferencesToUris(mdObject),
	            };
	        });
	    };
	    /**
	     * Save visualization
	     *
	     * @method saveVisualization
	     * @param {String} visualizationUri
	     */
	    MetadataModule.prototype.saveVisualization = function (projectId, visualization) {
	        var converted = referenceHandling_1.convertUrisToReferences(visualization.visualizationObject);
	        return this.createObject(projectId, { visualizationObject: converted });
	    };
	    /**
	     * Update visualization
	     *
	     * @method updateVisualization
	     * @param {String} visualizationUri
	     */
	    MetadataModule.prototype.updateVisualization = function (projectId, visualizationUri, visualization) {
	        var converted = referenceHandling_1.convertUrisToReferences(visualization.visualizationObject);
	        return this.updateObject(projectId, visualizationUri, { visualizationObject: converted });
	    };
	    /**
	     * Delete visualization
	     *
	     * @method deleteVisualization
	     * @param {String} visualizationUri
	     */
	    MetadataModule.prototype.deleteVisualization = function (visualizationUri) {
	        return this.deleteObject(visualizationUri);
	    };
	    /**
	     * Delete object
	     *
	     * @experimental
	     * @method deleteObject
	     * @param {String} uri of the object to be deleted
	     */
	    MetadataModule.prototype.deleteObject = function (uri) {
	        return this.xhr.del(uri);
	    };
	    /**
	     * Create object
	     *
	     * @experimental
	     * @method createObject
	     * @param {String} projectId
	     * @param {String} obj object definition
	     */
	    MetadataModule.prototype.createObject = function (projectId, obj) {
	        return this.xhr
	            .post("/gdc/md/" + projectId + "/obj?createAndGet=true", {
	            body: obj,
	        })
	            .then(function (r) { return r.getData(); });
	    };
	    /**
	     * Update object
	     *
	     * @experimental
	     * @method updateObject
	     * @param {String} projectId
	     * @param {String} visualizationUri
	     * @param {String} obj object definition
	     */
	    MetadataModule.prototype.updateObject = function (projectId, visualizationUri, obj) {
	        return this.xhr
	            .put("/gdc/md/" + projectId + "/obj/" + visualizationUri, {
	            body: obj,
	        })
	            .then(function (r) { return r.getData(); });
	    };
	    /**
	     * LDM manage
	     *
	     * @experimental
	     * @method ldmManage
	     * @param {String} projectId
	     * @param {String} maql
	     * @param {Object} options for polling (maxAttempts, pollStep)
	     */
	    MetadataModule.prototype.ldmManage = function (projectId, maql, options) {
	        var _this = this;
	        if (options === void 0) { options = {}; }
	        return this.xhr
	            .post("/gdc/md/" + projectId + "/ldm/manage2", { body: { manage: { maql: maql } } })
	            .then(function (r) { return r.getData(); })
	            .then(function (response) {
	            var manageStatusUri = response.entries[0].link;
	            return util_1.handlePolling(_this.xhr.get.bind(_this.xhr), manageStatusUri, _this.isTaskFinished, options);
	        })
	            .then(this.checkStatusForError);
	    };
	    /**
	     * ETL pull
	     *
	     * @experimental
	     * @method etlPull
	     * @param {String} projectId
	     * @param {String} uploadsDir
	     * @param {Object} options for polling (maxAttempts, pollStep)
	     */
	    MetadataModule.prototype.etlPull = function (projectId, uploadsDir, options) {
	        var _this = this;
	        if (options === void 0) { options = {}; }
	        return this.xhr
	            .post("/gdc/md/" + projectId + "/etl/pull2", { body: { pullIntegration: uploadsDir } })
	            .then(function (r) { return r.getData(); })
	            .then(function (response) {
	            var etlPullStatusUri = response.pull2Task.links.poll;
	            return util_1.handlePolling(_this.xhr.get.bind(_this.xhr), etlPullStatusUri, _this.isTaskFinished, options);
	        })
	            .then(this.checkStatusForError);
	    };
	    MetadataModule.prototype.isTaskFinished = function (task) {
	        var taskState = task.wTaskStatus.status;
	        return taskState === "OK" || taskState === "ERROR";
	    };
	    MetadataModule.prototype.checkStatusForError = function (response) {
	        if (response.wTaskStatus.status === "ERROR") {
	            return Promise.reject(response);
	        }
	        return response;
	    };
	    return MetadataModule;
	}());
	exports.MetadataModule = MetadataModule;


/***/ }),
/* 101 */
/***/ (function(module, exports, __webpack_require__) {

	var baseSlice = __webpack_require__(102),
	    isIterateeCall = __webpack_require__(69),
	    toInteger = __webpack_require__(103);

	/* Built-in method references for those with the same name as other `lodash` methods. */
	var nativeCeil = Math.ceil,
	    nativeMax = Math.max;

	/**
	 * Creates an array of elements split into groups the length of `size`.
	 * If `array` can't be split evenly, the final chunk will be the remaining
	 * elements.
	 *
	 * @static
	 * @memberOf _
	 * @since 3.0.0
	 * @category Array
	 * @param {Array} array The array to process.
	 * @param {number} [size=1] The length of each chunk
	 * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
	 * @returns {Array} Returns the new array of chunks.
	 * @example
	 *
	 * _.chunk(['a', 'b', 'c', 'd'], 2);
	 * // => [['a', 'b'], ['c', 'd']]
	 *
	 * _.chunk(['a', 'b', 'c', 'd'], 3);
	 * // => [['a', 'b', 'c'], ['d']]
	 */
	function chunk(array, size, guard) {
	  if ((guard ? isIterateeCall(array, size, guard) : size === undefined)) {
	    size = 1;
	  } else {
	    size = nativeMax(toInteger(size), 0);
	  }
	  var length = array == null ? 0 : array.length;
	  if (!length || size < 1) {
	    return [];
	  }
	  var index = 0,
	      resIndex = 0,
	      result = Array(nativeCeil(length / size));

	  while (index < length) {
	    result[resIndex++] = baseSlice(array, index, (index += size));
	  }
	  return result;
	}

	module.exports = chunk;


/***/ }),
/* 102 */
/***/ (function(module, exports) {

	/**
	 * The base implementation of `_.slice` without an iteratee call guard.
	 *
	 * @private
	 * @param {Array} array The array to slice.
	 * @param {number} [start=0] The start position.
	 * @param {number} [end=array.length] The end position.
	 * @returns {Array} Returns the slice of `array`.
	 */
	function baseSlice(array, start, end) {
	  var index = -1,
	      length = array.length;

	  if (start < 0) {
	    start = -start > length ? 0 : (length + start);
	  }
	  end = end > length ? length : end;
	  if (end < 0) {
	    end += length;
	  }
	  length = start > end ? 0 : ((end - start) >>> 0);
	  start >>>= 0;

	  var result = Array(length);
	  while (++index < length) {
	    result[index] = array[index + start];
	  }
	  return result;
	}

	module.exports = baseSlice;


/***/ }),
/* 103 */
/***/ (function(module, exports) {

	/**
	 * This method returns the first argument it receives.
	 *
	 * @static
	 * @since 0.1.0
	 * @memberOf _
	 * @category Util
	 * @param {*} value Any value.
	 * @returns {*} Returns `value`.
	 * @example
	 *
	 * var object = { 'a': 1 };
	 *
	 * console.log(_.identity(object) === object);
	 * // => true
	 */
	function identity(value) {
	  return value;
	}

	module.exports = identity;


/***/ }),
/* 104 */
/***/ (function(module, exports, __webpack_require__) {

	var baseFlatten = __webpack_require__(105);

	/**
	 * Flattens `array` a single level deep.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Array
	 * @param {Array} array The array to flatten.
	 * @returns {Array} Returns the new flattened array.
	 * @example
	 *
	 * _.flatten([1, [2, [3, [4]], 5]]);
	 * // => [1, 2, [3, [4]], 5]
	 */
	function flatten(array) {
	  var length = array == null ? 0 : array.length;
	  return length ? baseFlatten(array, 1) : [];
	}

	module.exports = flatten;


/***/ }),
/* 105 */
/***/ (function(module, exports, __webpack_require__) {

	var arrayPush = __webpack_require__(106),
	    isFlattenable = __webpack_require__(107);

	/**
	 * The base implementation of `_.flatten` with support for restricting flattening.
	 *
	 * @private
	 * @param {Array} array The array to flatten.
	 * @param {number} depth The maximum recursion depth.
	 * @param {boolean} [predicate=isFlattenable] The function invoked per iteration.
	 * @param {boolean} [isStrict] Restrict to values that pass `predicate` checks.
	 * @param {Array} [result=[]] The initial result value.
	 * @returns {Array} Returns the new flattened array.
	 */
	function baseFlatten(array, depth, predicate, isStrict, result) {
	  var index = -1,
	      length = array.length;

	  predicate || (predicate = isFlattenable);
	  result || (result = []);

	  while (++index < length) {
	    var value = array[index];
	    if (depth > 0 && predicate(value)) {
	      if (depth > 1) {
	        // Recursively flatten arrays (susceptible to call stack limits).
	        baseFlatten(value, depth - 1, predicate, isStrict, result);
	      } else {
	        arrayPush(result, value);
	      }
	    } else if (!isStrict) {
	      result[result.length] = value;
	    }
	  }
	  return result;
	}

	module.exports = baseFlatten;


/***/ }),
/* 106 */
/***/ (function(module, exports) {

	/**
	 * Appends the elements of `values` to `array`.
	 *
	 * @private
	 * @param {Array} array The array to modify.
	 * @param {Array} values The values to append.
	 * @returns {Array} Returns `array`.
	 */
	function arrayPush(array, values) {
	  var index = -1,
	      length = values.length,
	      offset = array.length;

	  while (++index < length) {
	    array[offset + index] = values[index];
	  }
	  return array;
	}

	module.exports = arrayPush;


/***/ }),
/* 107 */
/***/ (function(module, exports, __webpack_require__) {

	var Symbol = __webpack_require__(108),
	    isArguments = __webpack_require__(79),
	    isArray = __webpack_require__(44);

	/** Built-in value references. */
	var spreadableSymbol = Symbol ? Symbol.isConcatSpreadable : undefined;

	/**
	 * Checks if `value` is a flattenable `arguments` object or array.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is flattenable, else `false`.
	 */
	function isFlattenable(value) {
	  return isArray(value) || isArguments(value) ||
	    !!(spreadableSymbol && value && value[spreadableSymbol]);
	}

	module.exports = isFlattenable;


/***/ }),
/* 108 */
/***/ (function(module, exports, __webpack_require__) {

	var root = __webpack_require__(27);

	/** Built-in value references. */
	var Symbol = root.Symbol;

	module.exports = Symbol;


/***/ }),
/* 109 */
/***/ (function(module, exports, __webpack_require__) {

	var basePick = __webpack_require__(110),
	    flatRest = __webpack_require__(115);

	/**
	 * Creates an object composed of the picked `object` properties.
	 *
	 * @static
	 * @since 0.1.0
	 * @memberOf _
	 * @category Object
	 * @param {Object} object The source object.
	 * @param {...(string|string[])} [paths] The property paths to pick.
	 * @returns {Object} Returns the new object.
	 * @example
	 *
	 * var object = { 'a': 1, 'b': '2', 'c': 3 };
	 *
	 * _.pick(object, ['a', 'c']);
	 * // => { 'a': 1, 'c': 3 }
	 */
	var pick = flatRest(function(object, paths) {
	  return object == null ? {} : basePick(object, paths);
	});

	module.exports = pick;


/***/ }),
/* 110 */
/***/ (function(module, exports, __webpack_require__) {

	var basePickBy = __webpack_require__(111),
	    hasIn = __webpack_require__(112);

	/**
	 * The base implementation of `_.pick` without support for individual
	 * property identifiers.
	 *
	 * @private
	 * @param {Object} object The source object.
	 * @param {string[]} paths The property paths to pick.
	 * @returns {Object} Returns the new object.
	 */
	function basePick(object, paths) {
	  return basePickBy(object, paths, function(value, path) {
	    return hasIn(object, path);
	  });
	}

	module.exports = basePick;


/***/ }),
/* 111 */
/***/ (function(module, exports, __webpack_require__) {

	var baseGet = __webpack_require__(90),
	    baseSet = __webpack_require__(54),
	    castPath = __webpack_require__(55);

	/**
	 * The base implementation of  `_.pickBy` without support for iteratee shorthands.
	 *
	 * @private
	 * @param {Object} object The source object.
	 * @param {string[]} paths The property paths to pick.
	 * @param {Function} predicate The function invoked per property.
	 * @returns {Object} Returns the new object.
	 */
	function basePickBy(object, paths, predicate) {
	  var index = -1,
	      length = paths.length,
	      result = {};

	  while (++index < length) {
	    var path = paths[index],
	        value = baseGet(object, path);

	    if (predicate(value, path)) {
	      baseSet(result, castPath(path, object), value);
	    }
	  }
	  return result;
	}

	module.exports = basePickBy;


/***/ }),
/* 112 */
/***/ (function(module, exports, __webpack_require__) {

	var baseHasIn = __webpack_require__(113),
	    hasPath = __webpack_require__(114);

	/**
	 * Checks if `path` is a direct or inherited property of `object`.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Object
	 * @param {Object} object The object to query.
	 * @param {Array|string} path The path to check.
	 * @returns {boolean} Returns `true` if `path` exists, else `false`.
	 * @example
	 *
	 * var object = _.create({ 'a': _.create({ 'b': 2 }) });
	 *
	 * _.hasIn(object, 'a');
	 * // => true
	 *
	 * _.hasIn(object, 'a.b');
	 * // => true
	 *
	 * _.hasIn(object, ['a', 'b']);
	 * // => true
	 *
	 * _.hasIn(object, 'b');
	 * // => false
	 */
	function hasIn(object, path) {
	  return object != null && hasPath(object, path, baseHasIn);
	}

	module.exports = hasIn;


/***/ }),
/* 113 */
/***/ (function(module, exports) {

	/**
	 * The base implementation of `_.hasIn` without support for deep paths.
	 *
	 * @private
	 * @param {Object} [object] The object to query.
	 * @param {Array|string} key The key to check.
	 * @returns {boolean} Returns `true` if `key` exists, else `false`.
	 */
	function baseHasIn(object, key) {
	  return object != null && key in Object(object);
	}

	module.exports = baseHasIn;


/***/ }),
/* 114 */
/***/ (function(module, exports, __webpack_require__) {

	var castPath = __webpack_require__(55),
	    isArguments = __webpack_require__(79),
	    isArray = __webpack_require__(44),
	    isIndex = __webpack_require__(61),
	    isLength = __webpack_require__(82),
	    toKey = __webpack_require__(62);

	/**
	 * Checks if `path` exists on `object`.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @param {Array|string} path The path to check.
	 * @param {Function} hasFunc The function to check properties.
	 * @returns {boolean} Returns `true` if `path` exists, else `false`.
	 */
	function hasPath(object, path, hasFunc) {
	  path = castPath(path, object);

	  var index = -1,
	      length = path.length,
	      result = false;

	  while (++index < length) {
	    var key = toKey(path[index]);
	    if (!(result = object != null && hasFunc(object, key))) {
	      break;
	    }
	    object = object[key];
	  }
	  if (result || ++index != length) {
	    return result;
	  }
	  length = object == null ? 0 : object.length;
	  return !!length && isLength(length) && isIndex(key, length) &&
	    (isArray(object) || isArguments(object));
	}

	module.exports = hasPath;


/***/ }),
/* 115 */
/***/ (function(module, exports, __webpack_require__) {

	var flatten = __webpack_require__(104),
	    overRest = __webpack_require__(66),
	    setToString = __webpack_require__(68);

	/**
	 * A specialized version of `baseRest` which flattens the rest array.
	 *
	 * @private
	 * @param {Function} func The function to apply a rest parameter to.
	 * @returns {Function} Returns the new function.
	 */
	function flatRest(func) {
	  return setToString(overRest(func, undefined, flatten), func + '');
	}

	module.exports = flatRest;


/***/ }),
/* 116 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var __assign = (this && this.__assign) || function () {
	    __assign = Object.assign || function(t) {
	        for (var s, i = 1, n = arguments.length; i < n; i++) {
	            s = arguments[i];
	            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
	                t[p] = s[p];
	        }
	        return t;
	    };
	    return __assign.apply(this, arguments);
	};
	var __importDefault = (this && this.__importDefault) || function (mod) {
	    return (mod && mod.__esModule) ? mod : { "default": mod };
	};
	Object.defineProperty(exports, "__esModule", { value: true });
	var isEmpty_1 = __importDefault(__webpack_require__(117));
	var omit_1 = __importDefault(__webpack_require__(119));
	var isArray_1 = __importDefault(__webpack_require__(44));
	var isObject_1 = __importDefault(__webpack_require__(41));
	var isString_1 = __importDefault(__webpack_require__(125));
	var json_stable_stringify_1 = __importDefault(__webpack_require__(126));
	var uuid_1 = __webpack_require__(130);
	var uri_1 = __webpack_require__(135);
	/*
	 * Helpers
	 */
	var getReferenceValue = function (id, references) { return references[id]; };
	var getReferenceId = function (value, references) {
	    return Object.keys(references).find(function (id) { return references[id] === value; });
	};
	var defaultIdGenerator = function () { return uuid_1.v4().replace(/-/g, ""); };
	/**
	 * Recursively traverses the object and tries to apply a conversion to every string value
	 */
	var traverse = function (obj, convert) {
	    if (isArray_1.default(obj)) {
	        return obj.map(function (a) { return traverse(a, convert); });
	    }
	    else if (isObject_1.default(obj)) {
	        var object_1 = obj;
	        return Object.keys(object_1).reduce(function (result, key) {
	            result[key] = traverse(object_1[key], convert);
	            return result;
	        }, {});
	    }
	    else if (isString_1.default(obj)) {
	        return convert(obj);
	    }
	    else {
	        return obj;
	    }
	};
	var createConverter = function (conversionFunction) { return function (mdObject, idGenerator) {
	    if (idGenerator === void 0) { idGenerator = defaultIdGenerator; }
	    var content = mdObject.content;
	    if (!content) {
	        return mdObject;
	    }
	    var properties = content.properties;
	    if (!properties) {
	        return mdObject;
	    }
	    // prepare result objects
	    var originalProperties = JSON.parse(properties);
	    var originalReferences = content.references || {};
	    var _a = conversionFunction(originalProperties, originalReferences, idGenerator), convertedProperties = _a.convertedProperties, convertedReferences = _a.convertedReferences;
	    // set the new properties and references
	    var referencesProp = isEmpty_1.default(convertedReferences) ? undefined : { references: convertedReferences };
	    var result = __assign({}, mdObject, { content: __assign({}, omit_1.default(mdObject.content, "references"), { properties: json_stable_stringify_1.default(convertedProperties) }, referencesProp) });
	    return result;
	}; };
	/*
	 * Conversion from References to URIs
	 */
	var convertReferenceToUri = function (references) { return function (value) { return getReferenceValue(value, references) || value; }; };
	/**
	 * Converts reference based values to actual URIs
	 *
	 * @param mdObject The object to convert properties of
	 * @param [idGenerator=uuid] Function that returns unique ids
	 */
	exports.convertReferencesToUris = createConverter(function (originalProperties, originalReferences) {
	    var convertedProperties = traverse(originalProperties, convertReferenceToUri(originalReferences));
	    return {
	        convertedProperties: convertedProperties,
	        convertedReferences: originalReferences,
	    };
	});
	/*
	 * Conversion from URIs to References
	 */
	var createUriToReferenceConverter = function (originalReferences, idGenerator) {
	    var convertedReferences = {};
	    return {
	        convertedReferences: convertedReferences,
	        conversion: function (value) {
	            if (!uri_1.isUri(value)) {
	                return value;
	            }
	            var id = getReferenceId(value, originalReferences) || // try to reuse original references
	                getReferenceId(value, convertedReferences) || // or use already converted new references
	                idGenerator(); // or get a completely new id
	            convertedReferences[id] = value;
	            return id;
	        },
	    };
	};
	/**
	 * Converts URIs to reference based values
	 *
	 * @param mdObject The object to convert properties of
	 * @param [idGenerator=uuid] Function that returns unique ids
	 */
	exports.convertUrisToReferences = createConverter(function (originalProperties, originalReferences, idGenerator) {
	    var converter = createUriToReferenceConverter(originalReferences, idGenerator);
	    var convertedProperties = traverse(originalProperties, converter.conversion);
	    return {
	        convertedProperties: convertedProperties,
	        convertedReferences: converter.convertedReferences,
	    };
	});


/***/ }),
/* 117 */
/***/ (function(module, exports, __webpack_require__) {

	var baseKeys = __webpack_require__(118),
	    getTag = __webpack_require__(36),
	    isArguments = __webpack_require__(79),
	    isArray = __webpack_require__(44),
	    isArrayLike = __webpack_require__(81),
	    isBuffer = __webpack_require__(45),
	    isPrototype = __webpack_require__(43),
	    isTypedArray = __webpack_require__(83);

	/** `Object#toString` result references. */
	var mapTag = '[object Map]',
	    setTag = '[object Set]';

	/** Used for built-in method references. */
	var objectProto = Object.prototype;

	/** Used to check objects for own properties. */
	var hasOwnProperty = objectProto.hasOwnProperty;

	/**
	 * Checks if `value` is an empty object, collection, map, or set.
	 *
	 * Objects are considered empty if they have no own enumerable string keyed
	 * properties.
	 *
	 * Array-like values such as `arguments` objects, arrays, buffers, strings, or
	 * jQuery-like collections are considered empty if they have a `length` of `0`.
	 * Similarly, maps and sets are considered empty if they have a `size` of `0`.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is empty, else `false`.
	 * @example
	 *
	 * _.isEmpty(null);
	 * // => true
	 *
	 * _.isEmpty(true);
	 * // => true
	 *
	 * _.isEmpty(1);
	 * // => true
	 *
	 * _.isEmpty([1, 2, 3]);
	 * // => false
	 *
	 * _.isEmpty({ 'a': 1 });
	 * // => false
	 */
	function isEmpty(value) {
	  if (value == null) {
	    return true;
	  }
	  if (isArrayLike(value) &&
	      (isArray(value) || typeof value == 'string' || typeof value.splice == 'function' ||
	        isBuffer(value) || isTypedArray(value) || isArguments(value))) {
	    return !value.length;
	  }
	  var tag = getTag(value);
	  if (tag == mapTag || tag == setTag) {
	    return !value.size;
	  }
	  if (isPrototype(value)) {
	    return !baseKeys(value).length;
	  }
	  for (var key in value) {
	    if (hasOwnProperty.call(value, key)) {
	      return false;
	    }
	  }
	  return true;
	}

	module.exports = isEmpty;


/***/ }),
/* 118 */
/***/ (function(module, exports, __webpack_require__) {

	var overArg = __webpack_require__(22);

	/* Built-in method references for those with the same name as other `lodash` methods. */
	var nativeKeys = overArg(Object.keys, Object);

	module.exports = nativeKeys;


/***/ }),
/* 119 */
/***/ (function(module, exports, __webpack_require__) {

	var arrayMap = __webpack_require__(120),
	    baseClone = __webpack_require__(5),
	    baseUnset = __webpack_require__(121),
	    castPath = __webpack_require__(55),
	    copyObject = __webpack_require__(20),
	    customOmitClone = __webpack_require__(124),
	    flatRest = __webpack_require__(115),
	    getAllKeysIn = __webpack_require__(35);

	/** Used to compose bitmasks for cloning. */
	var CLONE_DEEP_FLAG = 1,
	    CLONE_FLAT_FLAG = 2,
	    CLONE_SYMBOLS_FLAG = 4;

	/**
	 * The opposite of `_.pick`; this method creates an object composed of the
	 * own and inherited enumerable property paths of `object` that are not omitted.
	 *
	 * **Note:** This method is considerably slower than `_.pick`.
	 *
	 * @static
	 * @since 0.1.0
	 * @memberOf _
	 * @category Object
	 * @param {Object} object The source object.
	 * @param {...(string|string[])} [paths] The property paths to omit.
	 * @returns {Object} Returns the new object.
	 * @example
	 *
	 * var object = { 'a': 1, 'b': '2', 'c': 3 };
	 *
	 * _.omit(object, ['a', 'c']);
	 * // => { 'b': '2' }
	 */
	var omit = flatRest(function(object, paths) {
	  var result = {};
	  if (object == null) {
	    return result;
	  }
	  var isDeep = false;
	  paths = arrayMap(paths, function(path) {
	    path = castPath(path, object);
	    isDeep || (isDeep = path.length > 1);
	    return path;
	  });
	  copyObject(object, getAllKeysIn(object), result);
	  if (isDeep) {
	    result = baseClone(result, CLONE_DEEP_FLAG | CLONE_FLAT_FLAG | CLONE_SYMBOLS_FLAG, customOmitClone);
	  }
	  var length = paths.length;
	  while (length--) {
	    baseUnset(result, paths[length]);
	  }
	  return result;
	});

	module.exports = omit;


/***/ }),
/* 120 */
/***/ (function(module, exports) {

	/**
	 * A specialized version of `_.map` for arrays without support for iteratee
	 * shorthands.
	 *
	 * @private
	 * @param {Array} [array] The array to iterate over.
	 * @param {Function} iteratee The function invoked per iteration.
	 * @returns {Array} Returns the new mapped array.
	 */
	function arrayMap(array, iteratee) {
	  var index = -1,
	      length = array == null ? 0 : array.length,
	      result = Array(length);

	  while (++index < length) {
	    result[index] = iteratee(array[index], index, array);
	  }
	  return result;
	}

	module.exports = arrayMap;


/***/ }),
/* 121 */
/***/ (function(module, exports, __webpack_require__) {

	var castPath = __webpack_require__(55),
	    last = __webpack_require__(122),
	    parent = __webpack_require__(123),
	    toKey = __webpack_require__(62);

	/**
	 * The base implementation of `_.unset`.
	 *
	 * @private
	 * @param {Object} object The object to modify.
	 * @param {Array|string} path The property path to unset.
	 * @returns {boolean} Returns `true` if the property is deleted, else `false`.
	 */
	function baseUnset(object, path) {
	  path = castPath(path, object);
	  object = parent(object, path);
	  return object == null || delete object[toKey(last(path))];
	}

	module.exports = baseUnset;


/***/ }),
/* 122 */
/***/ (function(module, exports) {

	/**
	 * Gets the last element of `array`.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Array
	 * @param {Array} array The array to query.
	 * @returns {*} Returns the last element of `array`.
	 * @example
	 *
	 * _.last([1, 2, 3]);
	 * // => 3
	 */
	function last(array) {
	  var length = array == null ? 0 : array.length;
	  return length ? array[length - 1] : undefined;
	}

	module.exports = last;


/***/ }),
/* 123 */
/***/ (function(module, exports, __webpack_require__) {

	var baseGet = __webpack_require__(90),
	    baseSlice = __webpack_require__(102);

	/**
	 * Gets the parent value at `path` of `object`.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @param {Array} path The path to get the parent value of.
	 * @returns {*} Returns the parent value.
	 */
	function parent(object, path) {
	  return path.length < 2 ? object : baseGet(object, baseSlice(path, 0, -1));
	}

	module.exports = parent;


/***/ }),
/* 124 */
/***/ (function(module, exports, __webpack_require__) {

	var isPlainObject = __webpack_require__(49);

	/**
	 * Used by `_.omit` to customize its `_.cloneDeep` use to only clone plain
	 * objects.
	 *
	 * @private
	 * @param {*} value The value to inspect.
	 * @param {string} key The key of the property to inspect.
	 * @returns {*} Returns the uncloned value or `undefined` to defer cloning to `_.cloneDeep`.
	 */
	function customOmitClone(value) {
	  return isPlainObject(value) ? undefined : value;
	}

	module.exports = customOmitClone;


/***/ }),
/* 125 */
/***/ (function(module, exports, __webpack_require__) {

	var baseGetTag = __webpack_require__(50),
	    isArray = __webpack_require__(44),
	    isObjectLike = __webpack_require__(51);

	/** `Object#toString` result references. */
	var stringTag = '[object String]';

	/**
	 * Checks if `value` is classified as a `String` primitive or object.
	 *
	 * @static
	 * @since 0.1.0
	 * @memberOf _
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a string, else `false`.
	 * @example
	 *
	 * _.isString('abc');
	 * // => true
	 *
	 * _.isString(1);
	 * // => false
	 */
	function isString(value) {
	  return typeof value == 'string' ||
	    (!isArray(value) && isObjectLike(value) && baseGetTag(value) == stringTag);
	}

	module.exports = isString;


/***/ }),
/* 126 */
/***/ (function(module, exports, __webpack_require__) {

	var json = typeof JSON !== 'undefined' ? JSON : __webpack_require__(127);

	module.exports = function (obj, opts) {
	    if (!opts) opts = {};
	    if (typeof opts === 'function') opts = { cmp: opts };
	    var space = opts.space || '';
	    if (typeof space === 'number') space = Array(space+1).join(' ');
	    var cycles = (typeof opts.cycles === 'boolean') ? opts.cycles : false;
	    var replacer = opts.replacer || function(key, value) { return value; };

	    var cmp = opts.cmp && (function (f) {
	        return function (node) {
	            return function (a, b) {
	                var aobj = { key: a, value: node[a] };
	                var bobj = { key: b, value: node[b] };
	                return f(aobj, bobj);
	            };
	        };
	    })(opts.cmp);

	    var seen = [];
	    return (function stringify (parent, key, node, level) {
	        var indent = space ? ('\n' + new Array(level + 1).join(space)) : '';
	        var colonSeparator = space ? ': ' : ':';

	        if (node && node.toJSON && typeof node.toJSON === 'function') {
	            node = node.toJSON();
	        }

	        node = replacer.call(parent, key, node);

	        if (node === undefined) {
	            return;
	        }
	        if (typeof node !== 'object' || node === null) {
	            return json.stringify(node);
	        }
	        if (isArray(node)) {
	            var out = [];
	            for (var i = 0; i < node.length; i++) {
	                var item = stringify(node, i, node[i], level+1) || json.stringify(null);
	                out.push(indent + space + item);
	            }
	            return '[' + out.join(',') + indent + ']';
	        }
	        else {
	            if (seen.indexOf(node) !== -1) {
	                if (cycles) return json.stringify('__cycle__');
	                throw new TypeError('Converting circular structure to JSON');
	            }
	            else seen.push(node);

	            var keys = objectKeys(node).sort(cmp && cmp(node));
	            var out = [];
	            for (var i = 0; i < keys.length; i++) {
	                var key = keys[i];
	                var value = stringify(node, key, node[key], level+1);

	                if(!value) continue;

	                var keyValue = json.stringify(key)
	                    + colonSeparator
	                    + value;
	                ;
	                out.push(indent + space + keyValue);
	            }
	            seen.splice(seen.indexOf(node), 1);
	            return '{' + out.join(',') + indent + '}';
	        }
	    })({ '': obj }, '', obj, 0);
	};

	var isArray = Array.isArray || function (x) {
	    return {}.toString.call(x) === '[object Array]';
	};

	var objectKeys = Object.keys || function (obj) {
	    var has = Object.prototype.hasOwnProperty || function () { return true };
	    var keys = [];
	    for (var key in obj) {
	        if (has.call(obj, key)) keys.push(key);
	    }
	    return keys;
	};


/***/ }),
/* 127 */
/***/ (function(module, exports, __webpack_require__) {

	exports.parse = __webpack_require__(128);
	exports.stringify = __webpack_require__(129);


/***/ }),
/* 128 */
/***/ (function(module, exports) {

	var at, // The index of the current character
	    ch, // The current character
	    escapee = {
	        '"':  '"',
	        '\\': '\\',
	        '/':  '/',
	        b:    '\b',
	        f:    '\f',
	        n:    '\n',
	        r:    '\r',
	        t:    '\t'
	    },
	    text,

	    error = function (m) {
	        // Call error when something is wrong.
	        throw {
	            name:    'SyntaxError',
	            message: m,
	            at:      at,
	            text:    text
	        };
	    },
	    
	    next = function (c) {
	        // If a c parameter is provided, verify that it matches the current character.
	        if (c && c !== ch) {
	            error("Expected '" + c + "' instead of '" + ch + "'");
	        }
	        
	        // Get the next character. When there are no more characters,
	        // return the empty string.
	        
	        ch = text.charAt(at);
	        at += 1;
	        return ch;
	    },
	    
	    number = function () {
	        // Parse a number value.
	        var number,
	            string = '';
	        
	        if (ch === '-') {
	            string = '-';
	            next('-');
	        }
	        while (ch >= '0' && ch <= '9') {
	            string += ch;
	            next();
	        }
	        if (ch === '.') {
	            string += '.';
	            while (next() && ch >= '0' && ch <= '9') {
	                string += ch;
	            }
	        }
	        if (ch === 'e' || ch === 'E') {
	            string += ch;
	            next();
	            if (ch === '-' || ch === '+') {
	                string += ch;
	                next();
	            }
	            while (ch >= '0' && ch <= '9') {
	                string += ch;
	                next();
	            }
	        }
	        number = +string;
	        if (!isFinite(number)) {
	            error("Bad number");
	        } else {
	            return number;
	        }
	    },
	    
	    string = function () {
	        // Parse a string value.
	        var hex,
	            i,
	            string = '',
	            uffff;
	        
	        // When parsing for string values, we must look for " and \ characters.
	        if (ch === '"') {
	            while (next()) {
	                if (ch === '"') {
	                    next();
	                    return string;
	                } else if (ch === '\\') {
	                    next();
	                    if (ch === 'u') {
	                        uffff = 0;
	                        for (i = 0; i < 4; i += 1) {
	                            hex = parseInt(next(), 16);
	                            if (!isFinite(hex)) {
	                                break;
	                            }
	                            uffff = uffff * 16 + hex;
	                        }
	                        string += String.fromCharCode(uffff);
	                    } else if (typeof escapee[ch] === 'string') {
	                        string += escapee[ch];
	                    } else {
	                        break;
	                    }
	                } else {
	                    string += ch;
	                }
	            }
	        }
	        error("Bad string");
	    },

	    white = function () {

	// Skip whitespace.

	        while (ch && ch <= ' ') {
	            next();
	        }
	    },

	    word = function () {

	// true, false, or null.

	        switch (ch) {
	        case 't':
	            next('t');
	            next('r');
	            next('u');
	            next('e');
	            return true;
	        case 'f':
	            next('f');
	            next('a');
	            next('l');
	            next('s');
	            next('e');
	            return false;
	        case 'n':
	            next('n');
	            next('u');
	            next('l');
	            next('l');
	            return null;
	        }
	        error("Unexpected '" + ch + "'");
	    },

	    value,  // Place holder for the value function.

	    array = function () {

	// Parse an array value.

	        var array = [];

	        if (ch === '[') {
	            next('[');
	            white();
	            if (ch === ']') {
	                next(']');
	                return array;   // empty array
	            }
	            while (ch) {
	                array.push(value());
	                white();
	                if (ch === ']') {
	                    next(']');
	                    return array;
	                }
	                next(',');
	                white();
	            }
	        }
	        error("Bad array");
	    },

	    object = function () {

	// Parse an object value.

	        var key,
	            object = {};

	        if (ch === '{') {
	            next('{');
	            white();
	            if (ch === '}') {
	                next('}');
	                return object;   // empty object
	            }
	            while (ch) {
	                key = string();
	                white();
	                next(':');
	                if (Object.hasOwnProperty.call(object, key)) {
	                    error('Duplicate key "' + key + '"');
	                }
	                object[key] = value();
	                white();
	                if (ch === '}') {
	                    next('}');
	                    return object;
	                }
	                next(',');
	                white();
	            }
	        }
	        error("Bad object");
	    };

	value = function () {

	// Parse a JSON value. It could be an object, an array, a string, a number,
	// or a word.

	    white();
	    switch (ch) {
	    case '{':
	        return object();
	    case '[':
	        return array();
	    case '"':
	        return string();
	    case '-':
	        return number();
	    default:
	        return ch >= '0' && ch <= '9' ? number() : word();
	    }
	};

	// Return the json_parse function. It will have access to all of the above
	// functions and variables.

	module.exports = function (source, reviver) {
	    var result;
	    
	    text = source;
	    at = 0;
	    ch = ' ';
	    result = value();
	    white();
	    if (ch) {
	        error("Syntax error");
	    }

	    // If there is a reviver function, we recursively walk the new structure,
	    // passing each name/value pair to the reviver function for possible
	    // transformation, starting with a temporary root object that holds the result
	    // in an empty key. If there is not a reviver function, we simply return the
	    // result.

	    return typeof reviver === 'function' ? (function walk(holder, key) {
	        var k, v, value = holder[key];
	        if (value && typeof value === 'object') {
	            for (k in value) {
	                if (Object.prototype.hasOwnProperty.call(value, k)) {
	                    v = walk(value, k);
	                    if (v !== undefined) {
	                        value[k] = v;
	                    } else {
	                        delete value[k];
	                    }
	                }
	            }
	        }
	        return reviver.call(holder, key, value);
	    }({'': result}, '')) : result;
	};


/***/ }),
/* 129 */
/***/ (function(module, exports) {

	var cx = /[\u0000\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g,
	    escapable = /[\\\"\x00-\x1f\x7f-\x9f\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g,
	    gap,
	    indent,
	    meta = {    // table of character substitutions
	        '\b': '\\b',
	        '\t': '\\t',
	        '\n': '\\n',
	        '\f': '\\f',
	        '\r': '\\r',
	        '"' : '\\"',
	        '\\': '\\\\'
	    },
	    rep;

	function quote(string) {
	    // If the string contains no control characters, no quote characters, and no
	    // backslash characters, then we can safely slap some quotes around it.
	    // Otherwise we must also replace the offending characters with safe escape
	    // sequences.
	    
	    escapable.lastIndex = 0;
	    return escapable.test(string) ? '"' + string.replace(escapable, function (a) {
	        var c = meta[a];
	        return typeof c === 'string' ? c :
	            '\\u' + ('0000' + a.charCodeAt(0).toString(16)).slice(-4);
	    }) + '"' : '"' + string + '"';
	}

	function str(key, holder) {
	    // Produce a string from holder[key].
	    var i,          // The loop counter.
	        k,          // The member key.
	        v,          // The member value.
	        length,
	        mind = gap,
	        partial,
	        value = holder[key];
	    
	    // If the value has a toJSON method, call it to obtain a replacement value.
	    if (value && typeof value === 'object' &&
	            typeof value.toJSON === 'function') {
	        value = value.toJSON(key);
	    }
	    
	    // If we were called with a replacer function, then call the replacer to
	    // obtain a replacement value.
	    if (typeof rep === 'function') {
	        value = rep.call(holder, key, value);
	    }
	    
	    // What happens next depends on the value's type.
	    switch (typeof value) {
	        case 'string':
	            return quote(value);
	        
	        case 'number':
	            // JSON numbers must be finite. Encode non-finite numbers as null.
	            return isFinite(value) ? String(value) : 'null';
	        
	        case 'boolean':
	        case 'null':
	            // If the value is a boolean or null, convert it to a string. Note:
	            // typeof null does not produce 'null'. The case is included here in
	            // the remote chance that this gets fixed someday.
	            return String(value);
	            
	        case 'object':
	            if (!value) return 'null';
	            gap += indent;
	            partial = [];
	            
	            // Array.isArray
	            if (Object.prototype.toString.apply(value) === '[object Array]') {
	                length = value.length;
	                for (i = 0; i < length; i += 1) {
	                    partial[i] = str(i, value) || 'null';
	                }
	                
	                // Join all of the elements together, separated with commas, and
	                // wrap them in brackets.
	                v = partial.length === 0 ? '[]' : gap ?
	                    '[\n' + gap + partial.join(',\n' + gap) + '\n' + mind + ']' :
	                    '[' + partial.join(',') + ']';
	                gap = mind;
	                return v;
	            }
	            
	            // If the replacer is an array, use it to select the members to be
	            // stringified.
	            if (rep && typeof rep === 'object') {
	                length = rep.length;
	                for (i = 0; i < length; i += 1) {
	                    k = rep[i];
	                    if (typeof k === 'string') {
	                        v = str(k, value);
	                        if (v) {
	                            partial.push(quote(k) + (gap ? ': ' : ':') + v);
	                        }
	                    }
	                }
	            }
	            else {
	                // Otherwise, iterate through all of the keys in the object.
	                for (k in value) {
	                    if (Object.prototype.hasOwnProperty.call(value, k)) {
	                        v = str(k, value);
	                        if (v) {
	                            partial.push(quote(k) + (gap ? ': ' : ':') + v);
	                        }
	                    }
	                }
	            }
	            
	        // Join all of the member texts together, separated with commas,
	        // and wrap them in braces.

	        v = partial.length === 0 ? '{}' : gap ?
	            '{\n' + gap + partial.join(',\n' + gap) + '\n' + mind + '}' :
	            '{' + partial.join(',') + '}';
	        gap = mind;
	        return v;
	    }
	}

	module.exports = function (value, replacer, space) {
	    var i;
	    gap = '';
	    indent = '';
	    
	    // If the space parameter is a number, make an indent string containing that
	    // many spaces.
	    if (typeof space === 'number') {
	        for (i = 0; i < space; i += 1) {
	            indent += ' ';
	        }
	    }
	    // If the space parameter is a string, it will be used as the indent string.
	    else if (typeof space === 'string') {
	        indent = space;
	    }

	    // If there is a replacer, it must be a function or an array.
	    // Otherwise, throw an error.
	    rep = replacer;
	    if (replacer && typeof replacer !== 'function'
	    && (typeof replacer !== 'object' || typeof replacer.length !== 'number')) {
	        throw new Error('JSON.stringify');
	    }
	    
	    // Make a fake root object containing our value under the key of ''.
	    // Return the result of stringifying the value.
	    return str('', {'': value});
	};


/***/ }),
/* 130 */
/***/ (function(module, exports, __webpack_require__) {

	var v1 = __webpack_require__(131);
	var v4 = __webpack_require__(134);

	var uuid = v4;
	uuid.v1 = v1;
	uuid.v4 = v4;

	module.exports = uuid;


/***/ }),
/* 131 */
/***/ (function(module, exports, __webpack_require__) {

	var rng = __webpack_require__(132);
	var bytesToUuid = __webpack_require__(133);

	// **`v1()` - Generate time-based UUID**
	//
	// Inspired by https://github.com/LiosK/UUID.js
	// and http://docs.python.org/library/uuid.html

	var _nodeId;
	var _clockseq;

	// Previous uuid creation time
	var _lastMSecs = 0;
	var _lastNSecs = 0;

	// See https://github.com/uuidjs/uuid for API details
	function v1(options, buf, offset) {
	  var i = buf && offset || 0;
	  var b = buf || [];

	  options = options || {};
	  var node = options.node || _nodeId;
	  var clockseq = options.clockseq !== undefined ? options.clockseq : _clockseq;

	  // node and clockseq need to be initialized to random values if they're not
	  // specified.  We do this lazily to minimize issues related to insufficient
	  // system entropy.  See #189
	  if (node == null || clockseq == null) {
	    var seedBytes = rng();
	    if (node == null) {
	      // Per 4.5, create and 48-bit node id, (47 random bits + multicast bit = 1)
	      node = _nodeId = [
	        seedBytes[0] | 0x01,
	        seedBytes[1], seedBytes[2], seedBytes[3], seedBytes[4], seedBytes[5]
	      ];
	    }
	    if (clockseq == null) {
	      // Per 4.2.2, randomize (14 bit) clockseq
	      clockseq = _clockseq = (seedBytes[6] << 8 | seedBytes[7]) & 0x3fff;
	    }
	  }

	  // UUID timestamps are 100 nano-second units since the Gregorian epoch,
	  // (1582-10-15 00:00).  JSNumbers aren't precise enough for this, so
	  // time is handled internally as 'msecs' (integer milliseconds) and 'nsecs'
	  // (100-nanoseconds offset from msecs) since unix epoch, 1970-01-01 00:00.
	  var msecs = options.msecs !== undefined ? options.msecs : new Date().getTime();

	  // Per 4.2.1.2, use count of uuid's generated during the current clock
	  // cycle to simulate higher resolution clock
	  var nsecs = options.nsecs !== undefined ? options.nsecs : _lastNSecs + 1;

	  // Time since last uuid creation (in msecs)
	  var dt = (msecs - _lastMSecs) + (nsecs - _lastNSecs)/10000;

	  // Per 4.2.1.2, Bump clockseq on clock regression
	  if (dt < 0 && options.clockseq === undefined) {
	    clockseq = clockseq + 1 & 0x3fff;
	  }

	  // Reset nsecs if clock regresses (new clockseq) or we've moved onto a new
	  // time interval
	  if ((dt < 0 || msecs > _lastMSecs) && options.nsecs === undefined) {
	    nsecs = 0;
	  }

	  // Per 4.2.1.2 Throw error if too many uuids are requested
	  if (nsecs >= 10000) {
	    throw new Error('uuid.v1(): Can\'t create more than 10M uuids/sec');
	  }

	  _lastMSecs = msecs;
	  _lastNSecs = nsecs;
	  _clockseq = clockseq;

	  // Per 4.1.4 - Convert from unix epoch to Gregorian epoch
	  msecs += 12219292800000;

	  // `time_low`
	  var tl = ((msecs & 0xfffffff) * 10000 + nsecs) % 0x100000000;
	  b[i++] = tl >>> 24 & 0xff;
	  b[i++] = tl >>> 16 & 0xff;
	  b[i++] = tl >>> 8 & 0xff;
	  b[i++] = tl & 0xff;

	  // `time_mid`
	  var tmh = (msecs / 0x100000000 * 10000) & 0xfffffff;
	  b[i++] = tmh >>> 8 & 0xff;
	  b[i++] = tmh & 0xff;

	  // `time_high_and_version`
	  b[i++] = tmh >>> 24 & 0xf | 0x10; // include version
	  b[i++] = tmh >>> 16 & 0xff;

	  // `clock_seq_hi_and_reserved` (Per 4.2.2 - include variant)
	  b[i++] = clockseq >>> 8 | 0x80;

	  // `clock_seq_low`
	  b[i++] = clockseq & 0xff;

	  // `node`
	  for (var n = 0; n < 6; ++n) {
	    b[i + n] = node[n];
	  }

	  return buf ? buf : bytesToUuid(b);
	}

	module.exports = v1;


/***/ }),
/* 132 */
/***/ (function(module, exports) {

	// Unique ID creation requires a high quality random # generator.  In the
	// browser this is a little complicated due to unknown quality of Math.random()
	// and inconsistent support for the `crypto` API.  We do the best we can via
	// feature-detection

	// getRandomValues needs to be invoked in a context where "this" is a Crypto
	// implementation. Also, find the complete implementation of crypto on IE11.
	var getRandomValues = (typeof(crypto) != 'undefined' && crypto.getRandomValues && crypto.getRandomValues.bind(crypto)) ||
	                      (typeof(msCrypto) != 'undefined' && typeof window.msCrypto.getRandomValues == 'function' && msCrypto.getRandomValues.bind(msCrypto));

	if (getRandomValues) {
	  // WHATWG crypto RNG - http://wiki.whatwg.org/wiki/Crypto
	  var rnds8 = new Uint8Array(16); // eslint-disable-line no-undef

	  module.exports = function whatwgRNG() {
	    getRandomValues(rnds8);
	    return rnds8;
	  };
	} else {
	  // Math.random()-based (RNG)
	  //
	  // If all else fails, use Math.random().  It's fast, but is of unspecified
	  // quality.
	  var rnds = new Array(16);

	  module.exports = function mathRNG() {
	    for (var i = 0, r; i < 16; i++) {
	      if ((i & 0x03) === 0) r = Math.random() * 0x100000000;
	      rnds[i] = r >>> ((i & 0x03) << 3) & 0xff;
	    }

	    return rnds;
	  };
	}


/***/ }),
/* 133 */
/***/ (function(module, exports) {

	/**
	 * Convert array of 16 byte values to UUID string format of the form:
	 * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX
	 */
	var byteToHex = [];
	for (var i = 0; i < 256; ++i) {
	  byteToHex[i] = (i + 0x100).toString(16).substr(1);
	}

	function bytesToUuid(buf, offset) {
	  var i = offset || 0;
	  var bth = byteToHex;
	  // join used to fix memory issue caused by concatenation: https://bugs.chromium.org/p/v8/issues/detail?id=3175#c4
	  return ([
	    bth[buf[i++]], bth[buf[i++]],
	    bth[buf[i++]], bth[buf[i++]], '-',
	    bth[buf[i++]], bth[buf[i++]], '-',
	    bth[buf[i++]], bth[buf[i++]], '-',
	    bth[buf[i++]], bth[buf[i++]], '-',
	    bth[buf[i++]], bth[buf[i++]],
	    bth[buf[i++]], bth[buf[i++]],
	    bth[buf[i++]], bth[buf[i++]]
	  ]).join('');
	}

	module.exports = bytesToUuid;


/***/ }),
/* 134 */
/***/ (function(module, exports, __webpack_require__) {

	var rng = __webpack_require__(132);
	var bytesToUuid = __webpack_require__(133);

	function v4(options, buf, offset) {
	  var i = buf && offset || 0;

	  if (typeof(options) == 'string') {
	    buf = options === 'binary' ? new Array(16) : null;
	    options = null;
	  }
	  options = options || {};

	  var rnds = options.random || (options.rng || rng)();

	  // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`
	  rnds[6] = (rnds[6] & 0x0f) | 0x40;
	  rnds[8] = (rnds[8] & 0x3f) | 0x80;

	  // Copy bytes to buffer, if provided
	  if (buf) {
	    for (var ii = 0; ii < 16; ++ii) {
	      buf[i + ii] = rnds[ii];
	    }
	  }

	  return buf || bytesToUuid(rnds);
	}

	module.exports = v4;


/***/ }),
/* 135 */
/***/ (function(module, exports) {

	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	// (C) 2007-2018 GoodData Corporation
	exports.REG_URI_OBJ = /\/gdc\/md\/(\S+)\/obj\/\d+/;
	exports.isUri = function (identifier) { return exports.REG_URI_OBJ.test(identifier); };
	exports.areUris = function (identifiers) { return identifiers.every(exports.isUri); };


/***/ }),
/* 136 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	// (C) 2007-2019 GoodData Corporation
	var __assign = (this && this.__assign) || function () {
	    __assign = Object.assign || function(t) {
	        for (var s, i = 1, n = arguments.length; i < n; i++) {
	            s = arguments[i];
	            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
	                t[p] = s[p];
	        }
	        return t;
	    };
	    return __assign.apply(this, arguments);
	};
	var __importDefault = (this && this.__importDefault) || function (mod) {
	    return (mod && mod.__esModule) ? mod : { "default": mod };
	};
	Object.defineProperty(exports, "__esModule", { value: true });
	var cloneDeep_1 = __importDefault(__webpack_require__(4));
	var typings_1 = __webpack_require__(137);
	function convertElementsArray(arr, isText) {
	    return isText ? { values: arr } : { uris: arr };
	}
	function convertPositiveAttributeFilter(filter) {
	    var oldFilter = filter.positiveAttributeFilter;
	    return {
	        positiveAttributeFilter: {
	            displayForm: oldFilter.displayForm,
	            in: convertElementsArray(oldFilter.in, oldFilter.textFilter),
	        },
	    };
	}
	function convertNegativeAttributeFilter(filter) {
	    var oldFilter = filter.negativeAttributeFilter;
	    return {
	        negativeAttributeFilter: {
	            displayForm: oldFilter.displayForm,
	            notIn: convertElementsArray(oldFilter.notIn, oldFilter.textFilter),
	        },
	    };
	}
	function convertFilter(filter) {
	    if (typings_1.AFM.isPositiveAttributeFilter(filter)) {
	        return convertPositiveAttributeFilter(filter);
	    }
	    else if (typings_1.AFM.isNegativeAttributeFilter(filter)) {
	        return convertNegativeAttributeFilter(filter);
	    }
	    return filter;
	}
	exports.convertFilter = convertFilter;
	function convertMeasureFilter(filter) {
	    if (typings_1.AFM.isPositiveAttributeFilter(filter)) {
	        return convertPositiveAttributeFilter(filter);
	    }
	    else if (typings_1.AFM.isNegativeAttributeFilter(filter)) {
	        return convertNegativeAttributeFilter(filter);
	    }
	    return filter;
	}
	function convertFilters(filters) {
	    return filters !== undefined ? filters.map(convertFilter) : filters;
	}
	function convertMeasureFilters(filters) {
	    return filters !== undefined ? filters.map(convertMeasureFilter) : filters;
	}
	function convertMeasure(measure) {
	    if (typings_1.AFM.isSimpleMeasureDefinition(measure.definition)) {
	        var simpleMeasure = measure.definition.measure;
	        var filters = convertMeasureFilters(simpleMeasure.filters);
	        var filtersProp = filters ? { filters: filters } : {};
	        return __assign({}, measure, { definition: {
	                measure: __assign({}, simpleMeasure, filtersProp),
	            } });
	    }
	    return measure;
	}
	function convertMeasures(measures) {
	    return measures !== undefined ? measures.map(convertMeasure) : measures;
	}
	/**
	 * Converts 'client-land' AFM to one that will be sent to backend.
	 *
	 * @param afm afm to convert
	 * @returns new instance of ExecuteAFM.IAfm structure
	 */
	function convertAfm(afm) {
	    if (afm === undefined) {
	        return {};
	    }
	    var executeAFM = __assign({}, afm, { measures: convertMeasures(afm.measures), filters: convertFilters(afm.filters) });
	    return cloneDeep_1.default(executeAFM);
	}
	exports.convertAfm = convertAfm;
	function convertExecution(execution) {
	    return {
	        execution: {
	            afm: convertAfm(execution.execution.afm),
	            resultSpec: execution.execution.resultSpec,
	        },
	    };
	}
	/**
	 * Converts 'client-land' AFM to JSON payload acceptable by REST API.
	 *
	 * @param execution execution to send to API
	 */
	function convertExecutionToJson(execution) {
	    return JSON.stringify(convertExecution(execution));
	}
	exports.convertExecutionToJson = convertExecutionToJson;


/***/ }),
/* 137 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	// (C) 2007-2020 GoodData Corporation
	function __export(m) {
	    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
	}
	exports.__esModule = true;
	__export(__webpack_require__(138));
	__export(__webpack_require__(139));
	__export(__webpack_require__(140));
	__export(__webpack_require__(141));
	__export(__webpack_require__(142));
	__export(__webpack_require__(143));
	__export(__webpack_require__(144));
	__export(__webpack_require__(145));
	__export(__webpack_require__(146));
	//# sourceMappingURL=index.js.map

/***/ }),
/* 138 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	exports.__esModule = true;
	// (C) 2007-2020 GoodData Corporation
	var isEmpty = __webpack_require__(117);
	/**
	 * Types defined here are client-side representation of the AFM. This representation MAY differ from the
	 * physical representation of the AFM accepted by the REST API.
	 *
	 * The intended use is that client code uses exclusively types defined in this namespace. Functions or methods
	 * that communicate with executeAfm REST API endpoint MUST transform this AFM to a structure acceptable by
	 * the backend.
	 *
	 * >>> Note for developers: when you modify these structures, be sure to update gooddata-js execute-afm.convert.ts
	 * with conversion of the new/updated construct to ExecuteAFM types accepted by backend.
	 *
	 * @see ./ExecuteAFM
	 */
	var AFM;
	(function (AFM) {
	    function isObjectUriQualifier(qualifier) {
	        return !isEmpty(qualifier) && qualifier.uri !== undefined;
	    }
	    AFM.isObjectUriQualifier = isObjectUriQualifier;
	    function isObjIdentifierQualifier(qualifier) {
	        return !isEmpty(qualifier) && qualifier.identifier !== undefined;
	    }
	    AFM.isObjIdentifierQualifier = isObjIdentifierQualifier;
	    function isSimpleMeasureDefinition(definition) {
	        return !isEmpty(definition) && definition.measure !== undefined;
	    }
	    AFM.isSimpleMeasureDefinition = isSimpleMeasureDefinition;
	    function isArithmeticMeasureDefinition(definition) {
	        return !isEmpty(definition) && definition.arithmeticMeasure !== undefined;
	    }
	    AFM.isArithmeticMeasureDefinition = isArithmeticMeasureDefinition;
	    function isPopMeasureDefinition(definition) {
	        return !isEmpty(definition) && definition.popMeasure !== undefined;
	    }
	    AFM.isPopMeasureDefinition = isPopMeasureDefinition;
	    function isPreviousPeriodMeasureDefinition(definition) {
	        return !isEmpty(definition)
	            && definition.previousPeriodMeasure !== undefined;
	    }
	    AFM.isPreviousPeriodMeasureDefinition = isPreviousPeriodMeasureDefinition;
	    function isAttributeSortItem(sortItem) {
	        return !isEmpty(sortItem) && sortItem.attributeSortItem !== undefined;
	    }
	    AFM.isAttributeSortItem = isAttributeSortItem;
	    function isMeasureSortItem(sortItem) {
	        return !isEmpty(sortItem) && sortItem.measureSortItem !== undefined;
	    }
	    AFM.isMeasureSortItem = isMeasureSortItem;
	    function isMeasureLocatorItem(locator) {
	        return !isEmpty(locator) && locator.measureLocatorItem !== undefined;
	    }
	    AFM.isMeasureLocatorItem = isMeasureLocatorItem;
	    function isDateFilter(filter) {
	        return !isEmpty(filter) && (isRelativeDateFilter(filter) || isAbsoluteDateFilter(filter));
	    }
	    AFM.isDateFilter = isDateFilter;
	    function isRelativeDateFilter(filter) {
	        return !isEmpty(filter) && filter.relativeDateFilter !== undefined;
	    }
	    AFM.isRelativeDateFilter = isRelativeDateFilter;
	    function isAbsoluteDateFilter(filter) {
	        return !isEmpty(filter) && filter.absoluteDateFilter !== undefined;
	    }
	    AFM.isAbsoluteDateFilter = isAbsoluteDateFilter;
	    function isAttributeFilter(filter) {
	        return !isEmpty(filter) && (isPositiveAttributeFilter(filter) || isNegativeAttributeFilter(filter));
	    }
	    AFM.isAttributeFilter = isAttributeFilter;
	    function isPositiveAttributeFilter(filter) {
	        return !isEmpty(filter) && filter.positiveAttributeFilter !== undefined;
	    }
	    AFM.isPositiveAttributeFilter = isPositiveAttributeFilter;
	    function isNegativeAttributeFilter(filter) {
	        return !isEmpty(filter) && filter.negativeAttributeFilter !== undefined;
	    }
	    AFM.isNegativeAttributeFilter = isNegativeAttributeFilter;
	    function isMeasureValueFilter(filter) {
	        return !isEmpty(filter) && filter.measureValueFilter !== undefined;
	    }
	    AFM.isMeasureValueFilter = isMeasureValueFilter;
	    function isExpressionFilter(filter) {
	        return !isEmpty(filter) && filter.value !== undefined;
	    }
	    AFM.isExpressionFilter = isExpressionFilter;
	})(AFM = exports.AFM || (exports.AFM = {}));
	//# sourceMappingURL=AFM.js.map

/***/ }),
/* 139 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	exports.__esModule = true;
	// (C) 2020 GoodData Corporation
	var isEmpty = __webpack_require__(117);
	var isArray = __webpack_require__(44);
	/**
	 * Types defined here exactly match types accepted by the executeAfm resource.
	 *
	 * >>> Note for developers: when you modify these structures, be sure to update gooddata-js execute-afm.convert.ts
	 * with conversion from AFM types to the new/updated construct.
	 *
	 * Types currently map executeAfm version 3.
	 */
	var ExecuteAFM;
	(function (ExecuteAFM) {
	    function isObjectUriQualifier(qualifier) {
	        return !isEmpty(qualifier) && qualifier.uri !== undefined;
	    }
	    ExecuteAFM.isObjectUriQualifier = isObjectUriQualifier;
	    function isObjIdentifierQualifier(qualifier) {
	        return !isEmpty(qualifier) && qualifier.identifier !== undefined;
	    }
	    ExecuteAFM.isObjIdentifierQualifier = isObjIdentifierQualifier;
	    function isSimpleMeasureDefinition(definition) {
	        return !isEmpty(definition) && definition.measure !== undefined;
	    }
	    ExecuteAFM.isSimpleMeasureDefinition = isSimpleMeasureDefinition;
	    function isArithmeticMeasureDefinition(definition) {
	        return !isEmpty(definition)
	            && definition.arithmeticMeasure !== undefined;
	    }
	    ExecuteAFM.isArithmeticMeasureDefinition = isArithmeticMeasureDefinition;
	    function isPopMeasureDefinition(definition) {
	        return !isEmpty(definition) && definition.popMeasure !== undefined;
	    }
	    ExecuteAFM.isPopMeasureDefinition = isPopMeasureDefinition;
	    function isPreviousPeriodMeasureDefinition(definition) {
	        return !isEmpty(definition)
	            && definition.previousPeriodMeasure !== undefined;
	    }
	    ExecuteAFM.isPreviousPeriodMeasureDefinition = isPreviousPeriodMeasureDefinition;
	    function isAttributeSortItem(sortItem) {
	        return !isEmpty(sortItem) && sortItem.attributeSortItem !== undefined;
	    }
	    ExecuteAFM.isAttributeSortItem = isAttributeSortItem;
	    function isMeasureSortItem(sortItem) {
	        return !isEmpty(sortItem) && sortItem.measureSortItem !== undefined;
	    }
	    ExecuteAFM.isMeasureSortItem = isMeasureSortItem;
	    function isMeasureLocatorItem(locator) {
	        return !isEmpty(locator)
	            && locator.measureLocatorItem !== undefined;
	    }
	    ExecuteAFM.isMeasureLocatorItem = isMeasureLocatorItem;
	    function isDateFilter(filter) {
	        return !isEmpty(filter) && (isRelativeDateFilter(filter) || isAbsoluteDateFilter(filter));
	    }
	    ExecuteAFM.isDateFilter = isDateFilter;
	    function isRelativeDateFilter(filter) {
	        return !isEmpty(filter) && filter.relativeDateFilter !== undefined;
	    }
	    ExecuteAFM.isRelativeDateFilter = isRelativeDateFilter;
	    function isAbsoluteDateFilter(filter) {
	        return !isEmpty(filter) && filter.absoluteDateFilter !== undefined;
	    }
	    ExecuteAFM.isAbsoluteDateFilter = isAbsoluteDateFilter;
	    function isAttributeFilter(filter) {
	        return !isEmpty(filter) && (isPositiveAttributeFilter(filter) || isNegativeAttributeFilter(filter));
	    }
	    ExecuteAFM.isAttributeFilter = isAttributeFilter;
	    function isPositiveAttributeFilter(filter) {
	        return !isEmpty(filter)
	            && filter.positiveAttributeFilter !== undefined;
	    }
	    ExecuteAFM.isPositiveAttributeFilter = isPositiveAttributeFilter;
	    function isNegativeAttributeFilter(filter) {
	        return !isEmpty(filter)
	            && filter.negativeAttributeFilter !== undefined;
	    }
	    ExecuteAFM.isNegativeAttributeFilter = isNegativeAttributeFilter;
	    function isMeasureValueFilter(filter) {
	        return !isEmpty(filter)
	            && filter.measureValueFilter !== undefined;
	    }
	    ExecuteAFM.isMeasureValueFilter = isMeasureValueFilter;
	    function isExpressionFilter(filter) {
	        return !isEmpty(filter) && filter.value !== undefined;
	    }
	    ExecuteAFM.isExpressionFilter = isExpressionFilter;
	    function isAttributeElementsArray(attributeElements) {
	        return attributeElements !== undefined && attributeElements instanceof Array;
	    }
	    ExecuteAFM.isAttributeElementsArray = isAttributeElementsArray;
	    function isAttributeElementsByRef(attributeElements) {
	        return !isEmpty(attributeElements)
	            && attributeElements.uris !== undefined;
	    }
	    ExecuteAFM.isAttributeElementsByRef = isAttributeElementsByRef;
	    function isAttributeElementsByValue(attributeElements) {
	        return !isEmpty(attributeElements)
	            && isArray(attributeElements.values);
	    }
	    ExecuteAFM.isAttributeElementsByValue = isAttributeElementsByValue;
	})(ExecuteAFM = exports.ExecuteAFM || (exports.ExecuteAFM = {}));
	//# sourceMappingURL=ExecuteAFM.js.map

/***/ }),
/* 140 */
/***/ (function(module, exports) {

	"use strict";
	exports.__esModule = true;
	// (C) 2007-2018 GoodData Corporation
	var Execution;
	(function (Execution) {
	    function isAttributeHeaderItem(header) {
	        return header.attributeHeaderItem !== undefined;
	    }
	    Execution.isAttributeHeaderItem = isAttributeHeaderItem;
	    function isMeasureHeaderItem(header) {
	        return header.measureHeaderItem !== undefined;
	    }
	    Execution.isMeasureHeaderItem = isMeasureHeaderItem;
	    function isTotalHeaderItem(header) {
	        return header.totalHeaderItem !== undefined;
	    }
	    Execution.isTotalHeaderItem = isTotalHeaderItem;
	    function isAttributeHeader(header) {
	        return header.attributeHeader !== undefined;
	    }
	    Execution.isAttributeHeader = isAttributeHeader;
	    function isMeasureGroupHeader(header) {
	        return header.measureGroupHeader !== undefined;
	    }
	    Execution.isMeasureGroupHeader = isMeasureGroupHeader;
	})(Execution = exports.Execution || (exports.Execution = {}));
	//# sourceMappingURL=Execution.js.map

/***/ }),
/* 141 */
/***/ (function(module, exports) {

	"use strict";
	exports.__esModule = true;
	var ExtendedDateFilters;
	(function (ExtendedDateFilters) {
	    ExtendedDateFilters.isAllTimeDateFilter = function (option) {
	        return option ? option.type === 'allTime' : false;
	    };
	    ExtendedDateFilters.isAbsoluteDateFilterForm = function (option) {
	        return option ? option.type === 'absoluteForm' : false;
	    };
	    ExtendedDateFilters.isAbsoluteDateFilterPreset = function (option) {
	        return option ? option.type === 'absolutePreset' : false;
	    };
	    ExtendedDateFilters.isAbsoluteDateFilterOption = function (option) {
	        return ExtendedDateFilters.isAbsoluteDateFilterForm(option) || ExtendedDateFilters.isAbsoluteDateFilterPreset(option);
	    };
	    ExtendedDateFilters.isRelativeDateFilterForm = function (option) {
	        return option ? option.type === 'relativeForm' : false;
	    };
	    ExtendedDateFilters.isRelativeDateFilterPreset = function (option) {
	        return option ? option.type === 'relativePreset' : false;
	    };
	    ExtendedDateFilters.isRelativeDateFilterOption = function (option) {
	        return ExtendedDateFilters.isRelativeDateFilterForm(option) || ExtendedDateFilters.isRelativeDateFilterPreset(option);
	    };
	})(ExtendedDateFilters = exports.ExtendedDateFilters || (exports.ExtendedDateFilters = {}));
	//# sourceMappingURL=ExtendedDateFilters.js.map

/***/ }),
/* 142 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	exports.__esModule = true;
	// (C) 2019 GoodData Corporation
	var AFM_1 = __webpack_require__(138);
	var VisualizationObject_1 = __webpack_require__(143);
	/**
	 * This namespace implements types that are used as inputs to various visualization components.
	 *
	 * At the moment these most of the types are mere aliases to types in VisualizationObject, AFM, or unions
	 * to different types. There is one notable exception: the measure & (simple) measure definition, this type
	 * is redefined here to allow simple measure filters be defined as text filters; this is not possible with the
	 * standard visualization object.
	 */
	var VisualizationInput;
	(function (VisualizationInput) {
	    function isMeasure(obj) {
	        return VisualizationObject_1.VisualizationObject.isMeasure(obj);
	    }
	    VisualizationInput.isMeasure = isMeasure;
	    function isMeasureDefinition(obj) {
	        return VisualizationObject_1.VisualizationObject.isMeasureDefinition(obj);
	    }
	    VisualizationInput.isMeasureDefinition = isMeasureDefinition;
	    function isArithmeticMeasureDefinition(obj) {
	        return VisualizationObject_1.VisualizationObject.isArithmeticMeasureDefinition(obj);
	    }
	    VisualizationInput.isArithmeticMeasureDefinition = isArithmeticMeasureDefinition;
	    function isPopMeasureDefinition(obj) {
	        return VisualizationObject_1.VisualizationObject.isPopMeasureDefinition(obj);
	    }
	    VisualizationInput.isPopMeasureDefinition = isPopMeasureDefinition;
	    function isPreviousPeriodMeasureDefinition(obj) {
	        return VisualizationObject_1.VisualizationObject.isPreviousPeriodMeasureDefinition(obj);
	    }
	    VisualizationInput.isPreviousPeriodMeasureDefinition = isPreviousPeriodMeasureDefinition;
	    function isAttribute(obj) {
	        return VisualizationObject_1.VisualizationObject.isAttribute(obj);
	    }
	    VisualizationInput.isAttribute = isAttribute;
	    function isPositiveAttributeFilter(obj) {
	        return AFM_1.AFM.isPositiveAttributeFilter(obj);
	    }
	    VisualizationInput.isPositiveAttributeFilter = isPositiveAttributeFilter;
	    function isNegativeAttributeFilter(obj) {
	        return AFM_1.AFM.isNegativeAttributeFilter(obj);
	    }
	    VisualizationInput.isNegativeAttributeFilter = isNegativeAttributeFilter;
	    function isAbsoluteDateFilter(obj) {
	        return VisualizationObject_1.VisualizationObject.isAbsoluteDateFilter(obj);
	    }
	    VisualizationInput.isAbsoluteDateFilter = isAbsoluteDateFilter;
	    function isRelativeDateFilter(obj) {
	        return VisualizationObject_1.VisualizationObject.isRelativeDateFilter(obj);
	    }
	    VisualizationInput.isRelativeDateFilter = isRelativeDateFilter;
	    function isMeasureValueFilter(obj) {
	        return VisualizationObject_1.VisualizationObject.isMeasureValueFilter(obj);
	    }
	    VisualizationInput.isMeasureValueFilter = isMeasureValueFilter;
	    function isSort(obj) {
	        return AFM_1.AFM.isAttributeSortItem(obj) || AFM_1.AFM.isMeasureSortItem(obj);
	    }
	    VisualizationInput.isSort = isSort;
	})(VisualizationInput = exports.VisualizationInput || (exports.VisualizationInput = {}));
	//# sourceMappingURL=VisualizationInput.js.map

/***/ }),
/* 143 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	exports.__esModule = true;
	var isEmpty = __webpack_require__(117);
	var VisualizationObject;
	(function (VisualizationObject) {
	    function isMeasure(bucketItem) {
	        return !isEmpty(bucketItem) && bucketItem.measure !== undefined;
	    }
	    VisualizationObject.isMeasure = isMeasure;
	    function isVisualizationAttribute(bucketItem) {
	        return !isEmpty(bucketItem) && bucketItem.visualizationAttribute !== undefined;
	    }
	    VisualizationObject.isVisualizationAttribute = isVisualizationAttribute;
	    function isMeasureDefinition(definition) {
	        return !isEmpty(definition) && definition.measureDefinition !== undefined;
	    }
	    VisualizationObject.isMeasureDefinition = isMeasureDefinition;
	    function isArithmeticMeasureDefinition(definition) {
	        return !isEmpty(definition) && definition.arithmeticMeasure !== undefined;
	    }
	    VisualizationObject.isArithmeticMeasureDefinition = isArithmeticMeasureDefinition;
	    function isPopMeasureDefinition(definition) {
	        return !isEmpty(definition) && definition.popMeasureDefinition !== undefined;
	    }
	    VisualizationObject.isPopMeasureDefinition = isPopMeasureDefinition;
	    function isPreviousPeriodMeasureDefinition(definition) {
	        return !isEmpty(definition)
	            && definition.previousPeriodMeasure !== undefined;
	    }
	    VisualizationObject.isPreviousPeriodMeasureDefinition = isPreviousPeriodMeasureDefinition;
	    function isAttributeFilter(filter) {
	        return !isEmpty(filter) && (filter.positiveAttributeFilter !== undefined
	            || filter.negativeAttributeFilter !== undefined);
	    }
	    VisualizationObject.isAttributeFilter = isAttributeFilter;
	    function isDateFilter(filter) {
	        return !isEmpty(filter) && (filter.absoluteDateFilter !== undefined
	            || filter.relativeDateFilter !== undefined);
	    }
	    VisualizationObject.isDateFilter = isDateFilter;
	    function isPositiveAttributeFilter(filter) {
	        return !isEmpty(filter)
	            && filter.positiveAttributeFilter !== undefined;
	    }
	    VisualizationObject.isPositiveAttributeFilter = isPositiveAttributeFilter;
	    function isMeasureValueFilter(filter) {
	        return !isEmpty(filter)
	            && filter.measureValueFilter !== undefined;
	    }
	    VisualizationObject.isMeasureValueFilter = isMeasureValueFilter;
	    function isAbsoluteDateFilter(filter) {
	        return !isEmpty(filter) && filter.absoluteDateFilter !== undefined;
	    }
	    VisualizationObject.isAbsoluteDateFilter = isAbsoluteDateFilter;
	    function isRelativeDateFilter(filter) {
	        return !isEmpty(filter) && filter.relativeDateFilter !== undefined;
	    }
	    VisualizationObject.isRelativeDateFilter = isRelativeDateFilter;
	    function isAttribute(bucketItem) {
	        return !isEmpty(bucketItem) && bucketItem.visualizationAttribute !== undefined;
	    }
	    VisualizationObject.isAttribute = isAttribute;
	    function isLocalIdentifierQualifier(objectQualifier) {
	        return (!isEmpty(objectQualifier) &&
	            objectQualifier.localIdentifier !== undefined);
	    }
	    VisualizationObject.isLocalIdentifierQualifier = isLocalIdentifierQualifier;
	    function isComparisonCondition(condition) {
	        return !isEmpty(condition) && condition.comparison !== undefined;
	    }
	    VisualizationObject.isComparisonCondition = isComparisonCondition;
	    function isRangeCondition(condition) {
	        return !isEmpty(condition) && condition.range !== undefined;
	    }
	    VisualizationObject.isRangeCondition = isRangeCondition;
	})(VisualizationObject = exports.VisualizationObject || (exports.VisualizationObject = {}));
	//# sourceMappingURL=VisualizationObject.js.map

/***/ }),
/* 144 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	// (C) 2020 GoodData Corporation
	exports.__esModule = true;
	var AFM_1 = __webpack_require__(138);
	/**
	 * List of products using post events
	 */
	var GdcProductName;
	(function (GdcProductName) {
	    /**
	     * AD product name
	     */
	    GdcProductName["ANALYTICAL_DESIGNER"] = "analyticalDesigner";
	    /**
	     * KD product name
	     */
	    GdcProductName["KPI_DASHBOARD"] = "dashboard";
	})(GdcProductName = exports.GdcProductName || (exports.GdcProductName = {}));
	/**
	 * Common event types in application
	 */
	var GdcEventType;
	(function (GdcEventType) {
	    /**
	     * Event to notify outer application that the command is invalid or have errors while processing
	     */
	    GdcEventType["AppCommandFailed"] = "appCommandFailed";
	})(GdcEventType = exports.GdcEventType || (exports.GdcEventType = {}));
	var GdcErrorType;
	(function (GdcErrorType) {
	    /**
	     * The posted command is not recognized.
	     */
	    GdcErrorType["InvalidCommand"] = "error:invalidCommand";
	    /**
	     * Argument specified in the command body is invalid; it has failed the syntactical
	     * or semantic validation.
	     */
	    GdcErrorType["InvalidArgument"] = "error:invalidArgument";
	    /**
	     * Command was posted when the app is not in a state to process the command. For instance:
	     *
	     * - trying to do save/save-as on new, empty insight
	     * - trying to do save/save-as on insight that is in error
	     * - trying to do undo when there is no step-back available
	     * - trying to do redo when there is no step-forward available
	     */
	    GdcErrorType["InvalidState"] = "error:invalidState";
	    /**
	     * The Unexpected Happened.
	     */
	    GdcErrorType["RuntimeError"] = "error:runtime";
	})(GdcErrorType = exports.GdcErrorType || (exports.GdcErrorType = {}));
	/**
	 * Type-guard checking whether an object is an instance of {@link CommandFailedData}
	 *
	 * @param obj - object to test
	 */
	function isCommandFailedData(obj) {
	    return getEventType(obj) === GdcEventType.AppCommandFailed;
	}
	exports.isCommandFailedData = isCommandFailedData;
	/**
	 * Get event type of event from event data
	 * @param obj the event data object
	 */
	function getEventType(obj) {
	    var _a = (obj || {}).gdc, _b = (_a === void 0 ? {} : _a).event, _c = (_b === void 0 ? {} : _b).name, name = _c === void 0 ? '' : _c;
	    return name;
	}
	exports.getEventType = getEventType;
	var EmbeddedGdc;
	(function (EmbeddedGdc) {
	    EmbeddedGdc.isDateFilter = AFM_1.AFM.isDateFilter;
	    EmbeddedGdc.isRelativeDateFilter = AFM_1.AFM.isRelativeDateFilter;
	    EmbeddedGdc.isAbsoluteDateFilter = AFM_1.AFM.isAbsoluteDateFilter;
	    EmbeddedGdc.isAttributeFilter = AFM_1.AFM.isAttributeFilter;
	    EmbeddedGdc.isPositiveAttributeFilter = AFM_1.AFM.isPositiveAttributeFilter;
	    EmbeddedGdc.isNegativeAttributeFilter = AFM_1.AFM.isNegativeAttributeFilter;
	    EmbeddedGdc.isObjIdentifierQualifier = AFM_1.AFM.isObjIdentifierQualifier;
	    EmbeddedGdc.isObjectUriQualifier = AFM_1.AFM.isObjectUriQualifier;
	})(EmbeddedGdc = exports.EmbeddedGdc || (exports.EmbeddedGdc = {}));
	//# sourceMappingURL=common.js.map

/***/ }),
/* 145 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	exports.__esModule = true;
	// (C) 2020 GoodData Corporation
	var common_1 = __webpack_require__(144);
	/**
	 * All interface, types, type-guard related to embedded analyticalDesigner
	 */
	var EmbeddedAnalyticalDesigner;
	(function (EmbeddedAnalyticalDesigner) {
	    /**
	     * All AD command Types
	     */
	    var GdcAdCommandType;
	    (function (GdcAdCommandType) {
	        /**
	         * The command set drillable items
	         */
	        GdcAdCommandType["DrillableItems"] = "drillableItems";
	        /**
	         * The command open an insight
	         */
	        GdcAdCommandType["OpenInsight"] = "openInsight";
	        /**
	         * The command save an insight
	         */
	        GdcAdCommandType["Save"] = "saveInsight";
	        /**
	         * The command save the insight as a new one
	         */
	        GdcAdCommandType["SaveAs"] = "saveAsInsight";
	        /**
	         * The command export an insight
	         */
	        GdcAdCommandType["Export"] = "exportInsight";
	        /**
	         * The command reset the insight editor to empty state
	         */
	        GdcAdCommandType["Clear"] = "clear";
	        /**
	         * The command undo to previous state
	         */
	        GdcAdCommandType["Undo"] = "undo";
	        /**
	         * The command redo to next state
	         */
	        GdcAdCommandType["Redo"] = "redo";
	        /**
	         * The command to add or update filter context
	         */
	        GdcAdCommandType["SetFilterContext"] = "setFilterContext";
	        /**
	         * The command to remove filter item from current filter context
	         */
	        GdcAdCommandType["RemoveFilterContext"] = "removeFilterContext";
	    })(GdcAdCommandType = EmbeddedAnalyticalDesigner.GdcAdCommandType || (EmbeddedAnalyticalDesigner.GdcAdCommandType = {}));
	    /**
	     * All event types on AD
	     */
	    var GdcAdEventType;
	    (function (GdcAdEventType) {
	        /**
	         * Type represent that Insight is saved
	         */
	        GdcAdEventType["ListeningForDrillableItems"] = "listeningForDrillableItems";
	        /**
	         * Type represent that a new insight is initialized
	         */
	        GdcAdEventType["NewInsightInitialized"] = "newInsightInitialized";
	        /**
	         * Type represent that the insight is opened
	         */
	        GdcAdEventType["InsightOpened"] = "insightOpened";
	        /**
	         * Type represent that the insight editor is cleared
	         */
	        GdcAdEventType["ClearFinished"] = "clearFinished";
	        /**
	         * Type represent that the insight is saved
	         *
	         * Note: use `visualizationSaved` because of backward compatibility
	         * @see visualizationSaved event on https://help.gooddata.com
	         */
	        GdcAdEventType["InsightSaved"] = "visualizationSaved";
	        /**
	         * Type represent that the undo action is finished
	         */
	        GdcAdEventType["UndoFinished"] = "undoFinished";
	        /**
	         * Type represent that the redo action is finished
	         */
	        GdcAdEventType["RedoFinished"] = "redoFinished";
	        /**
	         * Type represent that the export action is finished
	         */
	        GdcAdEventType["ExportFinished"] = "exportInsightFinished";
	        /**
	         * Type that drill performed
	         */
	        GdcAdEventType["Drill"] = "drill";
	        /**
	         * Type represent that the filter context is changed
	         */
	        GdcAdEventType["FilterContextChanged"] = "filterContextChanged";
	        /**
	         * Type represent that the set filter context action is finished
	         */
	        GdcAdEventType["SetFilterContextFinished"] = "setFilterContextFinished";
	        /**
	         * Type represent that the remove filter context action is finished
	         */
	        GdcAdEventType["RemoveFilterContextFinished"] = "removeFilterContextFinished";
	    })(GdcAdEventType = EmbeddedAnalyticalDesigner.GdcAdEventType || (EmbeddedAnalyticalDesigner.GdcAdEventType = {}));
	    /**
	     * Type-guard checking whether an object is an instance of {@link AdCommandFailedData}
	     *
	     * @param obj - object to test
	     */
	    function isAdCommandFailedData(obj) {
	        return common_1.isCommandFailedData(obj);
	    }
	    EmbeddedAnalyticalDesigner.isAdCommandFailedData = isAdCommandFailedData;
	    /**
	     * Type-guard checking whether an object is an instance of {@link DrillableItemsCommandData}
	     *
	     * @param obj - object to test
	     */
	    function isDrillableItemsCommandData(obj) {
	        return common_1.getEventType(obj) === GdcAdCommandType.DrillableItems;
	    }
	    EmbeddedAnalyticalDesigner.isDrillableItemsCommandData = isDrillableItemsCommandData;
	    /**
	     * Type-guard checking whether an object is an instance of {@link OpenInsightCommandData}
	     *
	     * @param obj - object to test
	     */
	    function isOpenInsightCommandData(obj) {
	        return common_1.getEventType(obj) === GdcAdCommandType.OpenInsight;
	    }
	    EmbeddedAnalyticalDesigner.isOpenInsightCommandData = isOpenInsightCommandData;
	    /**
	     * Type-guard checking whether an object is an instance of {@link ClearCommandData}
	     *
	     * @param obj - object to test
	     */
	    function isClearCommandData(obj) {
	        return common_1.getEventType(obj) === GdcAdCommandType.Clear;
	    }
	    EmbeddedAnalyticalDesigner.isClearCommandData = isClearCommandData;
	    /**
	     * Type-guard checking whether an object is an instance of {@link SaveInsightCommandData}
	     *
	     * @param obj - object to test
	     */
	    function isSaveInsightCommandData(obj) {
	        return common_1.getEventType(obj) === GdcAdCommandType.Save;
	    }
	    EmbeddedAnalyticalDesigner.isSaveInsightCommandData = isSaveInsightCommandData;
	    /**
	     * Type-guard checking whether an object is an instance of {@link SaveAsInsightCommandData}
	     *
	     * @param obj - object to test
	     */
	    function isSaveAsInsightCommandData(obj) {
	        return common_1.getEventType(obj) === GdcAdCommandType.SaveAs;
	    }
	    EmbeddedAnalyticalDesigner.isSaveAsInsightCommandData = isSaveAsInsightCommandData;
	    /**
	     * Type-guard checking whether an object is an instance of {@link ExportInsightCommandData}
	     *
	     * @param obj - object to test
	     */
	    function isExportInsightCommandData(obj) {
	        return common_1.getEventType(obj) === GdcAdCommandType.Export;
	    }
	    EmbeddedAnalyticalDesigner.isExportInsightCommandData = isExportInsightCommandData;
	    /**
	     * Type-guard checking whether an object is an instance of {@link UndoCommandData}
	     *
	     * @param obj - object to test
	     */
	    function isUndoCommandData(obj) {
	        return common_1.getEventType(obj) === GdcAdCommandType.Undo;
	    }
	    EmbeddedAnalyticalDesigner.isUndoCommandData = isUndoCommandData;
	    /**
	     * Type-guard checking whether an object is an instance of {@link RedoCommandData}
	     *
	     * @param obj - object to test
	     */
	    function isRedoCommandData(obj) {
	        return common_1.getEventType(obj) === GdcAdCommandType.Redo;
	    }
	    EmbeddedAnalyticalDesigner.isRedoCommandData = isRedoCommandData;
	    /**
	     * Type-guard checking whether an object is an instance of {@link SetFilterContextCommand}
	     *
	     * @param obj - object to test
	     */
	    function isSetFilterContextCommandData(obj) {
	        return common_1.getEventType(obj) === GdcAdCommandType.SetFilterContext;
	    }
	    EmbeddedAnalyticalDesigner.isSetFilterContextCommandData = isSetFilterContextCommandData;
	    /**
	     * Type-guard checking whether an object is an instance of {@link RemoveFilterContextCommand}
	     *
	     * @param obj - object to test
	     */
	    function isRemoveFilterContextCommandData(obj) {
	        return common_1.getEventType(obj) === GdcAdCommandType.RemoveFilterContext;
	    }
	    EmbeddedAnalyticalDesigner.isRemoveFilterContextCommandData = isRemoveFilterContextCommandData;
	    /**
	     * Type-guard checking whether an object is an instance of {@link NewInsightInitializedData}
	     *
	     * @param obj - object to test
	     */
	    function isNewInsightInitializedData(obj) {
	        return common_1.getEventType(obj) === GdcAdEventType.NewInsightInitialized;
	    }
	    EmbeddedAnalyticalDesigner.isNewInsightInitializedData = isNewInsightInitializedData;
	    /**
	     * Type-guard checking whether an object is an instance of {@link InsightOpenedData}
	     *
	     * @param obj - object to test
	     */
	    function isInsightOpenedData(obj) {
	        return common_1.getEventType(obj) === GdcAdEventType.InsightOpened;
	    }
	    EmbeddedAnalyticalDesigner.isInsightOpenedData = isInsightOpenedData;
	    /**
	     * Type-guard checking whether an object is an instance of {@link ClearFinishedData}
	     *
	     * @param obj - object to test
	     */
	    function isClearFinishedData(obj) {
	        return common_1.getEventType(obj) === GdcAdEventType.ClearFinished;
	    }
	    EmbeddedAnalyticalDesigner.isClearFinishedData = isClearFinishedData;
	    /**
	     * Type-guard checking whether an object is an instance of {@link InsightSavedData}
	     *
	     * @param obj - object to test
	     */
	    function isInsightSavedData(obj) {
	        return common_1.getEventType(obj) === GdcAdEventType.InsightSaved;
	    }
	    EmbeddedAnalyticalDesigner.isInsightSavedData = isInsightSavedData;
	    /**
	     * Type-guard checking whether an object is an instance of {@link ExportFinishedData}
	     *
	     * @param obj - object to test
	     */
	    function isExportFinishedData(obj) {
	        return common_1.getEventType(obj) === GdcAdEventType.ExportFinished;
	    }
	    EmbeddedAnalyticalDesigner.isExportFinishedData = isExportFinishedData;
	    /**
	     * Type-guard checking whether an object is an instance of {@link UndoFinishedData}
	     *
	     * @param obj - object to test
	     */
	    function isUndoFinishedData(obj) {
	        return common_1.getEventType(obj) === GdcAdEventType.UndoFinished;
	    }
	    EmbeddedAnalyticalDesigner.isUndoFinishedData = isUndoFinishedData;
	    /**
	     * Type-guard checking whether an object is an instance of {@link RedoFinishedData}
	     *
	     * @param obj - object to test
	     */
	    function isRedoFinishedData(obj) {
	        return common_1.getEventType(obj) === GdcAdEventType.RedoFinished;
	    }
	    EmbeddedAnalyticalDesigner.isRedoFinishedData = isRedoFinishedData;
	})(EmbeddedAnalyticalDesigner = exports.EmbeddedAnalyticalDesigner || (exports.EmbeddedAnalyticalDesigner = {}));
	//# sourceMappingURL=ad.js.map

/***/ }),
/* 146 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	exports.__esModule = true;
	// (C) 2020 GoodData Corporation
	var common_1 = __webpack_require__(144);
	var EmbeddedKpiDashboard;
	(function (EmbeddedKpiDashboard) {
	    /**
	     * All KD command Types.
	     */
	    var GdcKdCommandType;
	    (function (GdcKdCommandType) {
	        /**
	         * The command save a dashboard.
	         */
	        GdcKdCommandType["Save"] = "saveDashboard";
	        /**
	         * The command cancel editing dashboard.
	         */
	        GdcKdCommandType["CancelEdit"] = "cancelEdit";
	        /**
	         * The command delete existed dashboard.
	         */
	        GdcKdCommandType["Delete"] = "deleteDashboard";
	        /**
	         * The command edit a dashboard.
	         */
	        GdcKdCommandType["SwitchToEdit"] = "switchToEdit";
	        /**
	         * The command set drillable items.
	         */
	        GdcKdCommandType["DrillableItems"] = "drillableItems";
	        /**
	         * The command set size of dashboard.
	         */
	        GdcKdCommandType["SetSize"] = "setSize";
	        /**
	         * The command add widget to dashboard.
	         */
	        GdcKdCommandType["AddWidget"] = "addWidget";
	        /**
	         * The command add filter to dashboard.
	         */
	        GdcKdCommandType["AddFilter"] = "addFilter";
	        /**
	         * The command export a dashboard.
	         */
	        GdcKdCommandType["ExportToPdf"] = "exportToPdf";
	        /**
	         * The command to add or update filter context
	         */
	        GdcKdCommandType["SetFilterContext"] = "setFilterContext";
	        /**
	         * The command to remove filter item from current filter context
	         */
	        GdcKdCommandType["RemoveFilterContext"] = "removeFilterContext";
	    })(GdcKdCommandType = EmbeddedKpiDashboard.GdcKdCommandType || (EmbeddedKpiDashboard.GdcKdCommandType = {}));
	    /**
	     * All KD event types.
	     */
	    var GdcKdEventType;
	    (function (GdcKdEventType) {
	        /**
	         * Type represent that the dashboard listening for drilling event.
	         */
	        GdcKdEventType["ListeningForDrillableItems"] = "listeningForDrillableItems";
	        /**
	         * Type represent that the embedded content starts loading.
	         */
	        GdcKdEventType["LoadingStarted"] = "loadingStarted";
	        /**
	         * Type represent that The user does not have permissions to view or edit the content.
	         */
	        GdcKdEventType["NoPermissions"] = "noPermissions";
	        /**
	         * Type represent that an operation increasing the height of the hosting iframe is performed.
	         */
	        GdcKdEventType["Resized"] = "resized";
	        /**
	         * Type represent that the dashboard has been created and saved.
	         */
	        GdcKdEventType["DashboardCreated"] = "dashboardCreated";
	        /**
	         * Type represent that the content is fully loaded,
	         * and the user has permissions to access the dashboard.
	         */
	        GdcKdEventType["DashboardLoaded"] = "loaded";
	        /**
	         * Type represent that the existing dashboard has been updated.
	         */
	        GdcKdEventType["DashboardUpdated"] = "dashboardUpdated";
	        /**
	         * Type represent that the dashboard is saved.
	         *
	         */
	        GdcKdEventType["DashboardSaved"] = "dashboardSaved";
	        /**
	         * Type represent that the dashboard is deleted.
	         *
	         */
	        GdcKdEventType["DashboardDeleted"] = "dashboardDeleted";
	        /**
	         * Type represent that the user cancels the creation of the dashboard.
	         */
	        GdcKdEventType["DashboardCreationCanceled"] = "dashboardCreationCanceled";
	        /**
	         * Type represent that the dashboard is switched to edit mode.
	         */
	        GdcKdEventType["SwitchedToEdit"] = "switchedToEdit";
	        /**
	         * Type represent that the dashboard is switched to view mode.
	         */
	        GdcKdEventType["SwitchedToView"] = "switchedToView";
	        /**
	         * Type represent that the platform is down.
	         */
	        GdcKdEventType["Platform"] = "platform";
	        /**
	         * Type represent that the widget is added to dashboard.
	         *
	         */
	        GdcKdEventType["WidgetAdded"] = "widgetAdded";
	        /**
	         * Type represent that the filter is added to dashboard.
	         *
	         */
	        GdcKdEventType["FilterAdded"] = "filterAdded";
	        /**
	         * Type represent that the export action is finished.
	         */
	        GdcKdEventType["ExportedToPdf"] = "exportedToPdf";
	        /**
	         * Type represent that the drill performed
	         */
	        GdcKdEventType["Drill"] = "drill";
	        /**
	         * Type represent that the filter context is changed
	         */
	        GdcKdEventType["FilterContextChanged"] = "filterContextChanged";
	        /**
	         * Type represent that the set filter context action is finished
	         */
	        GdcKdEventType["SetFilterContextFinished"] = "setFilterContextFinished";
	        /**
	         * Type represent that the remove filter context action is finished
	         */
	        GdcKdEventType["RemoveFilterContextFinished"] = "removeFilterContextFinished";
	        /**
	         * Type that represents started drill to URL. The event does not contain an URL. The event can be used as
	         * notification to display a loading indicator as the URL resolving takes some time. The URL is sent in
	         * DrillToUrlResolved event which is posted after the URL is resolved. The event also contains an ID that can
	         * be matched with ID in subsequently posted DrillToUrlResolved event.
	         */
	        GdcKdEventType["DrillToUrlStarted"] = "drillToUrlStarted";
	        /**
	         * Type that represents resolved drill to URL. The event is sent after DrillToUrlStarted event was posted and
	         * it contains the resolved URL. The event also contains an ID which can be matched with ID from
	         * DrillToUrlStarted event.
	         */
	        GdcKdEventType["DrillToUrlResolved"] = "drillToUrlResolved";
	    })(GdcKdEventType = EmbeddedKpiDashboard.GdcKdEventType || (EmbeddedKpiDashboard.GdcKdEventType = {}));
	    /**
	     * Type-guard checking whether object is an instance of {@link SaveDashboardCommandData}.
	     *
	     * @param obj - object to test
	     */
	    function isSaveDashboardCommandData(obj) {
	        return common_1.getEventType(obj) === GdcKdCommandType.Save;
	    }
	    EmbeddedKpiDashboard.isSaveDashboardCommandData = isSaveDashboardCommandData;
	    /**
	     * Type-guard checking whether object is an instance of {@link CancelEditData}.
	     *
	     * @param obj - object to test
	     */
	    function isCancelEditCommandData(obj) {
	        return common_1.getEventType(obj) === GdcKdCommandType.CancelEdit;
	    }
	    EmbeddedKpiDashboard.isCancelEditCommandData = isCancelEditCommandData;
	    /**
	     * Type-guard checking whether object is an instance of {@link SwitchToEditCommandData}.
	     *
	     * @param obj - object to test
	     */
	    function isSwitchToEditCommandData(obj) {
	        return common_1.getEventType(obj) === GdcKdCommandType.SwitchToEdit;
	    }
	    EmbeddedKpiDashboard.isSwitchToEditCommandData = isSwitchToEditCommandData;
	    /**
	     * Type-guard checking whether object is an instance of {@link DrillableItemsCommandData}.
	     *
	     * @param obj - object to test
	     */
	    function isDrillableItemsCommandData(obj) {
	        return common_1.getEventType(obj) === GdcKdCommandType.DrillableItems;
	    }
	    EmbeddedKpiDashboard.isDrillableItemsCommandData = isDrillableItemsCommandData;
	    /**
	     * Type-guard checking whether object is an instance of {@link SetSizeCommandData}.
	     *
	     * @param obj - object to test
	     */
	    function isSetSizeCommandData(obj) {
	        return common_1.getEventType(obj) === GdcKdCommandType.SetSize;
	    }
	    EmbeddedKpiDashboard.isSetSizeCommandData = isSetSizeCommandData;
	    /**
	     * Type-guard checking whether an object is an instance of {@link SetFilterContextCommand}
	     *
	     * @param obj - object to test
	     */
	    function isSetFilterContextCommandData(obj) {
	        return common_1.getEventType(obj) === GdcKdCommandType.SetFilterContext;
	    }
	    EmbeddedKpiDashboard.isSetFilterContextCommandData = isSetFilterContextCommandData;
	    /**
	     * Type-guard checking whether an object is an instance of {@link RemoveFilterContextCommand}
	     *
	     * @param obj - object to test
	     */
	    function isRemoveFilterContextCommandData(obj) {
	        return common_1.getEventType(obj) === GdcKdCommandType.RemoveFilterContext;
	    }
	    EmbeddedKpiDashboard.isRemoveFilterContextCommandData = isRemoveFilterContextCommandData;
	    /**
	     * Type-guard checking whether object is an instance of {@link IdentifierInsightRef}.
	     *
	     * @param obj - object to test
	     */
	    function isIdentifierInsight(obj) {
	        return obj.identifier;
	    }
	    EmbeddedKpiDashboard.isIdentifierInsight = isIdentifierInsight;
	    /**
	     * Type-guard checking whether object is an instance of {@link UriInsightRef}.
	     *
	     * @param obj - object to test
	     */
	    function isUriInsight(obj) {
	        return obj.uri;
	    }
	    EmbeddedKpiDashboard.isUriInsight = isUriInsight;
	    /**
	     * Type-guard checking whether object is an instance of {@link AddWidgetCommandData}.
	     *
	     * @param obj - object to test
	     */
	    function isAddWidgetCommandData(obj) {
	        return common_1.getEventType(obj) === GdcKdCommandType.AddWidget;
	    }
	    EmbeddedKpiDashboard.isAddWidgetCommandData = isAddWidgetCommandData;
	    /**
	     * Type-guard checking whether object is an instance of {@link AddFilterCommandData}.
	     *
	     * @param obj - object to test
	     */
	    function isAddFilterCommandData(obj) {
	        return common_1.getEventType(obj) === GdcKdCommandType.AddFilter;
	    }
	    EmbeddedKpiDashboard.isAddFilterCommandData = isAddFilterCommandData;
	    /**
	     * Type-guard checking whether object is an instance of {@link ExportToPdfCommandData}.
	     *
	     * @param obj - object to test
	     */
	    function isExportToPdfCommandData(obj) {
	        return common_1.getEventType(obj) === GdcKdCommandType.ExportToPdf;
	    }
	    EmbeddedKpiDashboard.isExportToPdfCommandData = isExportToPdfCommandData;
	})(EmbeddedKpiDashboard = exports.EmbeddedKpiDashboard || (exports.EmbeddedKpiDashboard = {}));
	//# sourceMappingURL=kd.js.map

/***/ }),
/* 147 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	// (C) 2007-2018 GoodData Corporation
	var experimental_executions_1 = __webpack_require__(148);
	var attributesMapLoader_1 = __webpack_require__(182);
	var execute_afm_1 = __webpack_require__(184);
	/**
	 * Execution endpoints
	 *
	 * @module execution
	 * @class execution
	 *
	 */
	var ExecutionModule = /** @class */ (function () {
	    function ExecutionModule(xhr, md) {
	        this.executeAfmModule = new execute_afm_1.ExecuteAfmModule(xhr);
	        this.executeAfm = this.executeAfmModule.executeAfm.bind(this.executeAfmModule);
	        this.getExecutionResponse = this.executeAfmModule.getExecutionResponse.bind(this.executeAfmModule);
	        this._executeVisualization = this.executeAfmModule._executeVisualization.bind(this.executeAfmModule);
	        this._getVisExecutionResponse = this.executeAfmModule._getVisExecutionResponse.bind(this.executeAfmModule);
	        this.getPartialExecutionResult = this.executeAfmModule.getPartialExecutionResult.bind(this.executeAfmModule);
	        this.getExecutionResult = this.executeAfmModule.getExecutionResult.bind(this.executeAfmModule);
	        this.xhr = xhr;
	        this.md = md;
	    }
	    ExecutionModule.prototype.getData = function (projectId, columns, executionConfiguration, settings) {
	        if (executionConfiguration === void 0) { executionConfiguration = {}; }
	        if (settings === void 0) { settings = {}; }
	        return this.getExperimentalExecutionsModule().getData(projectId, columns, executionConfiguration, settings);
	    };
	    ExecutionModule.prototype.mdToExecutionDefinitionsAndColumns = function (projectId, mdObj, options) {
	        if (options === void 0) { options = {}; }
	        return this.getExperimentalExecutionsModule().mdToExecutionDefinitionsAndColumns(projectId, mdObj, options);
	    };
	    ExecutionModule.prototype.getExperimentalExecutionsModule = function () {
	        var loaderModule = new attributesMapLoader_1.AttributesMapLoaderModule(this.md);
	        return new experimental_executions_1.ExperimentalExecutionsModule(this.xhr, loaderModule.loadAttributesMap.bind(loaderModule));
	    };
	    return ExecutionModule;
	}());
	exports.ExecutionModule = ExecutionModule;


/***/ }),
/* 148 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {"use strict";
	var __assign = (this && this.__assign) || function () {
	    __assign = Object.assign || function(t) {
	        for (var s, i = 1, n = arguments.length; i < n; i++) {
	            s = arguments[i];
	            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
	                t[p] = s[p];
	        }
	        return t;
	    };
	    return __assign.apply(this, arguments);
	};
	var __importDefault = (this && this.__importDefault) || function (mod) {
	    return (mod && mod.__esModule) ? mod : { "default": mod };
	};
	Object.defineProperty(exports, "__esModule", { value: true });
	// (C) 2007-2020 GoodData Corporation
	var md5_1 = __importDefault(__webpack_require__(150));
	var invariant_1 = __importDefault(__webpack_require__(154));
	var cloneDeep_1 = __importDefault(__webpack_require__(4));
	var compact_1 = __importDefault(__webpack_require__(155));
	var filter_1 = __importDefault(__webpack_require__(156));
	var first_1 = __importDefault(__webpack_require__(157));
	var find_1 = __importDefault(__webpack_require__(159));
	var map_1 = __importDefault(__webpack_require__(164));
	var merge_1 = __importDefault(__webpack_require__(70));
	var every_1 = __importDefault(__webpack_require__(165));
	var get_1 = __importDefault(__webpack_require__(89));
	var isEmpty_1 = __importDefault(__webpack_require__(117));
	var negate_1 = __importDefault(__webpack_require__(166));
	var partial_1 = __importDefault(__webpack_require__(167));
	var flatten_1 = __importDefault(__webpack_require__(104));
	var set_1 = __importDefault(__webpack_require__(53));
	var rules_1 = __webpack_require__(172);
	var definitions_1 = __webpack_require__(173);
	var attributesMapLoader_1 = __webpack_require__(182);
	var visualizationObjectHelper_1 = __webpack_require__(183);
	var notEmpty = negate_1.default(isEmpty_1.default);
	function findHeaderForMappingFn(mapping, header) {
	    return ((mapping.element === header.id || mapping.element === header.uri) && header.measureIndex === undefined);
	}
	function wrapMeasureIndexesFromMappings(metricMappings, headers) {
	    if (metricMappings) {
	        metricMappings.forEach(function (mapping) {
	            var header = find_1.default(headers, partial_1.default(findHeaderForMappingFn, mapping));
	            if (header) {
	                header.measureIndex = mapping.measureIndex;
	                header.isPoP = mapping.isPoP;
	            }
	        });
	    }
	    return headers;
	}
	var emptyResult = {
	    extendedTabularDataResult: {
	        values: [],
	        warnings: [],
	    },
	};
	var MAX_TITLE_LENGTH = 1000;
	function getMetricTitle(suffix, title) {
	    var maxLength = MAX_TITLE_LENGTH - suffix.length;
	    if (title && title.length > maxLength) {
	        if (title[title.length - 1] === ")") {
	            return title.substring(0, maxLength - 2) + "\u2026)" + suffix;
	        }
	        return title.substring(0, maxLength - 1) + "\u2026" + suffix;
	    }
	    return "" + title + suffix;
	}
	var getBaseMetricTitle = partial_1.default(getMetricTitle, "");
	var CONTRIBUTION_METRIC_FORMAT = "#,##0.00%";
	function getPoPDefinition(measure) {
	    return get_1.default(measure, ["definition", "popMeasureDefinition"], {});
	}
	function getAggregation(measure) {
	    return get_1.default(visualizationObjectHelper_1.getDefinition(measure), "aggregation", "").toLowerCase();
	}
	function isEmptyFilter(metricFilter) {
	    if (get_1.default(metricFilter, "positiveAttributeFilter")) {
	        return isEmpty_1.default(get_1.default(metricFilter, ["positiveAttributeFilter", "in"]));
	    }
	    if (get_1.default(metricFilter, "negativeAttributeFilter")) {
	        return isEmpty_1.default(get_1.default(metricFilter, ["negativeAttributeFilter", "notIn"]));
	    }
	    if (get_1.default(metricFilter, "absoluteDateFilter")) {
	        return (get_1.default(metricFilter, ["absoluteDateFilter", "from"]) === undefined &&
	            get_1.default(metricFilter, ["absoluteDateFilter", "to"]) === undefined);
	    }
	    return (get_1.default(metricFilter, ["relativeDateFilter", "from"]) === undefined &&
	        get_1.default(metricFilter, ["relativeDateFilter", "to"]) === undefined);
	}
	function allFiltersEmpty(item) {
	    return every_1.default(map_1.default(visualizationObjectHelper_1.getMeasureFilters(item), function (f) { return isEmptyFilter(f); }));
	}
	function isDerived(measure) {
	    var aggregation = getAggregation(measure);
	    return aggregation !== "" || !allFiltersEmpty(measure);
	}
	function getAttrTypeFromMap(dfUri, attributesMap) {
	    return get_1.default(get_1.default(attributesMap, [dfUri], {}), ["attribute", "content", "type"]);
	}
	function getAttrUriFromMap(dfUri, attributesMap) {
	    return get_1.default(get_1.default(attributesMap, [dfUri], {}), ["attribute", "meta", "uri"]);
	}
	function isAttrFilterNegative(attributeFilter) {
	    return get_1.default(attributeFilter, "negativeAttributeFilter") !== undefined;
	}
	function getAttrFilterElements(attributeFilter) {
	    var isNegative = isAttrFilterNegative(attributeFilter);
	    var pathToElements = isNegative
	        ? ["negativeAttributeFilter", "notIn"]
	        : ["positiveAttributeFilter", "in"];
	    return get_1.default(attributeFilter, pathToElements, []);
	}
	function getAttrFilterExpression(measureFilter, attributesMap) {
	    var isNegative = get_1.default(measureFilter, "negativeAttributeFilter", false);
	    var detailPath = isNegative ? "negativeAttributeFilter" : "positiveAttributeFilter";
	    var attributeUri = getAttrUriFromMap(get_1.default(measureFilter, [detailPath, "displayForm", "uri"]), attributesMap);
	    var elements = getAttrFilterElements(measureFilter);
	    if (isEmpty_1.default(elements)) {
	        return null;
	    }
	    var elementsForQuery = map_1.default(elements, function (e) { return "[" + e + "]"; });
	    var negative = isNegative ? "NOT " : "";
	    return "[" + attributeUri + "] " + negative + "IN (" + elementsForQuery.join(",") + ")";
	}
	function getDateFilterExpression() {
	    // measure date filter was never supported
	    return "";
	}
	function getFilterExpression(attributesMap, measureFilter) {
	    if (visualizationObjectHelper_1.isAttributeMeasureFilter(measureFilter)) {
	        return getAttrFilterExpression(measureFilter, attributesMap);
	    }
	    return getDateFilterExpression();
	}
	function getGeneratedMetricExpression(item, attributesMap) {
	    var aggregation = getAggregation(item).toUpperCase();
	    var objectUri = get_1.default(visualizationObjectHelper_1.getDefinition(item), "item.uri");
	    var where = filter_1.default(map_1.default(visualizationObjectHelper_1.getMeasureFilters(item), partial_1.default(getFilterExpression, attributesMap)), function (e) { return !!e; });
	    return "SELECT " + (aggregation ? aggregation + "([" + objectUri + "])" : "[" + objectUri + "]") + (notEmpty(where) ? " WHERE " + where.join(" AND ") : "");
	}
	function getPercentMetricExpression(category, attributesMap, measure) {
	    var metricExpressionWithoutFilters = "SELECT [" + get_1.default(visualizationObjectHelper_1.getDefinition(measure), "item.uri") + "]";
	    if (isDerived(measure)) {
	        metricExpressionWithoutFilters = getGeneratedMetricExpression(set_1.default(cloneDeep_1.default(measure), ["definition", "measureDefinition", "filters"], []), attributesMap);
	    }
	    var attributeUri = getAttrUriFromMap(get_1.default(category, "displayForm.uri"), attributesMap);
	    var whereFilters = filter_1.default(map_1.default(visualizationObjectHelper_1.getMeasureFilters(measure), partial_1.default(getFilterExpression, attributesMap)), function (e) { return !!e; });
	    var whereExpression = notEmpty(whereFilters) ? " WHERE " + whereFilters.join(" AND ") : "";
	    // tslint:disable-next-line:max-line-length
	    return "SELECT (" + metricExpressionWithoutFilters + whereExpression + ") / (" + metricExpressionWithoutFilters + " BY ALL [" + attributeUri + "]" + whereExpression + ")";
	}
	function getPoPExpression(attributeUri, metricExpression) {
	    return "SELECT " + metricExpression + " FOR PREVIOUS ([" + attributeUri + "])";
	}
	function getGeneratedMetricHash(title, format, expression) {
	    return md5_1.default(expression + "#" + title + "#" + format);
	}
	function getMeasureType(measure) {
	    var aggregation = getAggregation(measure);
	    if (aggregation === "") {
	        return "metric";
	    }
	    else if (aggregation === "count") {
	        return "attribute";
	    }
	    return "fact";
	}
	function getGeneratedMetricIdentifier(item, aggregation, expressionCreator, hasher, attributesMap) {
	    var _a = get_1.default(visualizationObjectHelper_1.getDefinition(item), "item.uri", "").split("/"), prjId = _a[3], id = _a[5];
	    var identifier = prjId + "_" + id;
	    var hash = hasher(expressionCreator(item, attributesMap));
	    var hasNoFilters = isEmpty_1.default(visualizationObjectHelper_1.getMeasureFilters(item));
	    var type = getMeasureType(item);
	    var prefix = hasNoFilters || allFiltersEmpty(item) ? "" : "_filtered";
	    return type + "_" + identifier + ".generated." + hash + prefix + "_" + aggregation;
	}
	function isDateAttribute(attribute, attributesMap) {
	    if (attributesMap === void 0) { attributesMap = {}; }
	    return getAttrTypeFromMap(get_1.default(attribute, ["displayForm", "uri"]), attributesMap) !== undefined;
	}
	function getMeasureSorting(measure, mdObj) {
	    var sorting = get_1.default(mdObj, ["properties", "sortItems"], []);
	    var matchedSorting = sorting.find(function (sortItem) {
	        var measureSortItem = get_1.default(sortItem, ["measureSortItem"]);
	        if (measureSortItem) {
	            // only one item now, we support only 2d data
	            var identifier = get_1.default(measureSortItem, [
	                "locators",
	                0,
	                "measureLocatorItem",
	                "measureIdentifier",
	            ]);
	            return identifier === get_1.default(measure, "localIdentifier");
	        }
	        return false;
	    });
	    if (matchedSorting) {
	        return get_1.default(matchedSorting, ["measureSortItem", "direction"], null);
	    }
	    return null;
	}
	function getCategorySorting(category, mdObj) {
	    var sorting = get_1.default(mdObj, ["properties", "sortItems"], []);
	    var matchedSorting = sorting.find(function (sortItem) {
	        var attributeSortItem = get_1.default(sortItem, ["attributeSortItem"]);
	        if (attributeSortItem) {
	            var identifier = get_1.default(attributeSortItem, ["attributeIdentifier"]);
	            return identifier === get_1.default(category, "localIdentifier");
	        }
	        return false;
	    });
	    if (matchedSorting) {
	        return get_1.default(matchedSorting, ["attributeSortItem", "direction"], null);
	    }
	    return null;
	}
	var createPureMetric = function (measure, mdObj, measureIndex) { return ({
	    element: get_1.default(measure, ["definition", "measureDefinition", "item", "uri"]),
	    sort: getMeasureSorting(measure, mdObj),
	    meta: { measureIndex: measureIndex },
	}); };
	function createDerivedMetric(measure, mdObj, measureIndex, attributesMap) {
	    var format = measure.format;
	    var sort = getMeasureSorting(measure, mdObj);
	    var title = getBaseMetricTitle(measure.title);
	    var hasher = partial_1.default(getGeneratedMetricHash, title, format);
	    var aggregation = getAggregation(measure);
	    var element = getGeneratedMetricIdentifier(measure, aggregation.length ? aggregation : "base", getGeneratedMetricExpression, hasher, attributesMap);
	    var definition = {
	        metricDefinition: {
	            identifier: element,
	            expression: getGeneratedMetricExpression(measure, attributesMap),
	            title: title,
	            format: format,
	        },
	    };
	    return {
	        element: element,
	        definition: definition,
	        sort: sort,
	        meta: {
	            measureIndex: measureIndex,
	        },
	    };
	}
	function createContributionMetric(measure, mdObj, measureIndex, attributesMap) {
	    var attribute = first_1.default(visualizationObjectHelper_1.getAttributes(mdObj));
	    var getMetricExpression = partial_1.default(getPercentMetricExpression, attribute, attributesMap);
	    var title = getBaseMetricTitle(get_1.default(measure, "title"));
	    var hasher = partial_1.default(getGeneratedMetricHash, title, CONTRIBUTION_METRIC_FORMAT);
	    var identifier = getGeneratedMetricIdentifier(measure, "percent", getMetricExpression, hasher, attributesMap);
	    return {
	        element: identifier,
	        definition: {
	            metricDefinition: {
	                identifier: identifier,
	                expression: getMetricExpression(measure),
	                title: title,
	                format: CONTRIBUTION_METRIC_FORMAT,
	            },
	        },
	        sort: getMeasureSorting(measure, mdObj),
	        meta: {
	            measureIndex: measureIndex,
	        },
	    };
	}
	function getOriginalMeasureForPoP(popMeasure, mdObj) {
	    return visualizationObjectHelper_1.getMeasures(mdObj).find(function (measure) {
	        return get_1.default(measure, "localIdentifier") === get_1.default(getPoPDefinition(popMeasure), ["measureIdentifier"]);
	    });
	}
	function createPoPMetric(popMeasure, mdObj, measureIndex, attributesMap) {
	    var title = getBaseMetricTitle(get_1.default(popMeasure, "title"));
	    var format = get_1.default(popMeasure, "format");
	    var hasher = partial_1.default(getGeneratedMetricHash, title, format);
	    var attributeUri = get_1.default(popMeasure, "definition.popMeasureDefinition.popAttribute.uri");
	    var originalMeasure = getOriginalMeasureForPoP(popMeasure, mdObj);
	    var originalMeasureExpression = "[" + get_1.default(visualizationObjectHelper_1.getDefinition(originalMeasure), ["item", "uri"]) + "]";
	    var metricExpression = getPoPExpression(attributeUri, originalMeasureExpression);
	    if (isDerived(originalMeasure)) {
	        var generated = createDerivedMetric(originalMeasure, mdObj, measureIndex, attributesMap);
	        var generatedMeasureExpression = "(" + get_1.default(generated, [
	            "definition",
	            "metricDefinition",
	            "expression",
	        ]) + ")";
	        metricExpression = getPoPExpression(attributeUri, generatedMeasureExpression);
	    }
	    var identifier = getGeneratedMetricIdentifier(originalMeasure, "pop", function () { return metricExpression; }, hasher, attributesMap);
	    return {
	        element: identifier,
	        definition: {
	            metricDefinition: {
	                identifier: identifier,
	                expression: metricExpression,
	                title: title,
	                format: format,
	            },
	        },
	        sort: getMeasureSorting(popMeasure, mdObj),
	        meta: {
	            measureIndex: measureIndex,
	            isPoP: true,
	        },
	    };
	}
	function createContributionPoPMetric(popMeasure, mdObj, measureIndex, attributesMap) {
	    var attributeUri = get_1.default(popMeasure, ["definition", "popMeasureDefinition", "popAttribute", "uri"]);
	    var originalMeasure = getOriginalMeasureForPoP(popMeasure, mdObj);
	    var generated = createContributionMetric(originalMeasure, mdObj, measureIndex, attributesMap);
	    var title = getBaseMetricTitle(get_1.default(popMeasure, "title"));
	    var format = CONTRIBUTION_METRIC_FORMAT;
	    var hasher = partial_1.default(getGeneratedMetricHash, title, format);
	    var generatedMeasureExpression = "(" + get_1.default(generated, [
	        "definition",
	        "metricDefinition",
	        "expression",
	    ]) + ")";
	    var metricExpression = getPoPExpression(attributeUri, generatedMeasureExpression);
	    var identifier = getGeneratedMetricIdentifier(originalMeasure, "pop", function () { return metricExpression; }, hasher, attributesMap);
	    return {
	        element: identifier,
	        definition: {
	            metricDefinition: {
	                identifier: identifier,
	                expression: metricExpression,
	                title: title,
	                format: format,
	            },
	        },
	        sort: getMeasureSorting(),
	        meta: {
	            measureIndex: measureIndex,
	            isPoP: true,
	        },
	    };
	}
	function categoryToElement(attributesMap, mdObj, category) {
	    var element = getAttrUriFromMap(get_1.default(category, ["displayForm", "uri"]), attributesMap);
	    return {
	        element: element,
	        sort: getCategorySorting(category, mdObj),
	    };
	}
	function isPoP(_a) {
	    var definition = _a.definition;
	    return get_1.default(definition, "popMeasureDefinition") !== undefined;
	}
	function isContribution(_a) {
	    var definition = _a.definition;
	    return get_1.default(definition, ["measureDefinition", "computeRatio"]);
	}
	function isPoPContribution(popMeasure, mdObj) {
	    if (isPoP(popMeasure)) {
	        var originalMeasure = getOriginalMeasureForPoP(popMeasure, mdObj);
	        return isContribution(originalMeasure);
	    }
	    return false;
	}
	function isCalculatedMeasure(_a) {
	    var definition = _a.definition;
	    return get_1.default(definition, ["measureDefinition", "aggregation"]) === undefined;
	}
	var rules = new rules_1.Rules();
	rules.addRule([isPoPContribution], createContributionPoPMetric);
	rules.addRule([isPoP], createPoPMetric);
	rules.addRule([isContribution], createContributionMetric);
	rules.addRule([isDerived], createDerivedMetric);
	rules.addRule([isCalculatedMeasure], createPureMetric);
	function getMetricFactory(measure, mdObj) {
	    var factory = rules.match(measure, mdObj);
	    invariant_1.default(factory, "Unknown factory for: " + measure);
	    return factory;
	}
	function getExecutionDefinitionsAndColumns(mdObj, options, attributesMap) {
	    var measures = visualizationObjectHelper_1.getMeasures(mdObj);
	    var attributes = visualizationObjectHelper_1.getAttributes(mdObj);
	    var metrics = flatten_1.default(map_1.default(measures, function (measure, index) {
	        return getMetricFactory(measure, mdObj)(measure, mdObj, index, attributesMap);
	    }));
	    if (options.removeDateItems) {
	        attributes = filter_1.default(attributes, function (attribute) { return !isDateAttribute(attribute, attributesMap); });
	    }
	    attributes = map_1.default(attributes, partial_1.default(categoryToElement, attributesMap, mdObj));
	    var columns = compact_1.default(map_1.default(attributes.concat(metrics), "element"));
	    return {
	        columns: columns,
	        definitions: definitions_1.sortDefinitions(compact_1.default(map_1.default(metrics, "definition"))),
	    };
	}
	/**
	 * Module for execution on experimental execution resource
	 *
	 * @class execution
	 * @module execution
	 * @deprecated The module is in maintenance mode only (just the the compilation issues are being fixed when
	 *      referenced utilities and interfaces are being changed) and is not being extended when AFM executor
	 *      have new functionality added.
	 */
	var ExperimentalExecutionsModule = /** @class */ (function () {
	    function ExperimentalExecutionsModule(xhr, loadAttributesMap) {
	        this.xhr = xhr;
	        this.loadAttributesMap = loadAttributesMap;
	    }
	    /**
	     * For the given projectId it returns table structure with the given
	     * elements in column headers.
	     *
	     * @method getData
	     * @param {String} projectId - GD project identifier
	     * @param {Array} columns - An array of attribute or metric identifiers.
	     * @param {Object} executionConfiguration - Execution configuration - can contain for example
	     *                 property "where" containing query-like filters
	     *                 property "orderBy" contains array of sorted properties to order in form
	     *                      [{column: 'identifier', direction: 'asc|desc'}]
	     * @param {Object} settings - Supports additional settings accepted by the underlying
	     *                             xhr.ajax() calls
	     *
	     * @return {Object} Structure with `headers` and `rawData` keys filled with values from execution.
	     */
	    ExperimentalExecutionsModule.prototype.getData = function (projectId, columns, executionConfiguration, settings) {
	        var _this = this;
	        if (executionConfiguration === void 0) { executionConfiguration = {}; }
	        if (settings === void 0) { settings = {}; }
	        if (process.env.NODE_ENV !== "test") {
	            // tslint:disable-next-line:no-console
	            console.warn("ExperimentalExecutionsModule is deprecated and is no longer being maintained. " +
	                "Please migrate to the ExecuteAfmModule.");
	        }
	        var executedReport = {
	            isLoaded: false,
	        };
	        // Create request and result structures
	        var request = {
	            execution: { columns: columns },
	        };
	        // enrich configuration with supported properties such as
	        // where clause with query-like filters
	        ["where", "orderBy", "definitions"].forEach(function (property) {
	            if (executionConfiguration[property]) {
	                request.execution[property] = executionConfiguration[property];
	            }
	        });
	        // Execute request
	        return this.xhr
	            .post("/gdc/internal/projects/" + projectId + "/experimental/executions", __assign({}, settings, { body: JSON.stringify(request) }))
	            .then(function (r) { return r.getData(); })
	            .then(function (response) {
	            executedReport.headers = wrapMeasureIndexesFromMappings(get_1.default(executionConfiguration, "metricMappings"), get_1.default(response, ["executionResult", "headers"], []));
	            // Start polling on url returned in the executionResult for tabularData
	            return _this.loadExtendedDataResults(response.executionResult.extendedTabularDataResult, settings);
	        })
	            .then(function (r) {
	            var result = r.result, status = r.status;
	            return __assign({}, executedReport, { rawData: get_1.default(result, "extendedTabularDataResult.values", []), warnings: get_1.default(result, "extendedTabularDataResult.warnings", []), isLoaded: true, isEmpty: status === 204 });
	        });
	    };
	    ExperimentalExecutionsModule.prototype.mdToExecutionDefinitionsAndColumns = function (projectId, mdObj, options) {
	        if (options === void 0) { options = {}; }
	        var allDfUris = visualizationObjectHelper_1.getAttributesDisplayForms(mdObj);
	        var attributesMapPromise = this.getAttributesMap(options, allDfUris, projectId);
	        return attributesMapPromise.then(function (attributesMap) {
	            return getExecutionDefinitionsAndColumns(mdObj, options, attributesMap);
	        });
	    };
	    ExperimentalExecutionsModule.prototype.getAttributesMap = function (options, displayFormUris, projectId) {
	        var attributesMap = get_1.default(options, "attributesMap", {});
	        var missingUris = attributesMapLoader_1.getMissingUrisInAttributesMap(displayFormUris, attributesMap);
	        return this.loadAttributesMap(projectId, missingUris).then(function (result) {
	            return __assign({}, attributesMap, result);
	        });
	    };
	    ExperimentalExecutionsModule.prototype.loadExtendedDataResults = function (uri, settings, prevResult) {
	        var _this = this;
	        if (prevResult === void 0) { prevResult = emptyResult; }
	        return new Promise(function (resolve, reject) {
	            _this.xhr
	                .ajax(uri, settings)
	                .then(function (r) {
	                var response = r.response;
	                if (response.status === 204) {
	                    return {
	                        status: response.status,
	                        result: "",
	                    };
	                }
	                return {
	                    status: response.status,
	                    result: r.getData(),
	                };
	            })
	                .then(function (_a) {
	                var status = _a.status, result = _a.result;
	                var values = get_1.default(prevResult, "extendedTabularDataResult.values", []).concat(get_1.default(result, "extendedTabularDataResult.values", []));
	                var warnings = get_1.default(prevResult, "extendedTabularDataResult.warnings", []).concat(get_1.default(result, "extendedTabularDataResult.warnings", []));
	                var updatedResult = merge_1.default({}, prevResult, {
	                    extendedTabularDataResult: {
	                        values: values,
	                        warnings: warnings,
	                    },
	                });
	                var nextUri = get_1.default(result, "extendedTabularDataResult.paging.next");
	                if (nextUri) {
	                    resolve(_this.loadExtendedDataResults(nextUri, settings, updatedResult));
	                }
	                else {
	                    resolve({ status: status, result: updatedResult });
	                }
	            }, reject);
	        });
	    };
	    return ExperimentalExecutionsModule;
	}());
	exports.ExperimentalExecutionsModule = ExperimentalExecutionsModule;

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(149)))

/***/ }),
/* 149 */
/***/ (function(module, exports) {

	// shim for using process in browser
	var process = module.exports = {};

	// cached from whatever global is present so that test runners that stub it
	// don't break things.  But we need to wrap it in a try catch in case it is
	// wrapped in strict mode code which doesn't define any globals.  It's inside a
	// function because try/catches deoptimize in certain engines.

	var cachedSetTimeout;
	var cachedClearTimeout;

	function defaultSetTimout() {
	    throw new Error('setTimeout has not been defined');
	}
	function defaultClearTimeout () {
	    throw new Error('clearTimeout has not been defined');
	}
	(function () {
	    try {
	        if (typeof setTimeout === 'function') {
	            cachedSetTimeout = setTimeout;
	        } else {
	            cachedSetTimeout = defaultSetTimout;
	        }
	    } catch (e) {
	        cachedSetTimeout = defaultSetTimout;
	    }
	    try {
	        if (typeof clearTimeout === 'function') {
	            cachedClearTimeout = clearTimeout;
	        } else {
	            cachedClearTimeout = defaultClearTimeout;
	        }
	    } catch (e) {
	        cachedClearTimeout = defaultClearTimeout;
	    }
	} ())
	function runTimeout(fun) {
	    if (cachedSetTimeout === setTimeout) {
	        //normal enviroments in sane situations
	        return setTimeout(fun, 0);
	    }
	    // if setTimeout wasn't available but was latter defined
	    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
	        cachedSetTimeout = setTimeout;
	        return setTimeout(fun, 0);
	    }
	    try {
	        // when when somebody has screwed with setTimeout but no I.E. maddness
	        return cachedSetTimeout(fun, 0);
	    } catch(e){
	        try {
	            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
	            return cachedSetTimeout.call(null, fun, 0);
	        } catch(e){
	            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
	            return cachedSetTimeout.call(this, fun, 0);
	        }
	    }


	}
	function runClearTimeout(marker) {
	    if (cachedClearTimeout === clearTimeout) {
	        //normal enviroments in sane situations
	        return clearTimeout(marker);
	    }
	    // if clearTimeout wasn't available but was latter defined
	    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
	        cachedClearTimeout = clearTimeout;
	        return clearTimeout(marker);
	    }
	    try {
	        // when when somebody has screwed with setTimeout but no I.E. maddness
	        return cachedClearTimeout(marker);
	    } catch (e){
	        try {
	            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
	            return cachedClearTimeout.call(null, marker);
	        } catch (e){
	            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
	            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
	            return cachedClearTimeout.call(this, marker);
	        }
	    }



	}
	var queue = [];
	var draining = false;
	var currentQueue;
	var queueIndex = -1;

	function cleanUpNextTick() {
	    if (!draining || !currentQueue) {
	        return;
	    }
	    draining = false;
	    if (currentQueue.length) {
	        queue = currentQueue.concat(queue);
	    } else {
	        queueIndex = -1;
	    }
	    if (queue.length) {
	        drainQueue();
	    }
	}

	function drainQueue() {
	    if (draining) {
	        return;
	    }
	    var timeout = runTimeout(cleanUpNextTick);
	    draining = true;

	    var len = queue.length;
	    while(len) {
	        currentQueue = queue;
	        queue = [];
	        while (++queueIndex < len) {
	            if (currentQueue) {
	                currentQueue[queueIndex].run();
	            }
	        }
	        queueIndex = -1;
	        len = queue.length;
	    }
	    currentQueue = null;
	    draining = false;
	    runClearTimeout(timeout);
	}

	process.nextTick = function (fun) {
	    var args = new Array(arguments.length - 1);
	    if (arguments.length > 1) {
	        for (var i = 1; i < arguments.length; i++) {
	            args[i - 1] = arguments[i];
	        }
	    }
	    queue.push(new Item(fun, args));
	    if (queue.length === 1 && !draining) {
	        runTimeout(drainQueue);
	    }
	};

	// v8 likes predictible objects
	function Item(fun, array) {
	    this.fun = fun;
	    this.array = array;
	}
	Item.prototype.run = function () {
	    this.fun.apply(null, this.array);
	};
	process.title = 'browser';
	process.browser = true;
	process.env = {};
	process.argv = [];
	process.version = ''; // empty string to avoid regexp issues
	process.versions = {};

	function noop() {}

	process.on = noop;
	process.addListener = noop;
	process.once = noop;
	process.off = noop;
	process.removeListener = noop;
	process.removeAllListeners = noop;
	process.emit = noop;
	process.prependListener = noop;
	process.prependOnceListener = noop;

	process.listeners = function (name) { return [] }

	process.binding = function (name) {
	    throw new Error('process.binding is not supported');
	};

	process.cwd = function () { return '/' };
	process.chdir = function (dir) {
	    throw new Error('process.chdir is not supported');
	};
	process.umask = function() { return 0; };


/***/ }),
/* 150 */
/***/ (function(module, exports, __webpack_require__) {

	(function(){
	  var crypt = __webpack_require__(151),
	      utf8 = __webpack_require__(152).utf8,
	      isBuffer = __webpack_require__(153),
	      bin = __webpack_require__(152).bin,

	  // The core
	  md5 = function (message, options) {
	    // Convert to byte array
	    if (message.constructor == String)
	      if (options && options.encoding === 'binary')
	        message = bin.stringToBytes(message);
	      else
	        message = utf8.stringToBytes(message);
	    else if (isBuffer(message))
	      message = Array.prototype.slice.call(message, 0);
	    else if (!Array.isArray(message))
	      message = message.toString();
	    // else, assume byte array already

	    var m = crypt.bytesToWords(message),
	        l = message.length * 8,
	        a =  1732584193,
	        b = -271733879,
	        c = -1732584194,
	        d =  271733878;

	    // Swap endian
	    for (var i = 0; i < m.length; i++) {
	      m[i] = ((m[i] <<  8) | (m[i] >>> 24)) & 0x00FF00FF |
	             ((m[i] << 24) | (m[i] >>>  8)) & 0xFF00FF00;
	    }

	    // Padding
	    m[l >>> 5] |= 0x80 << (l % 32);
	    m[(((l + 64) >>> 9) << 4) + 14] = l;

	    // Method shortcuts
	    var FF = md5._ff,
	        GG = md5._gg,
	        HH = md5._hh,
	        II = md5._ii;

	    for (var i = 0; i < m.length; i += 16) {

	      var aa = a,
	          bb = b,
	          cc = c,
	          dd = d;

	      a = FF(a, b, c, d, m[i+ 0],  7, -680876936);
	      d = FF(d, a, b, c, m[i+ 1], 12, -389564586);
	      c = FF(c, d, a, b, m[i+ 2], 17,  606105819);
	      b = FF(b, c, d, a, m[i+ 3], 22, -1044525330);
	      a = FF(a, b, c, d, m[i+ 4],  7, -176418897);
	      d = FF(d, a, b, c, m[i+ 5], 12,  1200080426);
	      c = FF(c, d, a, b, m[i+ 6], 17, -1473231341);
	      b = FF(b, c, d, a, m[i+ 7], 22, -45705983);
	      a = FF(a, b, c, d, m[i+ 8],  7,  1770035416);
	      d = FF(d, a, b, c, m[i+ 9], 12, -1958414417);
	      c = FF(c, d, a, b, m[i+10], 17, -42063);
	      b = FF(b, c, d, a, m[i+11], 22, -1990404162);
	      a = FF(a, b, c, d, m[i+12],  7,  1804603682);
	      d = FF(d, a, b, c, m[i+13], 12, -40341101);
	      c = FF(c, d, a, b, m[i+14], 17, -1502002290);
	      b = FF(b, c, d, a, m[i+15], 22,  1236535329);

	      a = GG(a, b, c, d, m[i+ 1],  5, -165796510);
	      d = GG(d, a, b, c, m[i+ 6],  9, -1069501632);
	      c = GG(c, d, a, b, m[i+11], 14,  643717713);
	      b = GG(b, c, d, a, m[i+ 0], 20, -373897302);
	      a = GG(a, b, c, d, m[i+ 5],  5, -701558691);
	      d = GG(d, a, b, c, m[i+10],  9,  38016083);
	      c = GG(c, d, a, b, m[i+15], 14, -660478335);
	      b = GG(b, c, d, a, m[i+ 4], 20, -405537848);
	      a = GG(a, b, c, d, m[i+ 9],  5,  568446438);
	      d = GG(d, a, b, c, m[i+14],  9, -1019803690);
	      c = GG(c, d, a, b, m[i+ 3], 14, -187363961);
	      b = GG(b, c, d, a, m[i+ 8], 20,  1163531501);
	      a = GG(a, b, c, d, m[i+13],  5, -1444681467);
	      d = GG(d, a, b, c, m[i+ 2],  9, -51403784);
	      c = GG(c, d, a, b, m[i+ 7], 14,  1735328473);
	      b = GG(b, c, d, a, m[i+12], 20, -1926607734);

	      a = HH(a, b, c, d, m[i+ 5],  4, -378558);
	      d = HH(d, a, b, c, m[i+ 8], 11, -2022574463);
	      c = HH(c, d, a, b, m[i+11], 16,  1839030562);
	      b = HH(b, c, d, a, m[i+14], 23, -35309556);
	      a = HH(a, b, c, d, m[i+ 1],  4, -1530992060);
	      d = HH(d, a, b, c, m[i+ 4], 11,  1272893353);
	      c = HH(c, d, a, b, m[i+ 7], 16, -155497632);
	      b = HH(b, c, d, a, m[i+10], 23, -1094730640);
	      a = HH(a, b, c, d, m[i+13],  4,  681279174);
	      d = HH(d, a, b, c, m[i+ 0], 11, -358537222);
	      c = HH(c, d, a, b, m[i+ 3], 16, -722521979);
	      b = HH(b, c, d, a, m[i+ 6], 23,  76029189);
	      a = HH(a, b, c, d, m[i+ 9],  4, -640364487);
	      d = HH(d, a, b, c, m[i+12], 11, -421815835);
	      c = HH(c, d, a, b, m[i+15], 16,  530742520);
	      b = HH(b, c, d, a, m[i+ 2], 23, -995338651);

	      a = II(a, b, c, d, m[i+ 0],  6, -198630844);
	      d = II(d, a, b, c, m[i+ 7], 10,  1126891415);
	      c = II(c, d, a, b, m[i+14], 15, -1416354905);
	      b = II(b, c, d, a, m[i+ 5], 21, -57434055);
	      a = II(a, b, c, d, m[i+12],  6,  1700485571);
	      d = II(d, a, b, c, m[i+ 3], 10, -1894986606);
	      c = II(c, d, a, b, m[i+10], 15, -1051523);
	      b = II(b, c, d, a, m[i+ 1], 21, -2054922799);
	      a = II(a, b, c, d, m[i+ 8],  6,  1873313359);
	      d = II(d, a, b, c, m[i+15], 10, -30611744);
	      c = II(c, d, a, b, m[i+ 6], 15, -1560198380);
	      b = II(b, c, d, a, m[i+13], 21,  1309151649);
	      a = II(a, b, c, d, m[i+ 4],  6, -145523070);
	      d = II(d, a, b, c, m[i+11], 10, -1120210379);
	      c = II(c, d, a, b, m[i+ 2], 15,  718787259);
	      b = II(b, c, d, a, m[i+ 9], 21, -343485551);

	      a = (a + aa) >>> 0;
	      b = (b + bb) >>> 0;
	      c = (c + cc) >>> 0;
	      d = (d + dd) >>> 0;
	    }

	    return crypt.endian([a, b, c, d]);
	  };

	  // Auxiliary functions
	  md5._ff  = function (a, b, c, d, x, s, t) {
	    var n = a + (b & c | ~b & d) + (x >>> 0) + t;
	    return ((n << s) | (n >>> (32 - s))) + b;
	  };
	  md5._gg  = function (a, b, c, d, x, s, t) {
	    var n = a + (b & d | c & ~d) + (x >>> 0) + t;
	    return ((n << s) | (n >>> (32 - s))) + b;
	  };
	  md5._hh  = function (a, b, c, d, x, s, t) {
	    var n = a + (b ^ c ^ d) + (x >>> 0) + t;
	    return ((n << s) | (n >>> (32 - s))) + b;
	  };
	  md5._ii  = function (a, b, c, d, x, s, t) {
	    var n = a + (c ^ (b | ~d)) + (x >>> 0) + t;
	    return ((n << s) | (n >>> (32 - s))) + b;
	  };

	  // Package private blocksize
	  md5._blocksize = 16;
	  md5._digestsize = 16;

	  module.exports = function (message, options) {
	    if (message === undefined || message === null)
	      throw new Error('Illegal argument ' + message);

	    var digestbytes = crypt.wordsToBytes(md5(message, options));
	    return options && options.asBytes ? digestbytes :
	        options && options.asString ? bin.bytesToString(digestbytes) :
	        crypt.bytesToHex(digestbytes);
	  };

	})();


/***/ }),
/* 151 */
/***/ (function(module, exports) {

	(function() {
	  var base64map
	      = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/',

	  crypt = {
	    // Bit-wise rotation left
	    rotl: function(n, b) {
	      return (n << b) | (n >>> (32 - b));
	    },

	    // Bit-wise rotation right
	    rotr: function(n, b) {
	      return (n << (32 - b)) | (n >>> b);
	    },

	    // Swap big-endian to little-endian and vice versa
	    endian: function(n) {
	      // If number given, swap endian
	      if (n.constructor == Number) {
	        return crypt.rotl(n, 8) & 0x00FF00FF | crypt.rotl(n, 24) & 0xFF00FF00;
	      }

	      // Else, assume array and swap all items
	      for (var i = 0; i < n.length; i++)
	        n[i] = crypt.endian(n[i]);
	      return n;
	    },

	    // Generate an array of any length of random bytes
	    randomBytes: function(n) {
	      for (var bytes = []; n > 0; n--)
	        bytes.push(Math.floor(Math.random() * 256));
	      return bytes;
	    },

	    // Convert a byte array to big-endian 32-bit words
	    bytesToWords: function(bytes) {
	      for (var words = [], i = 0, b = 0; i < bytes.length; i++, b += 8)
	        words[b >>> 5] |= bytes[i] << (24 - b % 32);
	      return words;
	    },

	    // Convert big-endian 32-bit words to a byte array
	    wordsToBytes: function(words) {
	      for (var bytes = [], b = 0; b < words.length * 32; b += 8)
	        bytes.push((words[b >>> 5] >>> (24 - b % 32)) & 0xFF);
	      return bytes;
	    },

	    // Convert a byte array to a hex string
	    bytesToHex: function(bytes) {
	      for (var hex = [], i = 0; i < bytes.length; i++) {
	        hex.push((bytes[i] >>> 4).toString(16));
	        hex.push((bytes[i] & 0xF).toString(16));
	      }
	      return hex.join('');
	    },

	    // Convert a hex string to a byte array
	    hexToBytes: function(hex) {
	      for (var bytes = [], c = 0; c < hex.length; c += 2)
	        bytes.push(parseInt(hex.substr(c, 2), 16));
	      return bytes;
	    },

	    // Convert a byte array to a base-64 string
	    bytesToBase64: function(bytes) {
	      for (var base64 = [], i = 0; i < bytes.length; i += 3) {
	        var triplet = (bytes[i] << 16) | (bytes[i + 1] << 8) | bytes[i + 2];
	        for (var j = 0; j < 4; j++)
	          if (i * 8 + j * 6 <= bytes.length * 8)
	            base64.push(base64map.charAt((triplet >>> 6 * (3 - j)) & 0x3F));
	          else
	            base64.push('=');
	      }
	      return base64.join('');
	    },

	    // Convert a base-64 string to a byte array
	    base64ToBytes: function(base64) {
	      // Remove non-base-64 characters
	      base64 = base64.replace(/[^A-Z0-9+\/]/ig, '');

	      for (var bytes = [], i = 0, imod4 = 0; i < base64.length;
	          imod4 = ++i % 4) {
	        if (imod4 == 0) continue;
	        bytes.push(((base64map.indexOf(base64.charAt(i - 1))
	            & (Math.pow(2, -2 * imod4 + 8) - 1)) << (imod4 * 2))
	            | (base64map.indexOf(base64.charAt(i)) >>> (6 - imod4 * 2)));
	      }
	      return bytes;
	    }
	  };

	  module.exports = crypt;
	})();


/***/ }),
/* 152 */
/***/ (function(module, exports) {

	var charenc = {
	  // UTF-8 encoding
	  utf8: {
	    // Convert a string to a byte array
	    stringToBytes: function(str) {
	      return charenc.bin.stringToBytes(unescape(encodeURIComponent(str)));
	    },

	    // Convert a byte array to a string
	    bytesToString: function(bytes) {
	      return decodeURIComponent(escape(charenc.bin.bytesToString(bytes)));
	    }
	  },

	  // Binary encoding
	  bin: {
	    // Convert a string to a byte array
	    stringToBytes: function(str) {
	      for (var bytes = [], i = 0; i < str.length; i++)
	        bytes.push(str.charCodeAt(i) & 0xFF);
	      return bytes;
	    },

	    // Convert a byte array to a string
	    bytesToString: function(bytes) {
	      for (var str = [], i = 0; i < bytes.length; i++)
	        str.push(String.fromCharCode(bytes[i]));
	      return str.join('');
	    }
	  }
	};

	module.exports = charenc;


/***/ }),
/* 153 */
/***/ (function(module, exports) {

	/*!
	 * Determine if an object is a Buffer
	 *
	 * @author   Feross Aboukhadijeh <https://feross.org>
	 * @license  MIT
	 */

	// The _isBuffer check is for Safari 5-7 support, because it's missing
	// Object.prototype.constructor. Remove this eventually
	module.exports = function (obj) {
	  return obj != null && (isBuffer(obj) || isSlowBuffer(obj) || !!obj._isBuffer)
	}

	function isBuffer (obj) {
	  return !!obj.constructor && typeof obj.constructor.isBuffer === 'function' && obj.constructor.isBuffer(obj)
	}

	// For Node v0.10 support. Remove this eventually.
	function isSlowBuffer (obj) {
	  return typeof obj.readFloatLE === 'function' && typeof obj.slice === 'function' && isBuffer(obj.slice(0, 0))
	}


/***/ }),
/* 154 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 */

	'use strict';

	/**
	 * Use invariant() to assert state which your program assumes to be true.
	 *
	 * Provide sprintf-style format (only %s is supported) and arguments
	 * to provide information about what broke and what you were
	 * expecting.
	 *
	 * The invariant message will be stripped in production, but the invariant
	 * will remain to ensure logic does not differ in production.
	 */

	var invariant = function(condition, format, a, b, c, d, e, f) {
	  if (process.env.NODE_ENV !== 'production') {
	    if (format === undefined) {
	      throw new Error('invariant requires an error message argument');
	    }
	  }

	  if (!condition) {
	    var error;
	    if (format === undefined) {
	      error = new Error(
	        'Minified exception occurred; use the non-minified dev environment ' +
	        'for the full error message and additional helpful warnings.'
	      );
	    } else {
	      var args = [a, b, c, d, e, f];
	      var argIndex = 0;
	      error = new Error(
	        format.replace(/%s/g, function() { return args[argIndex++]; })
	      );
	      error.name = 'Invariant Violation';
	    }

	    error.framesToPop = 1; // we don't care about invariant's own frame
	    throw error;
	  }
	};

	module.exports = invariant;

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(149)))

/***/ }),
/* 155 */
/***/ (function(module, exports) {

	/**
	 * Creates an array with all falsey values removed. The values `false`, `null`,
	 * `0`, `""`, `undefined`, and `NaN` are falsey.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Array
	 * @param {Array} array The array to compact.
	 * @returns {Array} Returns the new array of filtered values.
	 * @example
	 *
	 * _.compact([0, 1, false, 2, '', 3]);
	 * // => [1, 2, 3]
	 */
	function compact(array) {
	  var index = -1,
	      length = array == null ? 0 : array.length,
	      resIndex = 0,
	      result = [];

	  while (++index < length) {
	    var value = array[index];
	    if (value) {
	      result[resIndex++] = value;
	    }
	  }
	  return result;
	}

	module.exports = compact;


/***/ }),
/* 156 */
/***/ (function(module, exports) {

	/**
	 * A specialized version of `_.filter` for arrays without support for
	 * iteratee shorthands.
	 *
	 * @private
	 * @param {Array} [array] The array to iterate over.
	 * @param {Function} predicate The function invoked per iteration.
	 * @returns {Array} Returns the new filtered array.
	 */
	function arrayFilter(array, predicate) {
	  var index = -1,
	      length = array == null ? 0 : array.length,
	      resIndex = 0,
	      result = [];

	  while (++index < length) {
	    var value = array[index];
	    if (predicate(value, index, array)) {
	      result[resIndex++] = value;
	    }
	  }
	  return result;
	}

	module.exports = arrayFilter;


/***/ }),
/* 157 */
/***/ (function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(158);


/***/ }),
/* 158 */
/***/ (function(module, exports) {

	/**
	 * Gets the first element of `array`.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @alias first
	 * @category Array
	 * @param {Array} array The array to query.
	 * @returns {*} Returns the first element of `array`.
	 * @example
	 *
	 * _.head([1, 2, 3]);
	 * // => 1
	 *
	 * _.head([]);
	 * // => undefined
	 */
	function head(array) {
	  return (array && array.length) ? array[0] : undefined;
	}

	module.exports = head;


/***/ }),
/* 159 */
/***/ (function(module, exports, __webpack_require__) {

	var createFind = __webpack_require__(160),
	    findIndex = __webpack_require__(162);

	/**
	 * Iterates over elements of `collection`, returning the first element
	 * `predicate` returns truthy for. The predicate is invoked with three
	 * arguments: (value, index|key, collection).
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Collection
	 * @param {Array|Object} collection The collection to inspect.
	 * @param {Function} [predicate=_.identity] The function invoked per iteration.
	 * @param {number} [fromIndex=0] The index to search from.
	 * @returns {*} Returns the matched element, else `undefined`.
	 * @example
	 *
	 * var users = [
	 *   { 'user': 'barney',  'age': 36, 'active': true },
	 *   { 'user': 'fred',    'age': 40, 'active': false },
	 *   { 'user': 'pebbles', 'age': 1,  'active': true }
	 * ];
	 *
	 * _.find(users, function(o) { return o.age < 40; });
	 * // => object for 'barney'
	 *
	 * // The `_.matches` iteratee shorthand.
	 * _.find(users, { 'age': 1, 'active': true });
	 * // => object for 'pebbles'
	 *
	 * // The `_.matchesProperty` iteratee shorthand.
	 * _.find(users, ['active', false]);
	 * // => object for 'fred'
	 *
	 * // The `_.property` iteratee shorthand.
	 * _.find(users, 'active');
	 * // => object for 'barney'
	 */
	var find = createFind(findIndex);

	module.exports = find;


/***/ }),
/* 160 */
/***/ (function(module, exports, __webpack_require__) {

	var baseIteratee = __webpack_require__(161),
	    isArrayLike = __webpack_require__(81),
	    keys = __webpack_require__(21);

	/**
	 * Creates a `_.find` or `_.findLast` function.
	 *
	 * @private
	 * @param {Function} findIndexFunc The function to find the collection index.
	 * @returns {Function} Returns the new find function.
	 */
	function createFind(findIndexFunc) {
	  return function(collection, predicate, fromIndex) {
	    var iterable = Object(collection);
	    if (!isArrayLike(collection)) {
	      var iteratee = baseIteratee(predicate, 3);
	      collection = keys(collection);
	      predicate = function(key) { return iteratee(iterable[key], key, iterable); };
	    }
	    var index = findIndexFunc(collection, predicate, fromIndex);
	    return index > -1 ? iterable[iteratee ? collection[index] : index] : undefined;
	  };
	}

	module.exports = createFind;


/***/ }),
/* 161 */
/***/ (function(module, exports) {

	/**
	 * This method returns the first argument it receives.
	 *
	 * @static
	 * @since 0.1.0
	 * @memberOf _
	 * @category Util
	 * @param {*} value Any value.
	 * @returns {*} Returns `value`.
	 * @example
	 *
	 * var object = { 'a': 1 };
	 *
	 * console.log(_.identity(object) === object);
	 * // => true
	 */
	function identity(value) {
	  return value;
	}

	module.exports = identity;


/***/ }),
/* 162 */
/***/ (function(module, exports, __webpack_require__) {

	var baseFindIndex = __webpack_require__(163),
	    baseIteratee = __webpack_require__(161),
	    toInteger = __webpack_require__(103);

	/* Built-in method references for those with the same name as other `lodash` methods. */
	var nativeMax = Math.max;

	/**
	 * This method is like `_.find` except that it returns the index of the first
	 * element `predicate` returns truthy for instead of the element itself.
	 *
	 * @static
	 * @memberOf _
	 * @since 1.1.0
	 * @category Array
	 * @param {Array} array The array to inspect.
	 * @param {Function} [predicate=_.identity] The function invoked per iteration.
	 * @param {number} [fromIndex=0] The index to search from.
	 * @returns {number} Returns the index of the found element, else `-1`.
	 * @example
	 *
	 * var users = [
	 *   { 'user': 'barney',  'active': false },
	 *   { 'user': 'fred',    'active': false },
	 *   { 'user': 'pebbles', 'active': true }
	 * ];
	 *
	 * _.findIndex(users, function(o) { return o.user == 'barney'; });
	 * // => 0
	 *
	 * // The `_.matches` iteratee shorthand.
	 * _.findIndex(users, { 'user': 'fred', 'active': false });
	 * // => 1
	 *
	 * // The `_.matchesProperty` iteratee shorthand.
	 * _.findIndex(users, ['active', false]);
	 * // => 0
	 *
	 * // The `_.property` iteratee shorthand.
	 * _.findIndex(users, 'active');
	 * // => 2
	 */
	function findIndex(array, predicate, fromIndex) {
	  var length = array == null ? 0 : array.length;
	  if (!length) {
	    return -1;
	  }
	  var index = fromIndex == null ? 0 : toInteger(fromIndex);
	  if (index < 0) {
	    index = nativeMax(length + index, 0);
	  }
	  return baseFindIndex(array, baseIteratee(predicate, 3), index);
	}

	module.exports = findIndex;


/***/ }),
/* 163 */
/***/ (function(module, exports) {

	/**
	 * The base implementation of `_.findIndex` and `_.findLastIndex` without
	 * support for iteratee shorthands.
	 *
	 * @private
	 * @param {Array} array The array to inspect.
	 * @param {Function} predicate The function invoked per iteration.
	 * @param {number} fromIndex The index to search from.
	 * @param {boolean} [fromRight] Specify iterating from right to left.
	 * @returns {number} Returns the index of the matched value, else `-1`.
	 */
	function baseFindIndex(array, predicate, fromIndex, fromRight) {
	  var length = array.length,
	      index = fromIndex + (fromRight ? 1 : -1);

	  while ((fromRight ? index-- : ++index < length)) {
	    if (predicate(array[index], index, array)) {
	      return index;
	    }
	  }
	  return -1;
	}

	module.exports = baseFindIndex;


/***/ }),
/* 164 */
/***/ (function(module, exports) {

	/**
	 * A specialized version of `_.map` for arrays without support for iteratee
	 * shorthands.
	 *
	 * @private
	 * @param {Array} [array] The array to iterate over.
	 * @param {Function} iteratee The function invoked per iteration.
	 * @returns {Array} Returns the new mapped array.
	 */
	function arrayMap(array, iteratee) {
	  var index = -1,
	      length = array == null ? 0 : array.length,
	      result = Array(length);

	  while (++index < length) {
	    result[index] = iteratee(array[index], index, array);
	  }
	  return result;
	}

	module.exports = arrayMap;


/***/ }),
/* 165 */
/***/ (function(module, exports) {

	/**
	 * A specialized version of `_.every` for arrays without support for
	 * iteratee shorthands.
	 *
	 * @private
	 * @param {Array} [array] The array to iterate over.
	 * @param {Function} predicate The function invoked per iteration.
	 * @returns {boolean} Returns `true` if all elements pass the predicate check,
	 *  else `false`.
	 */
	function arrayEvery(array, predicate) {
	  var index = -1,
	      length = array == null ? 0 : array.length;

	  while (++index < length) {
	    if (!predicate(array[index], index, array)) {
	      return false;
	    }
	  }
	  return true;
	}

	module.exports = arrayEvery;


/***/ }),
/* 166 */
/***/ (function(module, exports) {

	/** Error message constants. */
	var FUNC_ERROR_TEXT = 'Expected a function';

	/**
	 * Creates a function that negates the result of the predicate `func`. The
	 * `func` predicate is invoked with the `this` binding and arguments of the
	 * created function.
	 *
	 * @static
	 * @memberOf _
	 * @since 3.0.0
	 * @category Function
	 * @param {Function} predicate The predicate to negate.
	 * @returns {Function} Returns the new negated function.
	 * @example
	 *
	 * function isEven(n) {
	 *   return n % 2 == 0;
	 * }
	 *
	 * _.filter([1, 2, 3, 4, 5, 6], _.negate(isEven));
	 * // => [1, 3, 5]
	 */
	function negate(predicate) {
	  if (typeof predicate != 'function') {
	    throw new TypeError(FUNC_ERROR_TEXT);
	  }
	  return function() {
	    var args = arguments;
	    switch (args.length) {
	      case 0: return !predicate.call(this);
	      case 1: return !predicate.call(this, args[0]);
	      case 2: return !predicate.call(this, args[0], args[1]);
	      case 3: return !predicate.call(this, args[0], args[1], args[2]);
	    }
	    return !predicate.apply(this, args);
	  };
	}

	module.exports = negate;


/***/ }),
/* 167 */
/***/ (function(module, exports, __webpack_require__) {

	var baseRest = __webpack_require__(64),
	    createWrap = __webpack_require__(168),
	    getHolder = __webpack_require__(170),
	    replaceHolders = __webpack_require__(171);

	/** Used to compose bitmasks for function metadata. */
	var WRAP_PARTIAL_FLAG = 32;

	/**
	 * Creates a function that invokes `func` with `partials` prepended to the
	 * arguments it receives. This method is like `_.bind` except it does **not**
	 * alter the `this` binding.
	 *
	 * The `_.partial.placeholder` value, which defaults to `_` in monolithic
	 * builds, may be used as a placeholder for partially applied arguments.
	 *
	 * **Note:** This method doesn't set the "length" property of partially
	 * applied functions.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.2.0
	 * @category Function
	 * @param {Function} func The function to partially apply arguments to.
	 * @param {...*} [partials] The arguments to be partially applied.
	 * @returns {Function} Returns the new partially applied function.
	 * @example
	 *
	 * function greet(greeting, name) {
	 *   return greeting + ' ' + name;
	 * }
	 *
	 * var sayHelloTo = _.partial(greet, 'hello');
	 * sayHelloTo('fred');
	 * // => 'hello fred'
	 *
	 * // Partially applied with placeholders.
	 * var greetFred = _.partial(greet, _, 'fred');
	 * greetFred('hi');
	 * // => 'hi fred'
	 */
	var partial = baseRest(function(func, partials) {
	  var holders = replaceHolders(partials, getHolder(partial));
	  return createWrap(func, WRAP_PARTIAL_FLAG, undefined, partials, holders);
	});

	// Assign default placeholders.
	partial.placeholder = {};

	module.exports = partial;


/***/ }),
/* 168 */
/***/ (function(module, exports, __webpack_require__) {

	var apply = __webpack_require__(67),
	    createCtor = __webpack_require__(169),
	    root = __webpack_require__(27);

	/** Used to compose bitmasks for function metadata. */
	var WRAP_BIND_FLAG = 1;

	/**
	 * Creates a function that wraps `func` to invoke it with the `this` binding
	 * of `thisArg` and `partials` prepended to the arguments it receives.
	 *
	 * @private
	 * @param {Function} func The function to wrap.
	 * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
	 * @param {*} thisArg The `this` binding of `func`.
	 * @param {Array} partials The arguments to prepend to those provided to
	 *  the new function.
	 * @returns {Function} Returns the new wrapped function.
	 */
	function createPartial(func, bitmask, thisArg, partials) {
	  var isBind = bitmask & WRAP_BIND_FLAG,
	      Ctor = createCtor(func);

	  function wrapper() {
	    var argsIndex = -1,
	        argsLength = arguments.length,
	        leftIndex = -1,
	        leftLength = partials.length,
	        args = Array(leftLength + argsLength),
	        fn = (this && this !== root && this instanceof wrapper) ? Ctor : func;

	    while (++leftIndex < leftLength) {
	      args[leftIndex] = partials[leftIndex];
	    }
	    while (argsLength--) {
	      args[leftIndex++] = arguments[++argsIndex];
	    }
	    return apply(fn, isBind ? thisArg : this, args);
	  }
	  return wrapper;
	}

	module.exports = createPartial;


/***/ }),
/* 169 */
/***/ (function(module, exports, __webpack_require__) {

	var baseCreate = __webpack_require__(40),
	    isObject = __webpack_require__(41);

	/**
	 * Creates a function that produces an instance of `Ctor` regardless of
	 * whether it was invoked as part of a `new` expression or by `call` or `apply`.
	 *
	 * @private
	 * @param {Function} Ctor The constructor to wrap.
	 * @returns {Function} Returns the new wrapped function.
	 */
	function createCtor(Ctor) {
	  return function() {
	    // Use a `switch` statement to work with class constructors. See
	    // http://ecma-international.org/ecma-262/7.0/#sec-ecmascript-function-objects-call-thisargument-argumentslist
	    // for more details.
	    var args = arguments;
	    switch (args.length) {
	      case 0: return new Ctor;
	      case 1: return new Ctor(args[0]);
	      case 2: return new Ctor(args[0], args[1]);
	      case 3: return new Ctor(args[0], args[1], args[2]);
	      case 4: return new Ctor(args[0], args[1], args[2], args[3]);
	      case 5: return new Ctor(args[0], args[1], args[2], args[3], args[4]);
	      case 6: return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5]);
	      case 7: return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5], args[6]);
	    }
	    var thisBinding = baseCreate(Ctor.prototype),
	        result = Ctor.apply(thisBinding, args);

	    // Mimic the constructor's `return` behavior.
	    // See https://es5.github.io/#x13.2.2 for more details.
	    return isObject(result) ? result : thisBinding;
	  };
	}

	module.exports = createCtor;


/***/ }),
/* 170 */
/***/ (function(module, exports) {

	/**
	 * This method returns `undefined`.
	 *
	 * @static
	 * @memberOf _
	 * @since 2.3.0
	 * @category Util
	 * @example
	 *
	 * _.times(2, _.noop);
	 * // => [undefined, undefined]
	 */
	function noop() {
	  // No operation performed.
	}

	module.exports = noop;


/***/ }),
/* 171 */
/***/ (function(module, exports) {

	/**
	 * This method returns a new empty array.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.13.0
	 * @category Util
	 * @returns {Array} Returns the new empty array.
	 * @example
	 *
	 * var arrays = _.times(2, _.stubArray);
	 *
	 * console.log(arrays);
	 * // => [[], []]
	 *
	 * console.log(arrays[0] === arrays[1]);
	 * // => false
	 */
	function stubArray() {
	  return [];
	}

	module.exports = stubArray;


/***/ }),
/* 172 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var __importDefault = (this && this.__importDefault) || function (mod) {
	    return (mod && mod.__esModule) ? mod : { "default": mod };
	};
	Object.defineProperty(exports, "__esModule", { value: true });
	// (C) 2007-2018 GoodData Corporation
	var invariant_1 = __importDefault(__webpack_require__(154));
	var find_1 = __importDefault(__webpack_require__(159));
	var every_1 = __importDefault(__webpack_require__(165));
	var Rules = /** @class */ (function () {
	    function Rules() {
	        this.rules = [];
	    }
	    Rules.prototype.addRule = function (tests, callback) {
	        this.rules.push([tests, callback]);
	    };
	    Rules.prototype.match = function (subject, params) {
	        var _a = find_1.default(this.rules, function (_a) {
	            var tests = _a[0];
	            return every_1.default(tests, function (test) { return test(subject, params); });
	        }), callback = _a[1];
	        invariant_1.default(callback, "Callback not found :-(");
	        return callback;
	    };
	    return Rules;
	}());
	exports.Rules = Rules;


/***/ }),
/* 173 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var __importDefault = (this && this.__importDefault) || function (mod) {
	    return (mod && mod.__esModule) ? mod : { "default": mod };
	};
	Object.defineProperty(exports, "__esModule", { value: true });
	// (C) 2007-2018 GoodData Corporation
	var difference_1 = __importDefault(__webpack_require__(174));
	var map_1 = __importDefault(__webpack_require__(164));
	var IDENTIFIER_REGEX = /{\S+}/g;
	function getDependencies(_a) {
	    var metricDefinition = _a.metricDefinition;
	    return (metricDefinition.expression.match(IDENTIFIER_REGEX) || []).map(function (s) {
	        return s.substring(1, s.length - 1);
	    });
	}
	function getIdentifier(_a) {
	    var metricDefinition = _a.metricDefinition;
	    return metricDefinition.identifier;
	}
	function resolvedDependencies(resolved, _a) {
	    var dependencies = _a.dependencies;
	    var identifiers = map_1.default(resolved, "identifier");
	    return difference_1.default(dependencies, identifiers).length === 0;
	}
	function scan(resolved, unresolved) {
	    for (var i = 0; i < unresolved.length; i += 1) {
	        var tested = unresolved[i];
	        if (resolvedDependencies(resolved, tested)) {
	            resolved.push(tested);
	            unresolved.splice(i, 1);
	            i -= 1;
	        }
	    }
	}
	function sort(unresolved) {
	    var resolved = [];
	    var lastLength;
	    while (unresolved.length > 0) {
	        lastLength = unresolved.length;
	        scan(resolved, unresolved);
	        if (unresolved.length === lastLength) {
	            throw new Error("Metric defintions cannot be sorted due to missing dependencies.");
	        }
	    }
	    return resolved;
	}
	function sortDefinitions(definitions) {
	    var indexed = definitions.map(function (definition) { return ({
	        definition: definition,
	        identifier: getIdentifier(definition),
	        dependencies: getDependencies(definition),
	    }); });
	    return map_1.default(sort(indexed), "definition");
	}
	exports.sortDefinitions = sortDefinitions;


/***/ }),
/* 174 */
/***/ (function(module, exports, __webpack_require__) {

	var baseDifference = __webpack_require__(175),
	    baseFlatten = __webpack_require__(105),
	    baseRest = __webpack_require__(64),
	    isArrayLikeObject = __webpack_require__(80);

	/**
	 * Creates an array of `array` values not included in the other given arrays
	 * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
	 * for equality comparisons. The order and references of result values are
	 * determined by the first array.
	 *
	 * **Note:** Unlike `_.pullAll`, this method returns a new array.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Array
	 * @param {Array} array The array to inspect.
	 * @param {...Array} [values] The values to exclude.
	 * @returns {Array} Returns the new array of filtered values.
	 * @see _.without, _.xor
	 * @example
	 *
	 * _.difference([2, 1], [2, 3]);
	 * // => [1]
	 */
	var difference = baseRest(function(array, values) {
	  return isArrayLikeObject(array)
	    ? baseDifference(array, baseFlatten(values, 1, isArrayLikeObject, true))
	    : [];
	});

	module.exports = difference;


/***/ }),
/* 175 */
/***/ (function(module, exports, __webpack_require__) {

	var SetCache = __webpack_require__(176),
	    arrayIncludes = __webpack_require__(177),
	    arrayIncludesWith = __webpack_require__(179),
	    arrayMap = __webpack_require__(120),
	    baseUnary = __webpack_require__(180),
	    cacheHas = __webpack_require__(181);

	/** Used as the size to enable large array optimizations. */
	var LARGE_ARRAY_SIZE = 200;

	/**
	 * The base implementation of methods like `_.difference` without support
	 * for excluding multiple arrays or iteratee shorthands.
	 *
	 * @private
	 * @param {Array} array The array to inspect.
	 * @param {Array} values The values to exclude.
	 * @param {Function} [iteratee] The iteratee invoked per element.
	 * @param {Function} [comparator] The comparator invoked per element.
	 * @returns {Array} Returns the new array of filtered values.
	 */
	function baseDifference(array, values, iteratee, comparator) {
	  var index = -1,
	      includes = arrayIncludes,
	      isCommon = true,
	      length = array.length,
	      result = [],
	      valuesLength = values.length;

	  if (!length) {
	    return result;
	  }
	  if (iteratee) {
	    values = arrayMap(values, baseUnary(iteratee));
	  }
	  if (comparator) {
	    includes = arrayIncludesWith;
	    isCommon = false;
	  }
	  else if (values.length >= LARGE_ARRAY_SIZE) {
	    includes = cacheHas;
	    isCommon = false;
	    values = new SetCache(values);
	  }
	  outer:
	  while (++index < length) {
	    var value = array[index],
	        computed = iteratee == null ? value : iteratee(value);

	    value = (comparator || value !== 0) ? value : 0;
	    if (isCommon && computed === computed) {
	      var valuesIndex = valuesLength;
	      while (valuesIndex--) {
	        if (values[valuesIndex] === computed) {
	          continue outer;
	        }
	      }
	      result.push(value);
	    }
	    else if (!includes(values, computed, comparator)) {
	      result.push(value);
	    }
	  }
	  return result;
	}

	module.exports = baseDifference;


/***/ }),
/* 176 */
/***/ (function(module, exports, __webpack_require__) {

	var isArray = __webpack_require__(44);

	/**
	 * Casts `value` as an array if it's not one.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.4.0
	 * @category Lang
	 * @param {*} value The value to inspect.
	 * @returns {Array} Returns the cast array.
	 * @example
	 *
	 * _.castArray(1);
	 * // => [1]
	 *
	 * _.castArray({ 'a': 1 });
	 * // => [{ 'a': 1 }]
	 *
	 * _.castArray('abc');
	 * // => ['abc']
	 *
	 * _.castArray(null);
	 * // => [null]
	 *
	 * _.castArray(undefined);
	 * // => [undefined]
	 *
	 * _.castArray();
	 * // => []
	 *
	 * var array = [1, 2, 3];
	 * console.log(_.castArray(array) === array);
	 * // => true
	 */
	function castArray() {
	  if (!arguments.length) {
	    return [];
	  }
	  var value = arguments[0];
	  return isArray(value) ? value : [value];
	}

	module.exports = castArray;


/***/ }),
/* 177 */
/***/ (function(module, exports, __webpack_require__) {

	var baseIndexOf = __webpack_require__(178);

	/**
	 * A specialized version of `_.includes` for arrays without support for
	 * specifying an index to search from.
	 *
	 * @private
	 * @param {Array} [array] The array to inspect.
	 * @param {*} target The value to search for.
	 * @returns {boolean} Returns `true` if `target` is found, else `false`.
	 */
	function arrayIncludes(array, value) {
	  var length = array == null ? 0 : array.length;
	  return !!length && baseIndexOf(array, value, 0) > -1;
	}

	module.exports = arrayIncludes;


/***/ }),
/* 178 */
/***/ (function(module, exports) {

	/**
	 * A specialized version of `_.indexOf` which performs strict equality
	 * comparisons of values, i.e. `===`.
	 *
	 * @private
	 * @param {Array} array The array to inspect.
	 * @param {*} value The value to search for.
	 * @param {number} fromIndex The index to search from.
	 * @returns {number} Returns the index of the matched value, else `-1`.
	 */
	function strictIndexOf(array, value, fromIndex) {
	  var index = fromIndex - 1,
	      length = array.length;

	  while (++index < length) {
	    if (array[index] === value) {
	      return index;
	    }
	  }
	  return -1;
	}

	module.exports = strictIndexOf;


/***/ }),
/* 179 */
/***/ (function(module, exports) {

	/**
	 * This function is like `arrayIncludes` except that it accepts a comparator.
	 *
	 * @private
	 * @param {Array} [array] The array to inspect.
	 * @param {*} target The value to search for.
	 * @param {Function} comparator The comparator invoked per element.
	 * @returns {boolean} Returns `true` if `target` is found, else `false`.
	 */
	function arrayIncludesWith(array, value, comparator) {
	  var index = -1,
	      length = array == null ? 0 : array.length;

	  while (++index < length) {
	    if (comparator(value, array[index])) {
	      return true;
	    }
	  }
	  return false;
	}

	module.exports = arrayIncludesWith;


/***/ }),
/* 180 */
/***/ (function(module, exports) {

	/**
	 * The base implementation of `_.unary` without support for storing metadata.
	 *
	 * @private
	 * @param {Function} func The function to cap arguments for.
	 * @returns {Function} Returns the new capped function.
	 */
	function baseUnary(func) {
	  return function(value) {
	    return func(value);
	  };
	}

	module.exports = baseUnary;


/***/ }),
/* 181 */
/***/ (function(module, exports, __webpack_require__) {

	var baseIndexOf = __webpack_require__(178);

	/**
	 * A specialized version of `_.includes` for arrays without support for
	 * specifying an index to search from.
	 *
	 * @private
	 * @param {Array} [array] The array to inspect.
	 * @param {*} target The value to search for.
	 * @returns {boolean} Returns `true` if `target` is found, else `false`.
	 */
	function arrayIncludes(array, value) {
	  var length = array == null ? 0 : array.length;
	  return !!length && baseIndexOf(array, value, 0) > -1;
	}

	module.exports = arrayIncludes;


/***/ }),
/* 182 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var __importDefault = (this && this.__importDefault) || function (mod) {
	    return (mod && mod.__esModule) ? mod : { "default": mod };
	};
	Object.defineProperty(exports, "__esModule", { value: true });
	// (C) 2007-2018 GoodData Corporation
	var get_1 = __importDefault(__webpack_require__(89));
	var set_1 = __importDefault(__webpack_require__(53));
	function getAttributeUris(displayForms) {
	    return displayForms.map(function (displayForm) {
	        return get_1.default(displayForm, ["attributeDisplayForm", "content", "formOf"]);
	    });
	}
	function createAttributesMap(displayForms, attributes) {
	    return displayForms.reduce(function (attributesMap, displayForm) {
	        var dfUri = get_1.default(displayForm, ["attributeDisplayForm", "meta", "uri"]);
	        var attribute = attributes.find(function (attr) {
	            return get_1.default(attr, ["attribute", "meta", "uri"]) ===
	                get_1.default(displayForm, ["attributeDisplayForm", "content", "formOf"]);
	        });
	        return set_1.default(attributesMap, [dfUri], attribute);
	    }, {});
	}
	function getMissingUrisInAttributesMap(displayFormsUris, attributesMap) {
	    var uris = displayFormsUris || [];
	    return uris.filter(function (uri) { return !attributesMap[uri]; });
	}
	exports.getMissingUrisInAttributesMap = getMissingUrisInAttributesMap;
	var AttributesMapLoaderModule = /** @class */ (function () {
	    function AttributesMapLoaderModule(md) {
	        this.md = md;
	    }
	    AttributesMapLoaderModule.prototype.loadAttributesMap = function (projectId, attributeDisplayFormUris) {
	        var _this = this;
	        if (attributeDisplayFormUris.length === 0) {
	            return Promise.resolve({});
	        }
	        return this.md.getObjects(projectId, attributeDisplayFormUris).then(function (displayForms) {
	            var attributeUris = getAttributeUris(displayForms);
	            return _this.md.getObjects(projectId, attributeUris).then(function (attributes) {
	                return createAttributesMap(displayForms, attributes);
	            });
	        });
	    };
	    return AttributesMapLoaderModule;
	}());
	exports.AttributesMapLoaderModule = AttributesMapLoaderModule;


/***/ }),
/* 183 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var __importDefault = (this && this.__importDefault) || function (mod) {
	    return (mod && mod.__esModule) ? mod : { "default": mod };
	};
	Object.defineProperty(exports, "__esModule", { value: true });
	// (C) 2007-2018 GoodData Corporation
	var get_1 = __importDefault(__webpack_require__(89));
	var BUCKETS = "buckets";
	function getBuckets(mdObj) {
	    return get_1.default(mdObj, BUCKETS, []);
	}
	exports.getBuckets = getBuckets;
	function isAttribute(bucketItem) {
	    return get_1.default(bucketItem, "visualizationAttribute") !== undefined;
	}
	function isAttributeMeasureFilter(measureFilter) {
	    return ((get_1.default(measureFilter, "positiveAttributeFilter") || get_1.default(measureFilter, "negativeAttributeFilter")) !==
	        undefined);
	}
	exports.isAttributeMeasureFilter = isAttributeMeasureFilter;
	function isMeasure(bucketItem) {
	    return get_1.default(bucketItem, "measure") !== undefined;
	}
	function getAttributesInBucket(bucket) {
	    return get_1.default(bucket, "items").reduce(function (list, bucketItem) {
	        if (isAttribute(bucketItem)) {
	            list.push(get_1.default(bucketItem, "visualizationAttribute"));
	        }
	        return list;
	    }, []);
	}
	function getAttributes(mdObject) {
	    var buckets = getBuckets(mdObject);
	    return buckets.reduce(function (categoriesList, bucket) { return categoriesList.concat(getAttributesInBucket(bucket)); }, []);
	}
	exports.getAttributes = getAttributes;
	function getMeasuresInBucket(bucket) {
	    return get_1.default(bucket, "items").reduce(function (list, bucketItem) {
	        if (isMeasure(bucketItem)) {
	            list.push(get_1.default(bucketItem, "measure"));
	        }
	        return list;
	    }, []);
	}
	function getDefinition(measure) {
	    return get_1.default(measure, ["definition", "measureDefinition"], {});
	}
	exports.getDefinition = getDefinition;
	function getMeasures(mdObject) {
	    var buckets = getBuckets(mdObject);
	    return buckets.reduce(function (measuresList, bucket) { return measuresList.concat(getMeasuresInBucket(bucket)); }, []);
	}
	exports.getMeasures = getMeasures;
	function getMeasureFilters(measure) {
	    return get_1.default(getDefinition(measure), "filters", []);
	}
	exports.getMeasureFilters = getMeasureFilters;
	function getMeasureAttributeFilters(measure) {
	    return getMeasureFilters(measure).filter(isAttributeMeasureFilter);
	}
	exports.getMeasureAttributeFilters = getMeasureAttributeFilters;
	function getAttributeFilters(mdObject) {
	    return getMeasures(mdObject).reduce(function (filters, measure) { return filters.concat(getMeasureAttributeFilters(measure)); }, []);
	}
	function getAttributeFilterDisplayForm(measureFilter) {
	    return (get_1.default(measureFilter, ["positiveAttributeFilter", "displayForm", "uri"]) ||
	        get_1.default(measureFilter, ["negativeAttributeFilter", "displayForm", "uri"]));
	}
	function getAttributesDisplayForms(mdObject) {
	    var attributesDfs = getAttributes(mdObject).map(function (attribute) {
	        return get_1.default(attribute, ["displayForm", "uri"]);
	    });
	    var attrMeasureFilters = getAttributeFilters(mdObject);
	    var attrMeasureFiltersDfs = attrMeasureFilters.map(getAttributeFilterDisplayForm);
	    return attrMeasureFiltersDfs.concat(attributesDfs);
	}
	exports.getAttributesDisplayForms = getAttributesDisplayForms;


/***/ }),
/* 184 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || (function () {
	    var extendStatics = function (d, b) {
	        extendStatics = Object.setPrototypeOf ||
	            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
	            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
	        return extendStatics(d, b);
	    };
	    return function (d, b) {
	        extendStatics(d, b);
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	})();
	var __assign = (this && this.__assign) || function () {
	    __assign = Object.assign || function(t) {
	        for (var s, i = 1, n = arguments.length; i < n; i++) {
	            s = arguments[i];
	            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
	                t[p] = s[p];
	        }
	        return t;
	    };
	    return __assign.apply(this, arguments);
	};
	var __importDefault = (this && this.__importDefault) || function (mod) {
	    return (mod && mod.__esModule) ? mod : { "default": mod };
	};
	Object.defineProperty(exports, "__esModule", { value: true });
	// (C) 2007-2020 GoodData Corporation
	var invariant_1 = __importDefault(__webpack_require__(154));
	var qs_1 = __importDefault(__webpack_require__(95));
	var range_1 = __importDefault(__webpack_require__(185));
	var get_1 = __importDefault(__webpack_require__(89));
	var xhr_1 = __webpack_require__(48);
	var execute_afm_convert_1 = __webpack_require__(136);
	exports.DEFAULT_LIMIT = 1000;
	/**
	 * This interface represents error caused during second part of api execution (data fetching)
	 * and contains information about first execution part if that part was successful.
	 */
	var ApiExecutionResponseError = /** @class */ (function (_super) {
	    __extends(ApiExecutionResponseError, _super);
	    function ApiExecutionResponseError(error, executionResponse) {
	        var _this = _super.call(this, error.message, error.response, error.responseBody) || this;
	        _this.executionResponse = executionResponse;
	        return _this;
	    }
	    return ApiExecutionResponseError;
	}(xhr_1.ApiResponseError));
	exports.ApiExecutionResponseError = ApiExecutionResponseError;
	var ExecuteAfmModule = /** @class */ (function () {
	    function ExecuteAfmModule(xhr) {
	        this.xhr = xhr;
	    }
	    /**
	     * Execute AFM and fetch all data results
	     *
	     * @method executeAfm
	     * @param {String} projectId - GD project identifier
	     * @param {AFM.IExecution} execution - See https://github.com/gooddata/gooddata-typings/blob/v2.1.0/src/AFM.ts#L2
	     *
	     * @returns {Promise<Execution.IExecutionResponses>} Structure with `executionResponse` and `executionResult` -
	     *  See https://github.com/gooddata/gooddata-typings/blob/v2.1.0/src/Execution.ts#L113
	     */
	    ExecuteAfmModule.prototype.executeAfm = function (projectId, execution) {
	        var _this = this;
	        validateNumOfDimensions(get_1.default(execution, "execution.resultSpec.dimensions").length);
	        return this.getExecutionResponse(projectId, execution).then(function (executionResponse) {
	            return _this.getExecutionResult(executionResponse.links.executionResult)
	                .then(function (executionResult) {
	                return { executionResponse: executionResponse, executionResult: executionResult };
	            })
	                .catch(function (error) {
	                throw new ApiExecutionResponseError(error, executionResponse);
	            });
	        });
	    };
	    /**
	     * Execute AFM and return execution's response; the response describes dimensionality of the results and
	     * includes link to poll for the results.
	     *
	     * @method getExecutionResponse
	     * @param {string} projectId - GD project identifier
	     * @param {AFM.IExecution} execution - See https://github.com/gooddata/gooddata-typings/blob/v2.1.0/src/AFM.ts#L2
	     *
	     * @returns {Promise<Execution.IExecutionResponse>} Promise with `executionResponse`
	     *  See https://github.com/gooddata/gooddata-typings/blob/v2.1.0/src/Execution.ts#L69
	     */
	    ExecuteAfmModule.prototype.getExecutionResponse = function (projectId, execution) {
	        validateNumOfDimensions(get_1.default(execution, "execution.resultSpec.dimensions").length);
	        return this.xhr
	            .post("/gdc/app/projects/" + projectId + "/executeAfm", { body: execute_afm_convert_1.convertExecutionToJson(execution) })
	            .then(function (apiResponse) { return apiResponse.getData(); })
	            .then(unwrapExecutionResponse);
	    };
	    /**
	     * Execute saved visualization and get all data.
	     *
	     * NOTE: all functionality related to executeVisualization is experimental and subject to possible breaking changes
	     * in the future; location and shape of this interface WILL change when the functionality is made GA.
	     *
	     * @param {string} projectId - GD project identifier
	     * @param {IVisualizationExecution} visExecution - execution payload
	     *
	     * @private
	     * @internal
	     */
	    ExecuteAfmModule.prototype._executeVisualization = function (projectId, visExecution) {
	        // We have ONE-3961 as followup to take this out of experimental mode
	        var _this = this;
	        return this._getVisExecutionResponse(projectId, visExecution).then(function (executionResponse) {
	            return _this.getExecutionResult(executionResponse.links.executionResult).then(function (executionResult) {
	                return { executionResponse: executionResponse, executionResult: executionResult };
	            });
	        });
	    };
	    /**
	     *
	     * Execute visualization and return the response; the response describes dimensionality of the results and
	     * includes link to poll for the results.
	     *
	     * NOTE: all functionality related to executeVisualization is experimental and subject to possible breaking changes
	     * in the future; location and shape of this interface WILL change when the functionality is made GA.
	     *
	     * @param {string} projectId - GD project identifier
	     * @param {IVisualizationExecution} visExecution - execution payload
	     *
	     * @private
	     * @internal
	     */
	    ExecuteAfmModule.prototype._getVisExecutionResponse = function (projectId, visExecution) {
	        // We have ONE-3961 as followup to take this out of experimental mode
	        var body = createExecuteVisualizationBody(visExecution);
	        return this.xhr
	            .post("/gdc/app/projects/" + projectId + "/executeVisualization", { body: body })
	            .then(function (apiResponse) { return apiResponse.getData(); })
	            .then(unwrapExecutionResponse);
	    };
	    //
	    // working with results
	    //
	    /**
	     * Get one page of Result from Execution (with requested limit and offset)
	     *
	     * @method getPartialExecutionResult
	     * @param {string} executionResultUri
	     * @param {number[]} limit - limit for each dimension
	     * @param {number[]} offset - offset for each dimension
	     *
	     * @returns {Promise<Execution.IExecutionResult | null>}
	     *  Promise with `executionResult` or `null` (null means empty response - HTTP 204)
	     *  See https://github.com/gooddata/gooddata-typings/blob/v2.1.0/src/Execution.ts#L88
	     */
	    ExecuteAfmModule.prototype.getPartialExecutionResult = function (executionResultUri, limit, offset) {
	        var executionResultUriQueryPart = getExecutionResultUriQueryPart(executionResultUri);
	        var numOfDimensions = Number(qs_1.default.parse(executionResultUriQueryPart).dimensions);
	        validateNumOfDimensions(numOfDimensions);
	        return this.getPage(executionResultUri, limit, offset);
	    };
	    /**
	     * Get whole ExecutionResult
	     *
	     * @method getExecutionResult
	     * @param {string} executionResultUri
	     *
	     * @returns {Promise<Execution.IExecutionResult | null>}
	     *  Promise with `executionResult` or `null` (null means empty response - HTTP 204)
	     *  See https://github.com/gooddata/gooddata-typings/blob/v2.1.0/src/Execution.ts#L88
	     */
	    ExecuteAfmModule.prototype.getExecutionResult = function (executionResultUri) {
	        var executionResultUriQueryPart = getExecutionResultUriQueryPart(executionResultUri);
	        var numOfDimensions = Number(qs_1.default.parse(executionResultUriQueryPart).dimensions);
	        validateNumOfDimensions(numOfDimensions);
	        var limit = Array(numOfDimensions).fill(exports.DEFAULT_LIMIT);
	        var offset = Array(numOfDimensions).fill(0);
	        return this.getAllPages(executionResultUri, limit, offset);
	    };
	    ExecuteAfmModule.prototype.getPage = function (executionResultUri, limit, offset) {
	        return this.fetchExecutionResult(executionResultUri, limit, offset).then(function (executionResultWrapper) {
	            return executionResultWrapper ? unwrapExecutionResult(executionResultWrapper) : null;
	        });
	    };
	    ExecuteAfmModule.prototype.getAllPages = function (executionResultUri, limit, offset, prevExecutionResult) {
	        var _this = this;
	        return this.fetchExecutionResult(executionResultUri, limit, offset).then(function (executionResultWrapper) {
	            if (!executionResultWrapper) {
	                return null;
	            }
	            var executionResult = unwrapExecutionResult(executionResultWrapper);
	            var newExecutionResult = prevExecutionResult
	                ? mergePage(prevExecutionResult, executionResult)
	                : executionResult;
	            var _a = executionResult.paging, offset = _a.offset, total = _a.total;
	            var nextOffset = getNextOffset(limit, offset, total);
	            var nextLimit = getNextLimit(limit, nextOffset, total);
	            return nextPageExists(nextOffset, total)
	                ? _this.getAllPages(executionResultUri, nextLimit, nextOffset, newExecutionResult)
	                : newExecutionResult;
	        });
	    };
	    ExecuteAfmModule.prototype.fetchExecutionResult = function (executionResultUri, limit, offset) {
	        var uri = replaceLimitAndOffsetInUri(executionResultUri, limit, offset);
	        return this.xhr
	            .get(uri)
	            .then(function (apiResponse) { return (apiResponse.response.status === 204 ? null : apiResponse.getData()); });
	    };
	    return ExecuteAfmModule;
	}());
	exports.ExecuteAfmModule = ExecuteAfmModule;
	function getExecutionResultUriQueryPart(executionResultUri) {
	    return executionResultUri.split(/\?(.+)/)[1];
	}
	function unwrapExecutionResponse(executionResponseWrapper) {
	    return executionResponseWrapper.executionResponse;
	}
	function unwrapExecutionResult(executionResultWrapper) {
	    return executionResultWrapper.executionResult;
	}
	function validateNumOfDimensions(numOfDimensions) {
	    invariant_1.default(numOfDimensions === 1 || numOfDimensions === 2, numOfDimensions + " dimensions are not allowed. Only 1 or 2 dimensions are supported.");
	}
	function createExecuteVisualizationBody(visExecution) {
	    var _a = visExecution.visualizationExecution, reference = _a.reference, resultSpec = _a.resultSpec, filters = _a.filters;
	    var resultSpecProp = resultSpec ? { resultSpec: resultSpec } : undefined;
	    var filtersProp = filters ? { filters: filters } : undefined;
	    return JSON.stringify({
	        visualizationExecution: __assign({ reference: reference }, resultSpecProp, filtersProp),
	    });
	}
	function replaceLimitAndOffsetInUri(oldUri, limit, offset) {
	    var _a = oldUri.split(/\?(.+)/), uriPart = _a[0], queryPart = _a[1];
	    var query = __assign({}, qs_1.default.parse(queryPart), { limit: limit.join(","), offset: offset.join(",") });
	    return uriPart + qs_1.default.stringify(query, { addQueryPrefix: true });
	}
	exports.replaceLimitAndOffsetInUri = replaceLimitAndOffsetInUri;
	function getNextOffset(limit, offset, total) {
	    var numOfDimensions = total.length;
	    var defaultNextRowsOffset = offset[0] + limit[0];
	    if (numOfDimensions === 1) {
	        return [defaultNextRowsOffset];
	    }
	    var defaultNextColumnsOffset = offset[1] + limit[1];
	    var nextColumnsExist = offset[1] + limit[1] < total[1];
	    var nextRowsOffset = nextColumnsExist
	        ? offset[0] // stay in the same rows
	        : defaultNextRowsOffset; // go to the next rows
	    var nextColumnsOffset = nextColumnsExist
	        ? defaultNextColumnsOffset // next columns for the same rows
	        : 0; // start in the beginning of the next rows
	    return [nextRowsOffset, nextColumnsOffset];
	}
	exports.getNextOffset = getNextOffset;
	function getNextLimit(limit, nextOffset, total) {
	    var numOfDimensions = total.length;
	    validateNumOfDimensions(numOfDimensions);
	    var getSingleNextLimit = function (limit, nextOffset, total) {
	        return nextOffset + limit > total ? total - nextOffset : limit;
	    };
	    // prevent set up lower limit than possible for 2nd dimension in the beginning of the next rows
	    if (numOfDimensions === 2 &&
	        nextOffset[1] === 0 && // beginning of the next rows
	        limit[0] < total[1] // limit from 1st dimension should be used in 2nd dimension
	    ) {
	        return [getSingleNextLimit(limit[0], nextOffset[0], total[0]), limit[0]];
	    }
	    return range_1.default(numOfDimensions).map(function (i) { return getSingleNextLimit(limit[i], nextOffset[i], total[i]); });
	}
	exports.getNextLimit = getNextLimit;
	function nextPageExists(nextOffset, total) {
	    // expression "return nextLimit[0] > 0" also returns correct result
	    return nextOffset[0] < total[0];
	}
	exports.nextPageExists = nextPageExists;
	function mergeHeaderItemsForEachAttribute(dimension, headerItems, result) {
	    var _a;
	    if (headerItems && result.headerItems) {
	        for (var attrIdx = 0; attrIdx < headerItems[dimension].length; attrIdx += 1) {
	            (_a = result.headerItems[dimension][attrIdx]).push.apply(_a, headerItems[dimension][attrIdx]);
	        }
	    }
	}
	// works only for one or two dimensions
	function mergePage(prevExecutionResult, executionResult) {
	    var result = prevExecutionResult;
	    var headerItems = executionResult.headerItems, data = executionResult.data, paging = executionResult.paging;
	    var mergeHeaderItems = function (dimension) {
	        // for 1 dimension we already have the headers from first page
	        var otherDimension = dimension === 0 ? 1 : 0;
	        var isEdge = paging.offset[otherDimension] === 0;
	        if (isEdge) {
	            mergeHeaderItemsForEachAttribute(dimension, headerItems, result);
	        }
	    };
	    // merge data
	    var rowOffset = paging.offset[0];
	    if (result.data[rowOffset]) {
	        // appending columns to existing rows
	        for (var i = 0; i < data.length; i += 1) {
	            var columns = data[i];
	            var resultData = result.data[i + rowOffset];
	            resultData.push.apply(resultData, columns);
	        }
	    }
	    else {
	        // appending new rows
	        var resultData = result.data;
	        var currentPageData = data;
	        resultData.push.apply(resultData, currentPageData);
	    }
	    // merge headerItems
	    if (paging.offset.length > 1) {
	        mergeHeaderItems(0);
	        mergeHeaderItems(1);
	    }
	    else {
	        mergeHeaderItemsForEachAttribute(0, headerItems, result);
	    }
	    // update page count
	    if (paging.offset.length === 1) {
	        result.paging.count = [get_1.default(result, "headerItems[0][0]", []).length];
	    }
	    if (paging.offset.length === 2) {
	        result.paging.count = [
	            get_1.default(result, "headerItems[0][0]", []).length,
	            get_1.default(result, "headerItems[1][0]", []).length,
	        ];
	    }
	    return result;
	}
	exports.mergePage = mergePage;


/***/ }),
/* 185 */
/***/ (function(module, exports, __webpack_require__) {

	var createRange = __webpack_require__(186);

	/**
	 * Creates an array of numbers (positive and/or negative) progressing from
	 * `start` up to, but not including, `end`. A step of `-1` is used if a negative
	 * `start` is specified without an `end` or `step`. If `end` is not specified,
	 * it's set to `start` with `start` then set to `0`.
	 *
	 * **Note:** JavaScript follows the IEEE-754 standard for resolving
	 * floating-point values which can produce unexpected results.
	 *
	 * @static
	 * @since 0.1.0
	 * @memberOf _
	 * @category Util
	 * @param {number} [start=0] The start of the range.
	 * @param {number} end The end of the range.
	 * @param {number} [step=1] The value to increment or decrement by.
	 * @returns {Array} Returns the range of numbers.
	 * @see _.inRange, _.rangeRight
	 * @example
	 *
	 * _.range(4);
	 * // => [0, 1, 2, 3]
	 *
	 * _.range(-4);
	 * // => [0, -1, -2, -3]
	 *
	 * _.range(1, 5);
	 * // => [1, 2, 3, 4]
	 *
	 * _.range(0, 20, 5);
	 * // => [0, 5, 10, 15]
	 *
	 * _.range(0, -4, -1);
	 * // => [0, -1, -2, -3]
	 *
	 * _.range(1, 4, 0);
	 * // => [1, 1, 1]
	 *
	 * _.range(0);
	 * // => []
	 */
	var range = createRange();

	module.exports = range;


/***/ }),
/* 186 */
/***/ (function(module, exports, __webpack_require__) {

	var baseRange = __webpack_require__(187),
	    isIterateeCall = __webpack_require__(69),
	    toFinite = __webpack_require__(188);

	/**
	 * Creates a `_.range` or `_.rangeRight` function.
	 *
	 * @private
	 * @param {boolean} [fromRight] Specify iterating from right to left.
	 * @returns {Function} Returns the new range function.
	 */
	function createRange(fromRight) {
	  return function(start, end, step) {
	    if (step && typeof step != 'number' && isIterateeCall(start, end, step)) {
	      end = step = undefined;
	    }
	    // Ensure the sign of `-0` is preserved.
	    start = toFinite(start);
	    if (end === undefined) {
	      end = start;
	      start = 0;
	    } else {
	      end = toFinite(end);
	    }
	    step = step === undefined ? (start < end ? 1 : -1) : toFinite(step);
	    return baseRange(start, end, step, fromRight);
	  };
	}

	module.exports = createRange;


/***/ }),
/* 187 */
/***/ (function(module, exports) {

	/* Built-in method references for those with the same name as other `lodash` methods. */
	var nativeCeil = Math.ceil,
	    nativeMax = Math.max;

	/**
	 * The base implementation of `_.range` and `_.rangeRight` which doesn't
	 * coerce arguments.
	 *
	 * @private
	 * @param {number} start The start of the range.
	 * @param {number} end The end of the range.
	 * @param {number} step The value to increment or decrement by.
	 * @param {boolean} [fromRight] Specify iterating from right to left.
	 * @returns {Array} Returns the range of numbers.
	 */
	function baseRange(start, end, step, fromRight) {
	  var index = -1,
	      length = nativeMax(nativeCeil((end - start) / (step || 1)), 0),
	      result = Array(length);

	  while (length--) {
	    result[fromRight ? length : ++index] = start;
	    start += step;
	  }
	  return result;
	}

	module.exports = baseRange;


/***/ }),
/* 188 */
/***/ (function(module, exports) {

	/**
	 * This method returns the first argument it receives.
	 *
	 * @static
	 * @since 0.1.0
	 * @memberOf _
	 * @category Util
	 * @param {*} value Any value.
	 * @returns {*} Returns `value`.
	 * @example
	 *
	 * var object = { 'a': 1 };
	 *
	 * console.log(_.identity(object) === object);
	 * // => true
	 */
	function identity(value) {
	  return value;
	}

	module.exports = identity;


/***/ }),
/* 189 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var __assign = (this && this.__assign) || function () {
	    __assign = Object.assign || function(t) {
	        for (var s, i = 1, n = arguments.length; i < n; i++) {
	            s = arguments[i];
	            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
	                t[p] = s[p];
	        }
	        return t;
	    };
	    return __assign.apply(this, arguments);
	};
	var __importDefault = (this && this.__importDefault) || function (mod) {
	    return (mod && mod.__esModule) ? mod : { "default": mod };
	};
	Object.defineProperty(exports, "__esModule", { value: true });
	// (C) 2007-2019 GoodData Corporation
	var typings_1 = __webpack_require__(137);
	var compact_1 = __importDefault(__webpack_require__(155));
	var isEmpty_1 = __importDefault(__webpack_require__(117));
	var errors_1 = __webpack_require__(190);
	var FilterConverter_1 = __webpack_require__(191);
	var execute_afm_convert_1 = __webpack_require__(136);
	var util_1 = __webpack_require__(88);
	var export_1 = __webpack_require__(192);
	/**
	 * Functions for working with reports
	 *
	 * @Class report
	 * @module report
	 */
	var ReportModule = /** @class */ (function () {
	    function ReportModule(xhr) {
	        var _this = this;
	        this.xhr = xhr;
	        this.handleExportResultError = function (error) {
	            if (_this.isApiResponseError(error) &&
	                error.response.status === 400 &&
	                error.responseBody.indexOf(errors_1.ERROR_RESTRICTED_CODE) !== -1) {
	                return Promise.reject(__assign({}, error, { message: errors_1.ERROR_RESTRICTED_MESSAGE }));
	            }
	            return Promise.reject(error);
	        };
	    }
	    /**
	     * exportResult
	     * request new result export
	     * request new export of existing AFM execution
	     *
	     * @experimental
	     * @method exportResult
	     * @param {String} projectId GoodData projectId
	     * @param {String} executionResult report which should be exported
	     * @param {IExportConfig} exportConfig requested export options
	     * @param {Object} pollingOptions for polling (maxAttempts, pollStep)
	     * @return {Promise} Resolves if export successfully,
	     *                   Reject if export has error (network error, api error)
	     */
	    ReportModule.prototype.exportResult = function (projectId, executionResult, exportConfig, pollingOptions) {
	        var _this = this;
	        if (exportConfig === void 0) { exportConfig = {}; }
	        if (pollingOptions === void 0) { pollingOptions = {}; }
	        var requestPayload = {
	            resultExport: {
	                executionResult: executionResult,
	                exportConfig: __assign({}, exportConfig, this.sanitizeExportConfig(exportConfig)),
	            },
	        };
	        return this.xhr
	            .post("/gdc/internal/projects/" + projectId + "/exportResult", { body: requestPayload })
	            .then(function (response) { return response.getData(); })
	            .then(function (data) {
	            return util_1.handleHeadPolling(_this.xhr.get.bind(_this.xhr), data.uri, export_1.isExportFinished, pollingOptions);
	        })
	            .catch(this.handleExportResultError);
	    };
	    ReportModule.prototype.sanitizeExportConfig = function (exportConfig) {
	        var afm = exportConfig.afm;
	        if (afm && !isEmpty_1.default(afm.filters)) {
	            var sanitizedAfm = __assign({}, afm, { filters: this.sanitizeFilters(afm.filters) });
	            return __assign({}, exportConfig, { afm: sanitizedAfm });
	        }
	        return exportConfig;
	    };
	    ReportModule.prototype.isApiResponseError = function (error) {
	        return error.response !== undefined;
	    };
	    ReportModule.prototype.sanitizeFilters = function (filters) {
	        return filters ? compact_1.default(filters.map(this.sanitizeFilter)) : [];
	    };
	    ReportModule.prototype.sanitizeFilter = function (filter) {
	        if (typings_1.AFM.isAttributeFilter(filter)) {
	            return execute_afm_convert_1.convertFilter(filter);
	        }
	        else if (typings_1.AFM.isAbsoluteDateFilter(filter)) {
	            return FilterConverter_1.convertAbsoluteDateFilter(filter);
	        }
	        else if (typings_1.AFM.isRelativeDateFilter(filter)) {
	            return FilterConverter_1.convertRelativeDateFilter(filter);
	        }
	        return filter;
	    };
	    return ReportModule;
	}());
	exports.ReportModule = ReportModule;


/***/ }),
/* 190 */
/***/ (function(module, exports) {

	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	// (C) 2019 GoodData Corporation
	exports.SUCCESS_REQUEST_STATUS = 200;
	exports.ACCEPTED_REQUEST_STATUS = 202;
	exports.BAD_REQUEST_STATUS = 400;
	exports.BAD_REQUEST_MESSAGE = "Bad Request";
	exports.ERROR_RESTRICTED_CODE = "Export to required format is not allowed for data flagged as restricted.";
	exports.ERROR_RESTRICTED_MESSAGE = "You cannot export this insight because it contains restricted data.";


/***/ }),
/* 191 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	// (C) 2007-2019 GoodData Corporation
	var typings_1 = __webpack_require__(137);
	function convertAttributeFilter(filter) {
	    if (!typings_1.VisualizationObject.isPositiveAttributeFilter(filter)) {
	        if (!filter.negativeAttributeFilter.notIn.length) {
	            return null;
	        }
	    }
	    return filter;
	}
	function convertAbsoluteDateFilter(filter) {
	    var absoluteDateFilter = filter.absoluteDateFilter;
	    if (absoluteDateFilter.from === undefined || absoluteDateFilter.to === undefined) {
	        return null;
	    }
	    return {
	        absoluteDateFilter: {
	            dataSet: absoluteDateFilter.dataSet,
	            from: String(absoluteDateFilter.from),
	            to: String(absoluteDateFilter.to),
	        },
	    };
	}
	exports.convertAbsoluteDateFilter = convertAbsoluteDateFilter;
	function convertRelativeDateFilter(filter) {
	    var relativeDateFilter = filter.relativeDateFilter;
	    if (relativeDateFilter.from === undefined || !relativeDateFilter.to === undefined) {
	        return null;
	    }
	    return {
	        relativeDateFilter: {
	            dataSet: relativeDateFilter.dataSet,
	            granularity: relativeDateFilter.granularity,
	            from: Number(relativeDateFilter.from),
	            to: Number(relativeDateFilter.to),
	        },
	    };
	}
	exports.convertRelativeDateFilter = convertRelativeDateFilter;
	function convertMeasureValueFilter(filter) {
	    if (filter.measureValueFilter.condition === undefined) {
	        return null;
	    }
	    return filter;
	}
	exports.convertMeasureValueFilter = convertMeasureValueFilter;
	function convertVisualizationObjectFilter(filter) {
	    if (typings_1.VisualizationObject.isAttributeFilter(filter)) {
	        return convertAttributeFilter(filter);
	    }
	    else if (typings_1.VisualizationObject.isAbsoluteDateFilter(filter)) {
	        return convertAbsoluteDateFilter(filter);
	    }
	    else {
	        return convertRelativeDateFilter(filter);
	    }
	}
	exports.convertVisualizationObjectFilter = convertVisualizationObjectFilter;
	function convertVisualizationObjectExtendedFilter(filter) {
	    if (typings_1.VisualizationObject.isMeasureValueFilter(filter)) {
	        return convertMeasureValueFilter(filter);
	    }
	    else {
	        return convertVisualizationObjectFilter(filter);
	    }
	}
	exports.convertVisualizationObjectExtendedFilter = convertVisualizationObjectExtendedFilter;


/***/ }),
/* 192 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var __assign = (this && this.__assign) || function () {
	    __assign = Object.assign || function(t) {
	        for (var s, i = 1, n = arguments.length; i < n; i++) {
	            s = arguments[i];
	            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
	                t[p] = s[p];
	        }
	        return t;
	    };
	    return __assign.apply(this, arguments);
	};
	Object.defineProperty(exports, "__esModule", { value: true });
	var errors_1 = __webpack_require__(190);
	function isExportFinished(responseHeaders) {
	    var taskState = responseHeaders.status;
	    return taskState === errors_1.SUCCESS_REQUEST_STATUS || taskState >= errors_1.BAD_REQUEST_STATUS; // OK || ERROR
	}
	exports.isExportFinished = isExportFinished;
	function isDateFilter(filter) {
	    if (filter.dateFilter) {
	        return true;
	    }
	    return false;
	}
	exports.isDateFilter = isDateFilter;
	function sanitizeDateFilter(filter) {
	    var dateFilter = filter.dateFilter;
	    var optionalProps = {};
	    if (dateFilter.from) {
	        optionalProps.from = String(dateFilter.from);
	    }
	    if (dateFilter.to) {
	        optionalProps.to = String(dateFilter.to);
	    }
	    return {
	        dateFilter: __assign({}, dateFilter, optionalProps),
	    };
	}
	exports.sanitizeDateFilter = sanitizeDateFilter;
	function sanitizeDateFilters(filters) {
	    return filters.map(function (filter) {
	        if (isDateFilter(filter)) {
	            return sanitizeDateFilter(filter);
	        }
	        return filter;
	    });
	}
	exports.sanitizeDateFilters = sanitizeDateFilters;


/***/ }),
/* 193 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
	    return new (P || (P = Promise))(function (resolve, reject) {
	        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
	        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
	        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
	        step((generator = generator.apply(thisArg, _arguments || [])).next());
	    });
	};
	var __generator = (this && this.__generator) || function (thisArg, body) {
	    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
	    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
	    function verb(n) { return function (v) { return step([n, v]); }; }
	    function step(op) {
	        if (f) throw new TypeError("Generator is already executing.");
	        while (_) try {
	            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
	            if (y = 0, t) op = [op[0] & 2, t.value];
	            switch (op[0]) {
	                case 0: case 1: t = op; break;
	                case 4: _.label++; return { value: op[1], done: false };
	                case 5: _.label++; y = op[1]; op = [0]; continue;
	                case 7: op = _.ops.pop(); _.trys.pop(); continue;
	                default:
	                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
	                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
	                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
	                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
	                    if (t[2]) _.ops.pop();
	                    _.trys.pop(); continue;
	            }
	            op = body.call(thisArg, _);
	        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
	        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
	    }
	};
	Object.defineProperty(exports, "__esModule", { value: true });
	var util_1 = __webpack_require__(88);
	var export_1 = __webpack_require__(192);
	var DashboardModule = /** @class */ (function () {
	    function DashboardModule(xhr) {
	        this.xhr = xhr;
	    }
	    DashboardModule.prototype.exportToPdf = function (projectId, dashboardUri, filters, pollingOptions) {
	        if (filters === void 0) { filters = []; }
	        if (pollingOptions === void 0) { pollingOptions = {}; }
	        return __awaiter(this, void 0, Promise, function () {
	            var sanitizedFilters, payload, response, error_1;
	            return __generator(this, function (_a) {
	                switch (_a.label) {
	                    case 0:
	                        sanitizedFilters = export_1.sanitizeDateFilters(filters);
	                        payload = this.getDashboardExportPayload(dashboardUri, sanitizedFilters);
	                        _a.label = 1;
	                    case 1:
	                        _a.trys.push([1, 4, , 5]);
	                        return [4 /*yield*/, this.xhr.post("/gdc/internal/projects/" + projectId + "/exportDashboard", { body: payload })];
	                    case 2:
	                        response = _a.sent();
	                        return [4 /*yield*/, this.pollPdfFile(response, pollingOptions)];
	                    case 3: return [2 /*return*/, _a.sent()];
	                    case 4:
	                        error_1 = _a.sent();
	                        throw error_1;
	                    case 5: return [2 /*return*/];
	                }
	            });
	        });
	    };
	    DashboardModule.prototype.pollPdfFile = function (response, pollingOptions) {
	        return __awaiter(this, void 0, Promise, function () {
	            var data, exportResponse;
	            return __generator(this, function (_a) {
	                switch (_a.label) {
	                    case 0:
	                        data = response.getData();
	                        return [4 /*yield*/, util_1.handleHeadPolling(this.xhr.head.bind(this.xhr), data.uri, export_1.isExportFinished, pollingOptions)];
	                    case 1:
	                        exportResponse = _a.sent();
	                        return [2 /*return*/, exportResponse];
	                }
	            });
	        });
	    };
	    DashboardModule.prototype.getDashboardExportPayload = function (dashboardUri, filters) {
	        if (filters.length) {
	            return {
	                dashboardExport: {
	                    dashboardUri: dashboardUri,
	                    filters: filters,
	                },
	            };
	        }
	        // minimize payload
	        return {
	            dashboardExport: {
	                dashboardUri: dashboardUri,
	            },
	        };
	    };
	    return DashboardModule;
	}());
	exports.DashboardModule = DashboardModule;


/***/ }),
/* 194 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var __assign = (this && this.__assign) || function () {
	    __assign = Object.assign || function(t) {
	        for (var s, i = 1, n = arguments.length; i < n; i++) {
	            s = arguments[i];
	            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
	                t[p] = s[p];
	        }
	        return t;
	    };
	    return __assign.apply(this, arguments);
	};
	var __importDefault = (this && this.__importDefault) || function (mod) {
	    return (mod && mod.__esModule) ? mod : { "default": mod };
	};
	Object.defineProperty(exports, "__esModule", { value: true });
	// (C) 2007-2014 GoodData Corporation
	var set_1 = __importDefault(__webpack_require__(53));
	var get_1 = __importDefault(__webpack_require__(89));
	/**
	 * Config module holds SDK configuration variables
	 *
	 * Currently its only custom domain - which enabled using
	 * sdk from different domain (using CORS)
	 *
	 * Never set properties directly - always use setter methods
	 *
	 * @module config
	 * @class config
	 */
	var URL_REGEXP = "(?:(https)://+|(www\\.)?)\\w[:;,\\.?\\[\\]\\w/~%&=+#-@!]*";
	function sanitizeDomain(domain) {
	    if (domain === null) {
	        return undefined;
	    }
	    var sanitizedDomain = domain || "";
	    var link = sanitizedDomain.match(URL_REGEXP);
	    if (!link) {
	        throw new Error(domain + " is not a valid url");
	    }
	    // ensure https:// prefix and strip possible trailing /
	    return "https://" + link[0].replace(/^https?:\/\/|\/$/g, "");
	}
	exports.sanitizeDomain = sanitizeDomain;
	/**
	 * Returns sanitized config
	 *
	 * @method sanitizeConfig
	 * @return {object|undefined} config with sanitized domain
	 */
	function sanitizeConfig(config) {
	    var sanitized = __assign({}, config);
	    if (config.domain) {
	        sanitized.domain = sanitizeDomain(config.domain);
	    }
	    return sanitized;
	}
	exports.sanitizeConfig = sanitizeConfig;
	/**
	 * Config factory
	 *
	 * @param {object|null} configStorage config object
	 * @method createModule
	 * @return SDK config module
	 */
	var ConfigModule = /** @class */ (function () {
	    function ConfigModule(configStorage) {
	        this.configStorage = configStorage;
	        if (arguments.length !== 1) {
	            throw new Error("Config module has to be called with exactly one argument.");
	        }
	    }
	    /**
	     * Sets custom domain. Parameter is url which has always to be https://
	     * (if you don't provide it, we will do it for you).
	     *
	     * RegExp inspired taken from
	     * https://github.com/jarib/google-closure-library/blob/master/closure/goog/string/linkify.js
	     * @param {String|null} domain valid domain starting with https:// or null for removing
	     * @method setCustomDomain
	     */
	    ConfigModule.prototype.setCustomDomain = function (domain) {
	        this.configStorage.domain = sanitizeDomain(domain);
	    };
	    /**
	     * Returns current domain
	     *
	     * @method getCustomDomain
	     */
	    ConfigModule.prototype.getCustomDomain = function () {
	        return this.configStorage.domain;
	    };
	    /**
	     * Sets JS package and version info
	     *
	     * @method setJsPackage
	     * @param {String} name package name
	     * @param {String} version package version (semver)
	     * @private
	     */
	    ConfigModule.prototype.setJsPackage = function (name, version) {
	        if (!this.configStorage.originPackage) {
	            // only set the first (topmost) package
	            this.configStorage.originPackage = { name: name, version: version };
	        }
	    };
	    /**
	     * Returns JS package and version info
	     *
	     * @method getJsPackage
	     * @return {object} with 'name' and 'version' properties
	     * @private
	     */
	    ConfigModule.prototype.getJsPackage = function () {
	        return this.configStorage.originPackage;
	    };
	    ConfigModule.prototype.setRequestHeader = function (key, value) {
	        set_1.default(this.configStorage, ["xhrSettings", "headers", key], value);
	    };
	    ConfigModule.prototype.getRequestHeader = function (key) {
	        return get_1.default(this.configStorage, ["xhrSettings", "headers", key]);
	    };
	    return ConfigModule;
	}());
	exports.ConfigModule = ConfigModule;


/***/ }),
/* 195 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var __assign = (this && this.__assign) || function () {
	    __assign = Object.assign || function(t) {
	        for (var s, i = 1, n = arguments.length; i < n; i++) {
	            s = arguments[i];
	            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
	                t[p] = s[p];
	        }
	        return t;
	    };
	    return __assign.apply(this, arguments);
	};
	var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
	    return new (P || (P = Promise))(function (resolve, reject) {
	        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
	        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
	        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
	        step((generator = generator.apply(thisArg, _arguments || [])).next());
	    });
	};
	var __generator = (this && this.__generator) || function (thisArg, body) {
	    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
	    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
	    function verb(n) { return function (v) { return step([n, v]); }; }
	    function step(op) {
	        if (f) throw new TypeError("Generator is already executing.");
	        while (_) try {
	            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
	            if (y = 0, t) op = [op[0] & 2, t.value];
	            switch (op[0]) {
	                case 0: case 1: t = op; break;
	                case 4: _.label++; return { value: op[1], done: false };
	                case 5: _.label++; y = op[1]; op = [0]; continue;
	                case 7: op = _.ops.pop(); _.trys.pop(); continue;
	                default:
	                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
	                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
	                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
	                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
	                    if (t[2]) _.ops.pop();
	                    _.trys.pop(); continue;
	            }
	            op = body.call(thisArg, _);
	        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
	        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
	    }
	};
	var __importDefault = (this && this.__importDefault) || function (mod) {
	    return (mod && mod.__esModule) ? mod : { "default": mod };
	};
	Object.defineProperty(exports, "__esModule", { value: true });
	// (C) 2007-2018 GoodData Corporation
	var get_1 = __importDefault(__webpack_require__(89));
	var find_1 = __importDefault(__webpack_require__(159));
	var omit_1 = __importDefault(__webpack_require__(119));
	var cloneDeep_1 = __importDefault(__webpack_require__(4));
	var REQUEST_DEFAULTS = {
	    types: ["attribute", "metric", "fact"],
	    paging: {
	        offset: 0,
	    },
	};
	var LOAD_DATE_DATASET_DEFAULTS = {
	    includeUnavailableDateDataSetsCount: true,
	    includeAvailableDateAttributes: true,
	};
	/**
	 * Convert specific params in options to "requiredDataSets" structure. For more details look into
	 * res file https://github.com/gooddata/gdc-bear/blob/develop/resources/specification/internal/catalog.res
	 *
	 * @param options Supported keys in options are:
	 * <ul>
	 * <li>dataSetIdentifier - in value is string identifier of dataSet - this leads to CUSTOM type
	 * <li>returnAllDateDataSets - true value means to return ALL values without dataSet differentiation
	 * <li>returnAllRelatedDateDataSets - only related date dataSets are loaded across all dataSets
	 * <li>by default we get PRODUCTION dataSets
	 * </ul>
	 * @returns {Object} "requiredDataSets" object hash.
	 */
	var getRequiredDataSets = function (options) {
	    if (get_1.default(options, "returnAllRelatedDateDataSets")) {
	        return {};
	    }
	    if (get_1.default(options, "returnAllDateDataSets")) {
	        return { requiredDataSets: { type: "ALL" } };
	    }
	    if (get_1.default(options, "dataSetIdentifier")) {
	        return {
	            requiredDataSets: {
	                type: "CUSTOM",
	                customIdentifiers: [get_1.default(options, "dataSetIdentifier")],
	            },
	        };
	    }
	    return { requiredDataSets: { type: "PRODUCTION" } };
	};
	var buildItemDescriptionObjects = function (_a) {
	    var columns = _a.columns, definitions = _a.definitions;
	    if (!columns) {
	        return [];
	    }
	    return columns.map(function (column) {
	        var definition = find_1.default(definitions, function (_a) {
	            var metricDefinition = _a.metricDefinition;
	            return metricDefinition.identifier === column;
	        });
	        var maql = get_1.default(definition, "metricDefinition.expression");
	        if (maql) {
	            return { expression: maql };
	        }
	        return { uri: column };
	    });
	};
	var isStoredItemDescription = function (itemDescription) {
	    return !!itemDescription.uri;
	};
	var isAdHocItemDescription = function (itemDescription) {
	    return !!itemDescription.expression;
	};
	var unwrapItemDescriptionObject = function (itemDescription) {
	    if (isStoredItemDescription(itemDescription)) {
	        return itemDescription.uri;
	    }
	    if (isAdHocItemDescription(itemDescription)) {
	        return itemDescription.expression;
	    }
	    throw new Error("Item description can only have expression or uri");
	};
	var CatalogueModule = /** @class */ (function () {
	    function CatalogueModule(xhr, execution) {
	        this.xhr = xhr;
	        this.execution = execution;
	    }
	    CatalogueModule.prototype.loadItems = function (projectId, options) {
	        var _this = this;
	        if (options === void 0) { options = {}; }
	        var request = omit_1.default(__assign({}, REQUEST_DEFAULTS, options, getRequiredDataSets(options)), ["dataSetIdentifier", "returnAllDateDataSets", "attributesMap"]);
	        var mdObj = get_1.default(cloneDeep_1.default(options), "bucketItems");
	        var attributesMap = get_1.default(options, "attributesMap");
	        var hasBuckets = get_1.default(mdObj, "buckets") !== undefined;
	        if (hasBuckets) {
	            return this.loadItemDescriptions(projectId, mdObj, attributesMap).then(function (bucketItems) {
	                return _this.loadCatalog(projectId, __assign({}, request, { bucketItems: bucketItems }));
	            });
	        }
	        return this.loadCatalog(projectId, request);
	    };
	    CatalogueModule.prototype.loadDateDataSets = function (projectId, options) {
	        return __awaiter(this, void 0, void 0, function () {
	            var mdObj, bucketItems, _a, omittedOptions, request;
	            return __generator(this, function (_b) {
	                switch (_b.label) {
	                    case 0:
	                        mdObj = cloneDeep_1.default(options).bucketItems;
	                        if (!mdObj) return [3 /*break*/, 2];
	                        return [4 /*yield*/, this.loadItemDescriptions(projectId, mdObj, get_1.default(options, "attributesMap"), true)];
	                    case 1:
	                        _a = _b.sent();
	                        return [3 /*break*/, 3];
	                    case 2:
	                        _a = undefined;
	                        _b.label = 3;
	                    case 3:
	                        bucketItems = _a;
	                        omittedOptions = [
	                            "filter",
	                            "types",
	                            "paging",
	                            "dataSetIdentifier",
	                            "returnAllDateDataSets",
	                            "returnAllRelatedDateDataSets",
	                            "attributesMap",
	                        ];
	                        // includeObjectsWithTags has higher priority than excludeObjectsWithTags,
	                        // so when present omit excludeObjectsWithTags
	                        if (options.includeObjectsWithTags) {
	                            omittedOptions.push("excludeObjectsWithTags");
	                        }
	                        request = omit_1.default(__assign({}, LOAD_DATE_DATASET_DEFAULTS, REQUEST_DEFAULTS, options, getRequiredDataSets(options), { bucketItems: bucketItems }), omittedOptions);
	                        return [2 /*return*/, this.requestDateDataSets(projectId, request)];
	                }
	            });
	        });
	    };
	    /**
	     * Loads item description objects and returns them
	     *
	     * @internal
	     * @private
	     *
	     * @param projectId {string}
	     * @param mdObj metadata object containing buckets, visualization class, properties etc.
	     * @param attributesMap contains map of attributes where the keys are the attributes display forms URIs
	     * @param removeDateItems {boolean} skip date items
	     * @return ItemDescription which is either `{ uri: string }` or `{ expression: string }`
	     */
	    CatalogueModule.prototype.loadItemDescriptionObjects = function (projectId, mdObj, attributesMap, removeDateItems) {
	        if (removeDateItems === void 0) { removeDateItems = false; }
	        return __awaiter(this, void 0, Promise, function () {
	            var definitionsAndColumns;
	            return __generator(this, function (_a) {
	                switch (_a.label) {
	                    case 0: return [4 /*yield*/, this.execution.mdToExecutionDefinitionsAndColumns(projectId, mdObj, { attributesMap: attributesMap, removeDateItems: removeDateItems })];
	                    case 1:
	                        definitionsAndColumns = _a.sent();
	                        return [2 /*return*/, buildItemDescriptionObjects(definitionsAndColumns)];
	                }
	            });
	        });
	    };
	    /**
	     * ItemDescription is either URI or MAQL expression
	     * https://github.com/gooddata/gdc-bear/blob/185.4/resources/specification/md/obj.res#L284
	     *
	     * @param projectId {string}
	     * @param mdObj metadata object containing buckets, visualization class, properties etc.
	     * @param attributesMap contains map of attributes where the keys are the attributes display forms URIs
	     * @param removeDateItems {boolean} skip date items
	     * @deprecated
	     */
	    CatalogueModule.prototype.loadItemDescriptions = function (projectId, mdObj, attributesMap, removeDateItems) {
	        if (removeDateItems === void 0) { removeDateItems = false; }
	        return __awaiter(this, void 0, Promise, function () {
	            var itemDescriptions;
	            return __generator(this, function (_a) {
	                switch (_a.label) {
	                    case 0: return [4 /*yield*/, this.loadItemDescriptionObjects(projectId, mdObj, attributesMap, removeDateItems)];
	                    case 1:
	                        itemDescriptions = _a.sent();
	                        return [2 /*return*/, itemDescriptions.map(unwrapItemDescriptionObject)];
	                }
	            });
	        });
	    };
	    CatalogueModule.prototype.requestDateDataSets = function (projectId, dateDataSetsRequest) {
	        var uri = "/gdc/internal/projects/" + projectId + "/loadDateDataSets";
	        return this.xhr
	            .post(uri, { data: { dateDataSetsRequest: dateDataSetsRequest } })
	            .then(function (r) { return r.getData(); })
	            .then(function (data) { return data.dateDataSetsResponse; });
	    };
	    CatalogueModule.prototype.loadCatalog = function (projectId, catalogRequest) {
	        var uri = "/gdc/internal/projects/" + projectId + "/loadCatalog";
	        return this.xhr
	            .post(uri, { data: { catalogRequest: catalogRequest } })
	            .then(function (r) { return r.getData(); })
	            .then(function (data) { return data.catalogResponse; });
	    };
	    return CatalogueModule;
	}());
	exports.CatalogueModule = CatalogueModule;


/***/ }),
/* 196 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	// (C) 2007-2014 GoodData Corporation
	var dataProducts_1 = __webpack_require__(197);
	var domainDataProducts_1 = __webpack_require__(201);
	var domains_1 = __webpack_require__(202);
	var domainSegments_1 = __webpack_require__(200);
	var clients_1 = __webpack_require__(203);
	var segments_1 = __webpack_require__(199);
	var logs_1 = __webpack_require__(204);
	var contracts_1 = __webpack_require__(205);
	/**
	 * Network-UI support methods. Mostly private
	 *
	 * @module admin
	 * @class admin
	 *
	 */
	var AdminModule = /** @class */ (function () {
	    function AdminModule(xhr) {
	        this.xhr = xhr;
	        this.dataProducts = new dataProducts_1.DataProductsModule(this.xhr);
	        this.domainDataProducts = new domainDataProducts_1.DomainDataProductModule(this.xhr);
	        this.domains = new domains_1.DomainsModule(this.xhr);
	        this.domainSegments = new domainSegments_1.DomainSegmentsModule(this.xhr);
	        this.clients = new clients_1.ClientsModule(this.xhr);
	        this.logs = new logs_1.LogsModule(this.xhr);
	        this.contracts = new contracts_1.ContractsModule(this.xhr);
	        this.segments = new segments_1.SegmentsModule(this.xhr);
	    }
	    return AdminModule;
	}());
	exports.AdminModule = AdminModule;


/***/ }),
/* 197 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var __assign = (this && this.__assign) || function () {
	    __assign = Object.assign || function(t) {
	        for (var s, i = 1, n = arguments.length; i < n; i++) {
	            s = arguments[i];
	            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
	                t[p] = s[p];
	        }
	        return t;
	    };
	    return __assign.apply(this, arguments);
	};
	var __importStar = (this && this.__importStar) || function (mod) {
	    if (mod && mod.__esModule) return mod;
	    var result = {};
	    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
	    result["default"] = mod;
	    return result;
	};
	Object.defineProperty(exports, "__esModule", { value: true });
	// (C) 2007-2018 GoodData Corporation
	var routes_1 = __webpack_require__(198);
	var segments_1 = __webpack_require__(199);
	var domainDataProducts = __importStar(__webpack_require__(201));
	exports.transformDataProduct = function (item) {
	    var contractId = routes_1.parse(item.dataProduct.links.self, routes_1.CONTRACT_DATA_PRODUCT).contractId;
	    var dataProduct = __assign({ contractId: contractId }, item.dataProduct);
	    if (dataProduct.domainDataProducts) {
	        dataProduct.domainDataProducts = dataProduct.domainDataProducts.map(domainDataProducts.transformDomainDataProduct);
	    }
	    if (dataProduct.segments) {
	        dataProduct.segments = dataProduct.segments.map(segments_1.transformSegment);
	    }
	    return dataProduct;
	};
	var DataProductsModule = /** @class */ (function () {
	    function DataProductsModule(xhr) {
	        this.xhr = xhr;
	    }
	    DataProductsModule.prototype.getDataProducts = function (contractId, include) {
	        return this.xhr
	            .get(routes_1.interpolate(routes_1.CONTRACT_DATA_PRODUCTS, { contractId: contractId }, include && { include: include }))
	            .then(function (r) { return r.getData(); })
	            .then(function (data) { return ({
	            items: data.dataProducts.items.map(exports.transformDataProduct),
	        }); });
	    };
	    DataProductsModule.prototype.getDataProduct = function (contractId, dataProductId, include, stats, state) {
	        return this.xhr
	            .get(routes_1.interpolate(routes_1.CONTRACT_DATA_PRODUCT, { contractId: contractId, dataProductId: dataProductId }, __assign({}, (include && { include: include }), (stats && { stats: stats }), (state && { state: state }))))
	            .then(function (r) { return r.getData(); })
	            .then(function (data) { return exports.transformDataProduct(data); });
	    };
	    DataProductsModule.prototype.createDataProduct = function (contractId, dataProductId, domainIds) {
	        return this.xhr.post(routes_1.interpolate(routes_1.CONTRACT_DATA_PRODUCTS, { contractId: contractId }), {
	            body: JSON.stringify({
	                dataProductCreate: {
	                    id: dataProductId,
	                    domains: domainIds.map(function (domainId) {
	                        return routes_1.interpolate(routes_1.CONTRACT_DOMAIN, { contractId: contractId, domainId: domainId });
	                    }),
	                },
	            }),
	        });
	    };
	    DataProductsModule.prototype.renameDataProduct = function (contractId, dataProductId, newDataProductId) {
	        return this.xhr.post(routes_1.interpolate(routes_1.CONTRACT_DATA_PRODUCT_RENAME, { contractId: contractId, dataProductId: dataProductId }), {
	            body: JSON.stringify({ dataProductRename: { id: newDataProductId } }),
	        });
	    };
	    DataProductsModule.prototype.deleteDataProduct = function (contractId, dataProductId) {
	        return this.xhr.del(routes_1.interpolate(routes_1.CONTRACT_DATA_PRODUCT, { contractId: contractId, dataProductId: dataProductId }));
	    };
	    return DataProductsModule;
	}());
	exports.DataProductsModule = DataProductsModule;


/***/ }),
/* 198 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var __assign = (this && this.__assign) || function () {
	    __assign = Object.assign || function(t) {
	        for (var s, i = 1, n = arguments.length; i < n; i++) {
	            s = arguments[i];
	            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
	                t[p] = s[p];
	        }
	        return t;
	    };
	    return __assign.apply(this, arguments);
	};
	Object.defineProperty(exports, "__esModule", { value: true });
	// (C) 2007-2018 GoodData Corporation
	var util_1 = __webpack_require__(88);
	exports.ROOT = "/gdc/admin";
	exports.CONTRACTS = exports.ROOT + "/contracts";
	exports.CONTRACT = exports.CONTRACTS + "/:contractId";
	exports.CONTRACT_DATA_PRODUCTS = exports.CONTRACT + "/dataproducts";
	exports.CONTRACT_DATA_PRODUCT = exports.CONTRACT_DATA_PRODUCTS + "/:dataProductId";
	exports.CONTRACT_DATA_PRODUCT_DOMAIN_DATA_PRODUCTS = exports.CONTRACT_DATA_PRODUCT + "/domaindataproducts";
	exports.CONTRACT_DATA_PRODUCT_DOMAIN_DATA_PRODUCT = exports.CONTRACT_DATA_PRODUCT_DOMAIN_DATA_PRODUCTS + "/:domainId";
	exports.CONTRACT_DATA_PRODUCT_RENAME = exports.CONTRACT_DATA_PRODUCT + "/rename";
	exports.CONTRACT_DATA_PRODUCT_SEGMENTS = exports.CONTRACT_DATA_PRODUCT + "/segments";
	exports.CONTRACT_DATA_PRODUCT_SEGMENT = exports.CONTRACT_DATA_PRODUCT_SEGMENTS + "/:segmentId";
	exports.CONTRACT_DATA_PRODUCT_SEGMENT_RENAME = exports.CONTRACT_DATA_PRODUCT_SEGMENT + "/rename";
	exports.CONTRACT_DATA_PRODUCT_DOMAIN_SEGMENTS = exports.CONTRACT_DATA_PRODUCT_SEGMENT + "/domainsegments";
	exports.CONTRACT_DATA_PRODUCT_DOMAIN_SEGMENT = exports.CONTRACT_DATA_PRODUCT_DOMAIN_SEGMENTS + "/:domainId";
	exports.CONTRACT_DATA_PRODUCT_DOMAIN_SEGMENT_CLONE = exports.CONTRACT_DATA_PRODUCT_DOMAIN_SEGMENT + "/clone";
	exports.CONTRACT_DATA_PRODUCT_DOMAIN_SEGMENT_RENAME = exports.CONTRACT_DATA_PRODUCT_DOMAIN_SEGMENT + "/rename";
	exports.CONTRACT_DATA_PRODUCT_DOMAIN_SEGMENT_SYNC = exports.CONTRACT_DATA_PRODUCT_DOMAIN_SEGMENT + "/synchronizeClients";
	exports.CONTRACT_DATA_PRODUCT_DOMAIN_SEGMENT_LOG = exports.CONTRACT_DATA_PRODUCT_DOMAIN_SEGMENT + "/activityLog";
	exports.CONTRACT_DATA_PRODUCT_DOMAIN_SEGMENT_CLIENTS = exports.CONTRACT_DATA_PRODUCT_DOMAIN_SEGMENT + "/clients";
	exports.CONTRACT_DATA_PRODUCT_DOMAIN_SEGMENT_CLIENT = exports.CONTRACT_DATA_PRODUCT_DOMAIN_SEGMENT_CLIENTS + "/:clientId";
	exports.CONTRACT_DATA_PRODUCT_DOMAIN_SEGMENT_CLIENT_USERS = exports.CONTRACT_DATA_PRODUCT_DOMAIN_SEGMENT_CLIENT + "/project/users";
	exports.CONTRACT_DOMAINS = exports.CONTRACT + "/domains";
	exports.CONTRACT_DOMAIN = exports.CONTRACT_DOMAINS + "/:domainId";
	exports.CONTRACT_DOMAIN_USERS = exports.CONTRACT_DOMAIN + "/users";
	exports.CONTRACT_DOMAIN_PROJECTS = exports.CONTRACT_DOMAIN + "/projects";
	exports.CONTRACT_DOMAIN_PROJECT = exports.CONTRACT_DOMAIN_PROJECTS + "/:projectId";
	exports.CONTRACT_USERS = exports.CONTRACT + "/users";
	exports.USER_CONTRACTS = exports.ROOT + "/users/:userId/contracts";
	exports.DEPLOY_SEGMENT = exports.CONTRACT_DOMAIN + "/dataProducts/:dataProductId/segments/:segmentId/deploy";
	// parse params in route string accoring to template
	// returns params as plain object
	exports.parse = function (route, template) {
	    var parsedRoute = "";
	    if (route.startsWith("http")) {
	        var routeMatch = route.match(/^(https?:)\/\/(([^:/?#]*)(?::([0-9]+))?)([/]{0,1}[^?#]*)(\?[^#]*|)(#.*|)$/);
	        parsedRoute = routeMatch ? routeMatch[5] : "";
	    }
	    else {
	        parsedRoute = route;
	    }
	    var values = parsedRoute.split("/");
	    var views = template.split("/");
	    return views.reduce(function (result, view, idx) {
	        var _a;
	        if (view[0] === ":") {
	            return __assign({}, result, (_a = {}, _a[view.substr(1)] = values[idx], _a));
	        }
	        return result;
	    }, {});
	};
	// interpolates specified parameters from params into
	// the specified route string and returns the result
	exports.interpolate = function (route, params, query) {
	    if (query === void 0) { query = null; }
	    return route
	        .split("/")
	        .map(function (view) { return (view[0] === ":" ? params[view.substr(1)] : view); })
	        .join("/") + util_1.queryString(query);
	};


/***/ }),
/* 199 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var __assign = (this && this.__assign) || function () {
	    __assign = Object.assign || function(t) {
	        for (var s, i = 1, n = arguments.length; i < n; i++) {
	            s = arguments[i];
	            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
	                t[p] = s[p];
	        }
	        return t;
	    };
	    return __assign.apply(this, arguments);
	};
	var __importStar = (this && this.__importStar) || function (mod) {
	    if (mod && mod.__esModule) return mod;
	    var result = {};
	    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
	    result["default"] = mod;
	    return result;
	};
	Object.defineProperty(exports, "__esModule", { value: true });
	// (C) 2007-2018 GoodData Corporation
	var routes_1 = __webpack_require__(198);
	var domainSegments = __importStar(__webpack_require__(200));
	exports.transformSegment = function (item) {
	    var _a = routes_1.parse(item.segment.links.self, routes_1.CONTRACT_DATA_PRODUCT_SEGMENT), contractId = _a.contractId, dataProductId = _a.dataProductId;
	    var segment = __assign({ contractId: contractId,
	        dataProductId: dataProductId }, item.segment);
	    if (segment.domainSegments) {
	        segment.domainSegments = segment.domainSegments.map(domainSegments.transformDomainSegment);
	    }
	    return segment;
	};
	var SegmentsModule = /** @class */ (function () {
	    function SegmentsModule(xhr) {
	        this.xhr = xhr;
	    }
	    SegmentsModule.prototype.getDataProductSegments = function (contractId, dataProductId) {
	        return this.xhr
	            .get(routes_1.interpolate(routes_1.CONTRACT_DATA_PRODUCT_SEGMENTS, { contractId: contractId, dataProductId: dataProductId }))
	            .then(function (r) { return r.getData(); })
	            .then(function (data) { return ({
	            items: data.segments.items.map(exports.transformSegment),
	            status: data.segments.status,
	        }); });
	    };
	    SegmentsModule.prototype.createSegment = function (contractId, dataProductId, segmentId, domainIds) {
	        return this.xhr.post(routes_1.interpolate(routes_1.CONTRACT_DATA_PRODUCT_SEGMENTS, { contractId: contractId, dataProductId: dataProductId }), {
	            body: JSON.stringify({
	                segmentCreate: {
	                    id: segmentId,
	                    title: segmentId,
	                    domains: domainIds.map(function (domainId) {
	                        return routes_1.interpolate(routes_1.CONTRACT_DOMAIN, { contractId: contractId, domainId: domainId });
	                    }),
	                },
	            }),
	        });
	    };
	    SegmentsModule.prototype.renameSegment = function (contractId, dataProductId, segmentId, newSegmentId) {
	        return this.xhr.post(routes_1.interpolate(routes_1.CONTRACT_DATA_PRODUCT_SEGMENT_RENAME, { contractId: contractId, dataProductId: dataProductId, segmentId: segmentId }), {
	            body: JSON.stringify({ segmentRename: { id: newSegmentId } }),
	        });
	    };
	    SegmentsModule.prototype.deleteSegment = function (contractId, dataProductId, segmentId) {
	        return this.xhr.del(routes_1.interpolate(routes_1.CONTRACT_DATA_PRODUCT_SEGMENT, { contractId: contractId, dataProductId: dataProductId, segmentId: segmentId }));
	    };
	    return SegmentsModule;
	}());
	exports.SegmentsModule = SegmentsModule;


/***/ }),
/* 200 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var __assign = (this && this.__assign) || function () {
	    __assign = Object.assign || function(t) {
	        for (var s, i = 1, n = arguments.length; i < n; i++) {
	            s = arguments[i];
	            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
	                t[p] = s[p];
	        }
	        return t;
	    };
	    return __assign.apply(this, arguments);
	};
	var __importDefault = (this && this.__importDefault) || function (mod) {
	    return (mod && mod.__esModule) ? mod : { "default": mod };
	};
	Object.defineProperty(exports, "__esModule", { value: true });
	// (C) 2007-2018 GoodData Corporation
	var omit_1 = __importDefault(__webpack_require__(119));
	var routes_1 = __webpack_require__(198);
	exports.transformDomainSegment = function (item) {
	    var _a = routes_1.parse(item.domainSegment.links.self, routes_1.CONTRACT_DATA_PRODUCT_DOMAIN_SEGMENT), contractId = _a.contractId, dataProductId = _a.dataProductId, segmentId = _a.segmentId, domainId = _a.domainId;
	    return __assign({ contractId: contractId,
	        dataProductId: dataProductId,
	        segmentId: segmentId,
	        domainId: domainId }, item.domainSegment);
	};
	var DomainSegmentsModule = /** @class */ (function () {
	    function DomainSegmentsModule(xhr) {
	        this.xhr = xhr;
	    }
	    DomainSegmentsModule.prototype.getDomainSegments = function (contractId, dataProductId, segmentId, query) {
	        return this.xhr
	            .get(routes_1.interpolate(routes_1.CONTRACT_DATA_PRODUCT_DOMAIN_SEGMENTS, { contractId: contractId, dataProductId: dataProductId, segmentId: segmentId }, query))
	            .then(function (result) { return ({
	            items: result.getData().domainSegments.items.map(exports.transformDomainSegment),
	        }); });
	    };
	    DomainSegmentsModule.prototype.getDomainSegment = function (contractId, dataProductId, segmentId, domainId, query) {
	        return this.xhr
	            .get(routes_1.interpolate(routes_1.CONTRACT_DATA_PRODUCT_DOMAIN_SEGMENT, { contractId: contractId, dataProductId: dataProductId, segmentId: segmentId, domainId: domainId }, query))
	            .then(function (result) { return exports.transformDomainSegment(result.getData()); });
	    };
	    DomainSegmentsModule.prototype.cloneDomainSegment = function (contractId, dataProductId, segmentId, domainId, newSegmentId, newDomainId) {
	        return this.xhr.post(routes_1.interpolate(routes_1.CONTRACT_DATA_PRODUCT_DOMAIN_SEGMENT_CLONE, {
	            contractId: contractId,
	            dataProductId: dataProductId,
	            segmentId: segmentId,
	            domainId: domainId,
	        }), {
	            body: JSON.stringify({
	                cloneSegmentRequest: {
	                    clonedSegmentId: newSegmentId,
	                    domain: newDomainId,
	                },
	            }),
	        });
	    };
	    DomainSegmentsModule.prototype.deleteDomainSegment = function (contractId, dataProductId, segmentId, domainId) {
	        return this.xhr.del(routes_1.interpolate(routes_1.CONTRACT_DATA_PRODUCT_DOMAIN_SEGMENT, {
	            contractId: contractId,
	            dataProductId: dataProductId,
	            segmentId: segmentId,
	            domainId: domainId,
	        }));
	    };
	    DomainSegmentsModule.prototype.renameDomainSegment = function (contractId, dataProductId, segmentId, domainId, newSegmentId) {
	        return this.xhr.post(routes_1.interpolate(routes_1.CONTRACT_DATA_PRODUCT_DOMAIN_SEGMENT_RENAME, {
	            contractId: contractId,
	            dataProductId: dataProductId,
	            segmentId: segmentId,
	            domainId: domainId,
	        }), {
	            body: JSON.stringify({
	                domainSegmentRename: {
	                    id: newSegmentId,
	                },
	            }),
	        });
	    };
	    DomainSegmentsModule.prototype.syncDomainSegment = function (contractId, dataProductId, segmentId, domainId) {
	        return this.xhr.post(routes_1.interpolate(routes_1.CONTRACT_DATA_PRODUCT_DOMAIN_SEGMENT_SYNC, {
	            contractId: contractId,
	            dataProductId: dataProductId,
	            segmentId: segmentId,
	            domainId: domainId,
	        }));
	    };
	    DomainSegmentsModule.prototype.deployDomainSegment = function (contractId, dataProductId, segmentId, domainId, targetDomainId, synchronize) {
	        return this.xhr.post(routes_1.interpolate(routes_1.DEPLOY_SEGMENT, { contractId: contractId, dataProductId: dataProductId, segmentId: segmentId, domainId: domainId }, synchronize && { synchronize: synchronize }), { body: JSON.stringify({ deploySegmentRequest: { domain: targetDomainId } }) });
	    };
	    DomainSegmentsModule.prototype.updateDomainSegment = function (domainSegment) {
	        return this.xhr
	            .put(routes_1.interpolate(routes_1.CONTRACT_DATA_PRODUCT_DOMAIN_SEGMENT, domainSegment), {
	            body: JSON.stringify({
	                domainSegment: omit_1.default(domainSegment, [
	                    "contractId",
	                    "dataProductId",
	                    "segmentId",
	                    "domainId",
	                ]),
	            }),
	        })
	            .then(function (result) { return result.json(); })
	            .then(function (result) { return exports.transformDomainSegment(result); });
	    };
	    return DomainSegmentsModule;
	}());
	exports.DomainSegmentsModule = DomainSegmentsModule;


/***/ }),
/* 201 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var __assign = (this && this.__assign) || function () {
	    __assign = Object.assign || function(t) {
	        for (var s, i = 1, n = arguments.length; i < n; i++) {
	            s = arguments[i];
	            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
	                t[p] = s[p];
	        }
	        return t;
	    };
	    return __assign.apply(this, arguments);
	};
	Object.defineProperty(exports, "__esModule", { value: true });
	// (C) 2007-2018 GoodData Corporation
	var routes_1 = __webpack_require__(198);
	exports.transformDomainDataProduct = function (_a) {
	    var domainDataProduct = _a.domainDataProduct;
	    var _b = routes_1.parse(domainDataProduct.links.self, routes_1.CONTRACT_DATA_PRODUCT_DOMAIN_DATA_PRODUCT), contractId = _b.contractId, domainId = _b.domainId, dataProductId = _b.dataProductId;
	    return __assign({ contractId: contractId,
	        domainId: domainId,
	        dataProductId: dataProductId }, domainDataProduct);
	};
	var DomainDataProductModule = /** @class */ (function () {
	    function DomainDataProductModule(xhr) {
	        this.xhr = xhr;
	    }
	    DomainDataProductModule.prototype.getDomainDataProducts = function (contractId, dataProductId) {
	        return this.xhr
	            .get(routes_1.interpolate(routes_1.CONTRACT_DATA_PRODUCT_DOMAIN_DATA_PRODUCTS, { contractId: contractId, dataProductId: dataProductId }))
	            .then(function (result) {
	            var _a = result.getData(), items = _a.domainDataProducts.items, status = _a.status;
	            return {
	                items: items.map(exports.transformDomainDataProduct),
	                status: status,
	            };
	        });
	    };
	    return DomainDataProductModule;
	}());
	exports.DomainDataProductModule = DomainDataProductModule;


/***/ }),
/* 202 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var __assign = (this && this.__assign) || function () {
	    __assign = Object.assign || function(t) {
	        for (var s, i = 1, n = arguments.length; i < n; i++) {
	            s = arguments[i];
	            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
	                t[p] = s[p];
	        }
	        return t;
	    };
	    return __assign.apply(this, arguments);
	};
	Object.defineProperty(exports, "__esModule", { value: true });
	// (C) 2007-2018 GoodData Corporation
	var routes_1 = __webpack_require__(198);
	var transformDomain = function (item) {
	    var _a = routes_1.parse(item.domain.links.self, routes_1.CONTRACT_DOMAIN), domainId = _a.domainId, contractId = _a.contractId;
	    return __assign({ id: domainId, contractId: contractId }, item.domain);
	};
	var transformDomainUser = function (_a) {
	    var user = _a.user;
	    var params = routes_1.parse(user.links.domain, routes_1.CONTRACT_DOMAIN);
	    return __assign({ id: user.login }, params, { fullName: user.firstName + " " + user.lastName }, user);
	};
	var DomainsModule = /** @class */ (function () {
	    function DomainsModule(xhr) {
	        this.xhr = xhr;
	    }
	    DomainsModule.prototype.getDomain = function (contractId, domainId, query) {
	        var uri = routes_1.interpolate(routes_1.CONTRACT_DOMAIN, { contractId: contractId, domainId: domainId }, query);
	        return this.xhr
	            .get(uri)
	            .then(function (r) { return r.getData(); })
	            .then(transformDomain);
	    };
	    DomainsModule.prototype.getDomains = function (contractId, query) {
	        return this.xhr
	            .get(routes_1.interpolate(routes_1.CONTRACT_DOMAINS, { contractId: contractId }, query))
	            .then(function (r) { return r.getData(); })
	            .then(function (result) { return ({ items: result.domains.items.map(transformDomain) }); }); // TODO: paging?
	    };
	    DomainsModule.prototype.getDomainUsers = function (contractId, domainId, query, paging) {
	        if (paging && !paging.next) {
	            return Promise.resolve({ items: [], paging: {} });
	        }
	        var uri = paging
	            ? paging.next
	            : routes_1.interpolate(routes_1.CONTRACT_DOMAIN_USERS, { contractId: contractId, domainId: domainId }, query);
	        return this.xhr
	            .get(uri)
	            .then(function (r) { return r.getData(); })
	            .then(function (result) { return (__assign({}, result.domainUsers, { items: result.domainUsers.items.map(transformDomainUser) })); });
	    };
	    DomainsModule.prototype.getDomainProjects = function (contractId, domainId, state, query, paging) {
	        var uri = null;
	        if (paging) {
	            if (!paging.next) {
	                return Promise.resolve({ items: [], paging: {} });
	            }
	            uri = paging.next;
	        }
	        else {
	            var queryObject = state || query
	                ? __assign({}, (state ? { state: state } : undefined), (query ? { prefixSearch: query } : undefined)) : null;
	            uri = routes_1.interpolate(routes_1.CONTRACT_DOMAIN_PROJECTS, { contractId: contractId, domainId: domainId }, queryObject);
	        }
	        return this.xhr
	            .get(uri)
	            .then(function (r) { return r.getData(); })
	            .then(function (result) { return (__assign({}, result.domainProjects, { items: result.domainProjects.items.map(function (item) { return item.project; }) })); });
	    };
	    return DomainsModule;
	}());
	exports.DomainsModule = DomainsModule;


/***/ }),
/* 203 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var __assign = (this && this.__assign) || function () {
	    __assign = Object.assign || function(t) {
	        for (var s, i = 1, n = arguments.length; i < n; i++) {
	            s = arguments[i];
	            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
	                t[p] = s[p];
	        }
	        return t;
	    };
	    return __assign.apply(this, arguments);
	};
	Object.defineProperty(exports, "__esModule", { value: true });
	// (C) 2007-2018 GoodData Corporation
	var routes_1 = __webpack_require__(198);
	var ClientsModule = /** @class */ (function () {
	    function ClientsModule(xhr) {
	        this.xhr = xhr;
	    }
	    ClientsModule.prototype.getClient = function (contractId, dataProductId, segmentId, domainId, clientId) {
	        var _this = this;
	        var query = { stats: "user" };
	        var uri = routes_1.interpolate(routes_1.CONTRACT_DATA_PRODUCT_DOMAIN_SEGMENT_CLIENT, { contractId: contractId, dataProductId: dataProductId, segmentId: segmentId, domainId: domainId, clientId: clientId }, query);
	        return this.xhr
	            .get(uri)
	            .then(function (r) { return r.getData(); })
	            .then(function (result) { return _this.transformClient(result); });
	    };
	    ClientsModule.prototype.getClients = function (contractId, dataProductId, segmentId, domainId, filter, paging) {
	        var _this = this;
	        var query = filter ? { clientPrefix: filter, stats: "user" } : { stats: "user" };
	        var uri = paging
	            ? paging.next
	            : routes_1.interpolate(routes_1.CONTRACT_DATA_PRODUCT_DOMAIN_SEGMENT_CLIENTS, { contractId: contractId, dataProductId: dataProductId, segmentId: segmentId, domainId: domainId }, query);
	        if (uri) {
	            return this.xhr
	                .get(uri)
	                .then(function (r) { return r.getData(); })
	                .then(function (result) { return ({
	                items: result.clients.items.map(_this.transformClient),
	                paging: result.clients.paging,
	            }); });
	        }
	        return Promise.resolve({ items: [], paging: {} });
	    };
	    ClientsModule.prototype.getClientUsers = function (contractId, dataProductId, domainId, segmentId, clientId, query, paging) {
	        var _this = this;
	        if (paging && !paging.next) {
	            return Promise.resolve({ items: [], paging: {} });
	        }
	        var uri = paging
	            ? paging.next
	            : routes_1.interpolate(routes_1.CONTRACT_DATA_PRODUCT_DOMAIN_SEGMENT_CLIENT_USERS, { contractId: contractId, dataProductId: dataProductId, domainId: domainId, segmentId: segmentId, clientId: clientId }, query);
	        return this.xhr
	            .get(uri)
	            .then(function (r) { return r.getData(); })
	            .then(function (result) { return (__assign({}, result.clientUsers, { items: result.clientUsers.items.map(_this.transformClientUser) })); });
	    };
	    ClientsModule.prototype.transformClient = function (item) {
	        var _a = routes_1.parse(item.client.links.self, routes_1.CONTRACT_DATA_PRODUCT_DOMAIN_SEGMENT_CLIENT), contractId = _a.contractId, dataProductId = _a.dataProductId, domainId = _a.domainId, segmentId = _a.segmentId;
	        return __assign({ contractId: contractId,
	            dataProductId: dataProductId,
	            domainId: domainId,
	            segmentId: segmentId }, item.client);
	    };
	    ClientsModule.prototype.transformClientUser = function (user) {
	        return __assign({ id: user.login, fullName: user.firstName + " " + user.lastName, role: user.roles[0] }, user);
	    };
	    return ClientsModule;
	}());
	exports.ClientsModule = ClientsModule;


/***/ }),
/* 204 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	// (C) 2007-2018 GoodData Corporation
	var routes_1 = __webpack_require__(198);
	var LogsModule = /** @class */ (function () {
	    function LogsModule(xhr) {
	        this.xhr = xhr;
	    }
	    LogsModule.prototype.getLogs = function (contractId, dataProductId, domainId, segmentId) {
	        return this.xhr
	            .get(routes_1.interpolate(routes_1.CONTRACT_DATA_PRODUCT_DOMAIN_SEGMENT_LOG, {
	            contractId: contractId,
	            dataProductId: dataProductId,
	            domainId: domainId,
	            segmentId: segmentId,
	        }))
	            .then(function (data) { return data.logs.map(function (item) { return item.log; }); });
	    };
	    return LogsModule;
	}());
	exports.LogsModule = LogsModule;


/***/ }),
/* 205 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var __importStar = (this && this.__importStar) || function (mod) {
	    if (mod && mod.__esModule) return mod;
	    var result = {};
	    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
	    result["default"] = mod;
	    return result;
	};
	Object.defineProperty(exports, "__esModule", { value: true });
	// (C) 2007-2018 GoodData Corporation
	var routes = __importStar(__webpack_require__(198));
	var ContractsModule = /** @class */ (function () {
	    function ContractsModule(xhr) {
	        this.xhr = xhr;
	    }
	    ContractsModule.prototype.getUserContracts = function () {
	        return this.xhr.get(routes.CONTRACTS).then(function (data) { return ({
	            items: data.getData().contracts.items.map(function (item) { return item.contract; }),
	            paging: data.getData().contracts.paging,
	        }); });
	    };
	    return ContractsModule;
	}());
	exports.ContractsModule = ContractsModule;


/***/ }),
/* 206 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var __assign = (this && this.__assign) || function () {
	    __assign = Object.assign || function(t) {
	        for (var s, i = 1, n = arguments.length; i < n; i++) {
	            s = arguments[i];
	            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
	                t[p] = s[p];
	        }
	        return t;
	    };
	    return __assign.apply(this, arguments);
	};
	var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
	    return new (P || (P = Promise))(function (resolve, reject) {
	        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
	        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
	        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
	        step((generator = generator.apply(thisArg, _arguments || [])).next());
	    });
	};
	var __generator = (this && this.__generator) || function (thisArg, body) {
	    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
	    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
	    function verb(n) { return function (v) { return step([n, v]); }; }
	    function step(op) {
	        if (f) throw new TypeError("Generator is already executing.");
	        while (_) try {
	            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
	            if (y = 0, t) op = [op[0] & 2, t.value];
	            switch (op[0]) {
	                case 0: case 1: t = op; break;
	                case 4: _.label++; return { value: op[1], done: false };
	                case 5: _.label++; y = op[1]; op = [0]; continue;
	                case 7: op = _.ops.pop(); _.trys.pop(); continue;
	                default:
	                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
	                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
	                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
	                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
	                    if (t[2]) _.ops.pop();
	                    _.trys.pop(); continue;
	            }
	            op = body.call(thisArg, _);
	        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
	        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
	    }
	};
	var __importDefault = (this && this.__importDefault) || function (mod) {
	    return (mod && mod.__esModule) ? mod : { "default": mod };
	};
	Object.defineProperty(exports, "__esModule", { value: true });
	// (C) 2020 GoodData Corporation
	var metadata_1 = __webpack_require__(100);
	var user_1 = __webpack_require__(93);
	var cloneDeepWith_1 = __importDefault(__webpack_require__(207));
	var isEmpty_1 = __importDefault(__webpack_require__(117));
	var omit_1 = __importDefault(__webpack_require__(119));
	function createTranslator(kpiMap, visWidgetMap) {
	    return function (oldUri) {
	        var kpiMatch = kpiMap.get(oldUri);
	        var visWidgetMatch = visWidgetMap.get(oldUri);
	        if (kpiMatch) {
	            return kpiMatch;
	        }
	        else if (visWidgetMatch) {
	            return visWidgetMatch;
	        }
	        else {
	            return oldUri;
	        }
	    };
	}
	exports.createTranslator = createTranslator;
	/**
	 * Updates content of the dashboard
	 *
	 * @param {string} dashboardUri uri of dashboard
	 * @param {UriTranslator} uriTranslator gets updated widgets and kpis uri
	 * @param {string} filterContext updated filter context uri
	 * @experimental
	 */
	function updateContent(analyticalDashboard, uriTranslator, filterContext) {
	    return cloneDeepWith_1.default(__assign({}, analyticalDashboard.content, { filterContext: filterContext, widgets: analyticalDashboard.content.widgets.map(function (uri) {
	            return uriTranslator(uri);
	        }) }), function (value) {
	        var uri = value.uri;
	        if (!uri) {
	            return;
	        }
	        return __assign({}, value, { uri: uriTranslator(uri) });
	    });
	}
	exports.updateContent = updateContent;
	var MetadataModuleExt = /** @class */ (function () {
	    function MetadataModuleExt(xhr) {
	        this.xhr = xhr;
	        this.metadataModule = new metadata_1.MetadataModule(xhr);
	        this.userModule = new user_1.UserModule(xhr);
	    }
	    /**
	     * @param {string} projectId id of the project
	     * @param {string} dashboardUri uri of the dashboard
	     * @param {ICopyDashboardOptions} options object with options:
	     *          - default {} dashboard is cloned with new kpi reference and visualization widget is cloned with new
	     *              visualization object reference
	     *          - copyKpi {boolean} choose whether dashboard is cloned with new Kpi reference
	     *          - copyVisObj {boolean} choose whether visualization widget is cloned with new visualization object reference
	     *          - name {string} optional - choose name, default value is "Copy of (old title of the dashboard)"
	     * @returns {string} uri of cloned dashboard
	     * @experimental
	     */
	    MetadataModuleExt.prototype.saveDashboardAs = function (projectId, dashboardUri, options) {
	        return __awaiter(this, void 0, Promise, function () {
	            var objectsFromDashboard, dashboardDetails, analyticalDashboard, allCreatedObjUris, visWidgetUris, filterContext, kpiMap, visWidgetMap, translator, updatedContent, dashboardTitle, duplicateDashboard, duplicateDashboardUri, err_1;
	            var _this = this;
	            return __generator(this, function (_a) {
	                switch (_a.label) {
	                    case 0: return [4 /*yield*/, this.getObjectsFromDashboard(projectId, dashboardUri)];
	                    case 1:
	                        objectsFromDashboard = _a.sent();
	                        return [4 /*yield*/, this.metadataModule.getObjectDetails(dashboardUri)];
	                    case 2:
	                        dashboardDetails = _a.sent();
	                        analyticalDashboard = dashboardDetails.analyticalDashboard;
	                        allCreatedObjUris = [];
	                        visWidgetUris = [];
	                        _a.label = 3;
	                    case 3:
	                        _a.trys.push([3, 8, , 14]);
	                        return [4 /*yield*/, this.duplicateFilterContext(projectId, objectsFromDashboard)];
	                    case 4:
	                        filterContext = _a.sent();
	                        allCreatedObjUris.push(filterContext);
	                        return [4 /*yield*/, this.duplicateOrKeepKpis(projectId, objectsFromDashboard, options)];
	                    case 5:
	                        kpiMap = _a.sent();
	                        if (this.shouldCopyKpi(options)) {
	                            allCreatedObjUris.push.apply(allCreatedObjUris, Array.from(kpiMap.values()));
	                        }
	                        return [4 /*yield*/, this.duplicateWidgets(projectId, objectsFromDashboard, options)];
	                    case 6:
	                        visWidgetMap = _a.sent();
	                        visWidgetUris.push.apply(visWidgetUris, Array.from(visWidgetMap.values()));
	                        translator = createTranslator(kpiMap, visWidgetMap);
	                        updatedContent = updateContent(analyticalDashboard, translator, filterContext);
	                        dashboardTitle = this.getDashboardName(analyticalDashboard.meta.title, options.name);
	                        duplicateDashboard = __assign({}, dashboardDetails, { analyticalDashboard: __assign({}, dashboardDetails.analyticalDashboard, { content: this.getDashboardDetailObject(updatedContent, filterContext), meta: __assign({}, omit_1.default(dashboardDetails.analyticalDashboard.meta, [
	                                    "identifier",
	                                    "uri",
	                                    "author",
	                                    "created",
	                                    "updated",
	                                    "contributor",
	                                ]), { title: dashboardTitle }) }) });
	                        return [4 /*yield*/, this.metadataModule.createObject(projectId, duplicateDashboard)];
	                    case 7:
	                        duplicateDashboardUri = (_a.sent()).analyticalDashboard.meta.uri;
	                        return [2 /*return*/, duplicateDashboardUri];
	                    case 8:
	                        err_1 = _a.sent();
	                        if (!this.shouldCopyVisObj(options)) return [3 /*break*/, 10];
	                        return [4 /*yield*/, Promise.all(visWidgetUris.map(function (uri) { return _this.cascadingDelete(projectId, uri); }))];
	                    case 9:
	                        _a.sent();
	                        return [3 /*break*/, 12];
	                    case 10: return [4 /*yield*/, Promise.all(visWidgetUris.map(function (uri) { return _this.metadataModule.deleteObject(uri); }))];
	                    case 11:
	                        _a.sent();
	                        _a.label = 12;
	                    case 12: return [4 /*yield*/, Promise.all(allCreatedObjUris.map(function (uri) { return _this.cascadingDelete(projectId, uri); }))];
	                    case 13:
	                        _a.sent();
	                        return [2 /*return*/, dashboardUri];
	                    case 14: return [2 /*return*/];
	                }
	            });
	        });
	    };
	    /**
	     * Deletes dashboard and its objects
	     * (only the author of the dashboard can delete the dashboard and its objects)
	     *
	     * @method deleteAllObjects
	     * @param {string} projectId Project identifier
	     * @param {string} dashboardUri Uri of a dashboard to be deleted
	     * @experimental
	     */
	    MetadataModuleExt.prototype.cascadingDelete = function (projectID, dashboardUri) {
	        return __awaiter(this, void 0, Promise, function () {
	            var objects, currentUser, objectsToBeDeleted;
	            return __generator(this, function (_a) {
	                switch (_a.label) {
	                    case 0: return [4 /*yield*/, this.metadataModule.getObjectUsing(projectID, dashboardUri)];
	                    case 1:
	                        objects = _a.sent();
	                        return [4 /*yield*/, this.userModule.getAccountInfo()];
	                    case 2:
	                        currentUser = (_a.sent()).profileUri;
	                        objectsToBeDeleted = objects
	                            .filter(function (object) { return object.author === currentUser; })
	                            .map(function (object) {
	                            return object.link;
	                        });
	                        return [2 /*return*/, this.xhr.post("/gdc/md/" + projectID + "/objects/delete", {
	                                body: {
	                                    delete: {
	                                        items: [dashboardUri].concat(objectsToBeDeleted),
	                                        mode: "cascade",
	                                    },
	                                },
	                            })];
	                }
	            });
	        });
	    };
	    MetadataModuleExt.prototype.getDashboardDetailObject = function (updatedContent, filterContext) {
	        var layout = updatedContent.layout;
	        return __assign({}, updatedContent, { filterContext: filterContext, widgets: updatedContent.widgets.slice() }, (isEmpty_1.default(layout) ? {} : { layout: layout }));
	    };
	    MetadataModuleExt.prototype.getDashboardName = function (originalName, newName) {
	        if (newName !== undefined) {
	            return newName;
	        }
	        return "Copy of " + originalName;
	    };
	    MetadataModuleExt.prototype.duplicateOrKeepKpis = function (projectId, objsFromDashboard, options) {
	        return __awaiter(this, void 0, Promise, function () {
	            var uriMap;
	            var _this = this;
	            return __generator(this, function (_a) {
	                switch (_a.label) {
	                    case 0:
	                        uriMap = new Map();
	                        if (!this.shouldCopyKpi(options)) return [3 /*break*/, 2];
	                        return [4 /*yield*/, Promise.all(objsFromDashboard
	                                .filter(function (obj) { return _this.unwrapObj(obj).meta.category === "kpi"; })
	                                .map(function (kpiWidget) { return __awaiter(_this, void 0, void 0, function () {
	                                var kpi, newUriKpiObj;
	                                return __generator(this, function (_a) {
	                                    switch (_a.label) {
	                                        case 0:
	                                            kpi = kpiWidget.kpi;
	                                            return [4 /*yield*/, this.metadataModule.createObject(projectId, kpiWidget)];
	                                        case 1:
	                                            newUriKpiObj = (_a.sent()).kpi.meta.uri;
	                                            uriMap.set(kpi.meta.uri, newUriKpiObj);
	                                            return [2 /*return*/];
	                                    }
	                                });
	                            }); }))];
	                    case 1:
	                        _a.sent();
	                        _a.label = 2;
	                    case 2: return [2 /*return*/, uriMap];
	                }
	            });
	        });
	    };
	    MetadataModuleExt.prototype.duplicateWidgets = function (projectId, objsFromDashboard, options) {
	        return __awaiter(this, void 0, Promise, function () {
	            var uriMap;
	            var _this = this;
	            return __generator(this, function (_a) {
	                switch (_a.label) {
	                    case 0:
	                        uriMap = new Map();
	                        return [4 /*yield*/, Promise.all(objsFromDashboard
	                                .filter(function (obj) { return _this.unwrapObj(obj).meta.category === "visualizationWidget"; })
	                                .map(function (visWidget) { return __awaiter(_this, void 0, void 0, function () {
	                                return __generator(this, function (_a) {
	                                    return [2 /*return*/, this.createAndUpdateWidgets(projectId, visWidget, options, uriMap)];
	                                });
	                            }); }))];
	                    case 1:
	                        _a.sent();
	                        return [2 /*return*/, uriMap];
	                }
	            });
	        });
	    };
	    MetadataModuleExt.prototype.createAndUpdateWidgets = function (projectId, visWidget, options, uriMap) {
	        return __awaiter(this, void 0, Promise, function () {
	            var visualizationWidget, visObj, newUriVisObj, updatedVisWidget, visUri, visualizationWidget_1;
	            return __generator(this, function (_a) {
	                switch (_a.label) {
	                    case 0:
	                        visualizationWidget = visWidget.visualizationWidget;
	                        if (!this.shouldCopyVisObj(options)) return [3 /*break*/, 4];
	                        return [4 /*yield*/, this.metadataModule.getObjectDetails(visualizationWidget.content.visualization)];
	                    case 1:
	                        visObj = _a.sent();
	                        return [4 /*yield*/, this.metadataModule.createObject(projectId, visObj)];
	                    case 2:
	                        newUriVisObj = (_a.sent())
	                            .visualizationObject.meta.uri;
	                        updatedVisWidget = __assign({}, visWidget, { visualizationWidget: __assign({}, visWidget.visualizationWidget, { content: __assign({}, visWidget.visualizationWidget.content, { visualization: newUriVisObj }) }) });
	                        return [4 /*yield*/, this.metadataModule.createObject(projectId, updatedVisWidget)];
	                    case 3:
	                        visUri = (_a.sent())
	                            .visualizationWidget.meta.uri;
	                        uriMap.set(visualizationWidget.meta.uri, visUri);
	                        return [3 /*break*/, 6];
	                    case 4: return [4 /*yield*/, this.metadataModule.createObject(projectId, visWidget)];
	                    case 5:
	                        visualizationWidget_1 = (_a.sent()).visualizationWidget;
	                        uriMap.set(visWidget.visualizationWidget.meta.uri, visualizationWidget_1.meta.uri);
	                        _a.label = 6;
	                    case 6: return [2 /*return*/];
	                }
	            });
	        });
	    };
	    MetadataModuleExt.prototype.duplicateFilterContext = function (projectId, objsFromDashboard) {
	        return __awaiter(this, void 0, Promise, function () {
	            var filterContext;
	            var _this = this;
	            return __generator(this, function (_a) {
	                switch (_a.label) {
	                    case 0: return [4 /*yield*/, this.metadataModule.createObject(projectId, objsFromDashboard.filter(function (obj) { return _this.unwrapObj(obj).meta.category === "filterContext"; })[0])];
	                    case 1:
	                        filterContext = (_a.sent()).filterContext;
	                        return [2 /*return*/, filterContext.meta.uri];
	                }
	            });
	        });
	    };
	    MetadataModuleExt.prototype.getObjectsFromDashboard = function (projectId, dashboardUri) {
	        return __awaiter(this, void 0, Promise, function () {
	            var uris;
	            return __generator(this, function (_a) {
	                switch (_a.label) {
	                    case 0: return [4 /*yield*/, this.getObjectsUrisInDashboard(projectId, dashboardUri)];
	                    case 1:
	                        uris = _a.sent();
	                        return [2 /*return*/, this.metadataModule.getObjects(projectId, uris)];
	                }
	            });
	        });
	    };
	    MetadataModuleExt.prototype.getObjectsUrisInDashboard = function (projectId, dashboardUri) {
	        return __awaiter(this, void 0, Promise, function () {
	            return __generator(this, function (_a) {
	                switch (_a.label) {
	                    case 0: return [4 /*yield*/, this.metadataModule.getObjectUsing(projectId, dashboardUri, {
	                            types: ["kpi", "visualizationWidget", "filterContext"],
	                        })];
	                    case 1: return [2 /*return*/, (_a.sent()).map(function (obj) {
	                            return obj.link;
	                        })];
	                }
	            });
	        });
	    };
	    MetadataModuleExt.prototype.unwrapObj = function (obj) {
	        return obj[Object.keys(obj)[0]];
	    };
	    MetadataModuleExt.prototype.shouldCopyVisObj = function (options) {
	        return !!(options.copyVisObj || typeof options.copyVisObj === "undefined");
	    };
	    MetadataModuleExt.prototype.shouldCopyKpi = function (options) {
	        return !!(options.copyKpi || typeof options.copyKpi === "undefined");
	    };
	    return MetadataModuleExt;
	}());
	exports.MetadataModuleExt = MetadataModuleExt;


/***/ }),
/* 207 */
/***/ (function(module, exports, __webpack_require__) {

	var baseClone = __webpack_require__(5);

	/** Used to compose bitmasks for cloning. */
	var CLONE_DEEP_FLAG = 1,
	    CLONE_SYMBOLS_FLAG = 4;

	/**
	 * This method is like `_.cloneWith` except that it recursively clones `value`.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to recursively clone.
	 * @param {Function} [customizer] The function to customize cloning.
	 * @returns {*} Returns the deep cloned value.
	 * @see _.cloneWith
	 * @example
	 *
	 * function customizer(value) {
	 *   if (_.isElement(value)) {
	 *     return value.cloneNode(true);
	 *   }
	 * }
	 *
	 * var el = _.cloneDeepWith(document.body, customizer);
	 *
	 * console.log(el === document.body);
	 * // => false
	 * console.log(el.nodeName);
	 * // => 'BODY'
	 * console.log(el.childNodes.length);
	 * // => 20
	 */
	function cloneDeepWith(value, customizer) {
	  customizer = typeof customizer == 'function' ? customizer : undefined;
	  return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG, customizer);
	}

	module.exports = cloneDeepWith;


/***/ }),
/* 208 */
/***/ (function(module, exports) {

	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var BootstrapModule = /** @class */ (function () {
	    function BootstrapModule(xhr) {
	        this.xhr = xhr;
	    }
	    /**
	     * Returns information about currently logged in user from bootstrap resource
	     * @method getBootstrapData
	     */
	    BootstrapModule.prototype.getBootstrapData = function () {
	        return this.xhr.get("/gdc/app/account/bootstrap").then(function (result) { return result.getData(); });
	    };
	    /**
	     * Returns the mapboxToken for using GeoPushpinChart
	     * @method getMapboxToken
	     * @param {any} bootstrapData - data from bootstrap resource
	     */
	    BootstrapModule.prototype.getMapboxToken = function (bootstrapData) {
	        return bootstrapData.bootstrapResource.current.mapboxToken || null;
	    };
	    return BootstrapModule;
	}());
	exports.BootstrapModule = BootstrapModule;


/***/ }),
/* 209 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var __importStar = (this && this.__importStar) || function (mod) {
	    if (mod && mod.__esModule) return mod;
	    var result = {};
	    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
	    result["default"] = mod;
	    return result;
	};
	Object.defineProperty(exports, "__esModule", { value: true });
	// (C) 2007-2018 GoodData Corporation
	var Header = __importStar(__webpack_require__(210));
	exports.Header = Header;
	var DataSourceUtils = __importStar(__webpack_require__(211));
	exports.DataSourceUtils = DataSourceUtils;
	var DataSource = __importStar(__webpack_require__(212));
	exports.DataSource = DataSource;
	var Filters = __importStar(__webpack_require__(214));
	exports.Filters = Filters;
	var Uri = __importStar(__webpack_require__(135));
	exports.Uri = Uri;
	var async_1 = __webpack_require__(215);
	exports.createSubject = async_1.createSubject;
	exports.ISubject = async_1.ISubject;
	var toAfmResultSpec_1 = __webpack_require__(247);
	exports.toAfmResultSpec = toAfmResultSpec_1.toAfmResultSpec;
	var ResultSpecUtils = __importStar(__webpack_require__(252));
	exports.ResultSpecUtils = ResultSpecUtils;
	var AfmUtils = __importStar(__webpack_require__(253));
	exports.AfmUtils = AfmUtils;
	var DataTable_1 = __webpack_require__(254);
	exports.DataTable = DataTable_1.DataTable;
	var DummyAdapter_1 = __webpack_require__(262);
	exports.DummyAdapter = DummyAdapter_1.DummyAdapter;
	var ExecuteAfmAdapter_1 = __webpack_require__(264);
	exports.ExecuteAfmAdapter = ExecuteAfmAdapter_1.ExecuteAfmAdapter;
	var UriAdapter_1 = __webpack_require__(265);
	exports.UriAdapter = UriAdapter_1.UriAdapter;
	var Adapter_1 = __webpack_require__(266);
	exports.IAdapter = Adapter_1.IAdapter;


/***/ }),
/* 210 */
/***/ (function(module, exports) {

	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });


/***/ }),
/* 211 */
/***/ (function(module, exports) {

	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	function dataSourcesMatch(first, second) {
	    var firstFingerprint = first ? first.getFingerprint() : null;
	    var secondFingerprint = second ? second.getFingerprint() : null;
	    return firstFingerprint === secondFingerprint;
	}
	exports.dataSourcesMatch = dataSourcesMatch;


/***/ }),
/* 212 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var __importDefault = (this && this.__importDefault) || function (mod) {
	    return (mod && mod.__esModule) ? mod : { "default": mod };
	};
	Object.defineProperty(exports, "__esModule", { value: true });
	var json_stable_stringify_1 = __importDefault(__webpack_require__(126));
	var DataSource_1 = __webpack_require__(213);
	exports.IDataSource = DataSource_1.IDataSource;
	var execute_afm_1 = __webpack_require__(184);
	var DataSource = /** @class */ (function () {
	    function DataSource(execFactory, afm, fingerprint, responseFactory, resultFactory) {
	        this.execFactory = execFactory;
	        this.afm = afm;
	        this.fingerprint = fingerprint;
	        this.responseFactory = responseFactory;
	        this.resultFactory = resultFactory;
	        this.executionPromises = {};
	    }
	    DataSource.prototype.getData = function (resultSpec) {
	        return this.execFactory(resultSpec);
	    };
	    DataSource.prototype.getPage = function (resultSpec, limit, offset) {
	        var _this = this;
	        if (limit === void 0) { limit = []; }
	        if (offset === void 0) { offset = []; }
	        var resultSpecFingerprint = json_stable_stringify_1.default(resultSpec);
	        if (!this.responseFactory) {
	            throw new Error("Missing responseFactory!");
	        }
	        if (!this.executionPromises[resultSpecFingerprint]) {
	            this.executionPromises[resultSpecFingerprint] = this.responseFactory(resultSpec);
	        }
	        return this.executionPromises[resultSpecFingerprint].then(function (executionResponse) {
	            if (!_this.resultFactory) {
	                throw new Error("Missing resultFactory!");
	            }
	            var safeOffset = offset.map(function (offsetItem) {
	                if (offsetItem === void 0) { offsetItem = 0; }
	                return offsetItem;
	            });
	            var safeLimit = limit.map(function (limitItem) {
	                if (limitItem === void 0) { limitItem = execute_afm_1.DEFAULT_LIMIT; }
	                var safeLimitItem = Math.min(limitItem, execute_afm_1.DEFAULT_LIMIT);
	                if (safeLimitItem < limitItem) {
	                    // tslint:disable-next-line:no-console
	                    console.warn("The maximum limit per page is " + execute_afm_1.DEFAULT_LIMIT);
	                }
	                return safeLimitItem;
	            });
	            return _this.resultFactory(executionResponse.links.executionResult, safeLimit, safeOffset).then(function (executionResult) { return ({
	                executionResult: executionResult,
	                executionResponse: executionResponse,
	            }); });
	        });
	    };
	    DataSource.prototype.getAfm = function () {
	        return this.afm;
	    };
	    DataSource.prototype.getFingerprint = function () {
	        return this.fingerprint ? this.fingerprint : json_stable_stringify_1.default(this.afm);
	    };
	    return DataSource;
	}());
	exports.DataSource = DataSource;


/***/ }),
/* 213 */
/***/ (function(module, exports) {

	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });


/***/ }),
/* 214 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var __assign = (this && this.__assign) || function () {
	    __assign = Object.assign || function(t) {
	        for (var s, i = 1, n = arguments.length; i < n; i++) {
	            s = arguments[i];
	            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
	                t[p] = s[p];
	        }
	        return t;
	    };
	    return __assign.apply(this, arguments);
	};
	var __importDefault = (this && this.__importDefault) || function (mod) {
	    return (mod && mod.__esModule) ? mod : { "default": mod };
	};
	Object.defineProperty(exports, "__esModule", { value: true });
	// (C) 2007-2018 GoodData Corporation
	var cloneDeep_1 = __importDefault(__webpack_require__(4));
	var isEmpty_1 = __importDefault(__webpack_require__(117));
	var typings_1 = __webpack_require__(137);
	var isDateFilter = typings_1.AFM.isDateFilter;
	var isNegativeAttributeFilter = typings_1.AFM.isNegativeAttributeFilter;
	var isPositiveAttributeFilter = typings_1.AFM.isPositiveAttributeFilter;
	/**
	 * Tests whether attribute elements are empty of not.
	 *
	 * @param elements one of the acceptable attribute element forms
	 */
	function isEmptyAttributeElements(elements) {
	    return isEmpty_1.default(elements);
	}
	exports.isEmptyAttributeElements = isEmptyAttributeElements;
	/**
	 * Tests whether filter if semantically empty - e.g. it will not have any effect on the results and can thus
	 * be discarded.
	 *
	 * @param filter any acceptable AFM filter
	 */
	function isEmptyFilter(filter) {
	    if (isPositiveAttributeFilter(filter)) {
	        return isEmptyAttributeElements(filter.positiveAttributeFilter.in);
	    }
	    else if (isNegativeAttributeFilter(filter)) {
	        return isEmptyAttributeElements(filter.negativeAttributeFilter.notIn);
	    }
	    // expression filters were always considered empty
	    return !isDateFilter(filter);
	}
	exports.isEmptyFilter = isEmptyFilter;
	/**
	 * Tests whether filter is semantically not empty - e.g. it will have some effect on the results.
	 *
	 * @param filter any acceptable AFM filter
	 * @deprecated use isEmptyFilter instead
	 */
	function isNotEmptyFilter(filter) {
	    return !isEmptyFilter(filter);
	}
	exports.isNotEmptyFilter = isNotEmptyFilter;
	/**
	 * Merges new filters into existing AFM. This essentially concatenates/appends new filters at the end of the
	 * existing filter list defined in the AFM and then filters out any semantically empty, no-effect filters.
	 *
	 * This function is immutable, it constructs new instance of AFM.
	 *
	 * @param afm afm to merge filters into
	 * @param filters filters to merge
	 * @returns new instance of AFM.
	 */
	function mergeFilters(afm, filters) {
	    var cloned = cloneDeep_1.default(afm);
	    return __assign({}, cloned, { filters: (cloned.filters || []).concat(filters).filter(isNotEmptyFilter) });
	}
	exports.mergeFilters = mergeFilters;


/***/ }),
/* 215 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var __importDefault = (this && this.__importDefault) || function (mod) {
	    return (mod && mod.__esModule) ? mod : { "default": mod };
	};
	Object.defineProperty(exports, "__esModule", { value: true });
	// (C) 2007-2018 GoodData Corporation
	var identity_1 = __importDefault(__webpack_require__(65));
	var Subject_1 = __webpack_require__(216);
	var Subscription_1 = __webpack_require__(222);
	exports.Subscription = Subscription_1.Subscription;
	__webpack_require__(235);
	__webpack_require__(244);
	/**
	 * Creates infinite stream
	 * Usage:
	 * const subject = createSubject(
	 *      (result) => console.log('Success:', result),
	 *      (error) => console.error('Error:', error)
	 * );
	 * subject.next(promise1);
	 * subject.next(promise2);
	 *
	 * subject.unsubscribe();
	 *
	 * @method createSubject
	 * @param {StreamSuccessHandler<T>} successHandler
	 * @param {StreamErrorHandler} errorHandler
	 * @return {ISubject<Promise<T>>}
	 */
	function createSubject(successHandler, errorHandler) {
	    var subject = new Subject_1.Subject();
	    var subscription = subject
	        // This ensures we get last added promise
	        .switchMap(identity_1.default)
	        // Streams are closed on error by default so we need this workaround
	        .catch(function (error, caught) {
	        errorHandler(error); // handle error
	        return caught; // stream continue
	    })
	        .subscribe(successHandler);
	    var wrapper = {
	        next: function (promise) {
	            subject.next(promise);
	        },
	        unsubscribe: function () {
	            subscription.unsubscribe();
	            subject.unsubscribe();
	        },
	    };
	    return wrapper;
	}
	exports.createSubject = createSubject;


/***/ }),
/* 216 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var Observable_1 = __webpack_require__(217);
	var Subscriber_1 = __webpack_require__(220);
	var Subscription_1 = __webpack_require__(222);
	var ObjectUnsubscribedError_1 = __webpack_require__(233);
	var SubjectSubscription_1 = __webpack_require__(234);
	var rxSubscriber_1 = __webpack_require__(229);
	/**
	 * @class SubjectSubscriber<T>
	 */
	var SubjectSubscriber = (function (_super) {
	    __extends(SubjectSubscriber, _super);
	    function SubjectSubscriber(destination) {
	        _super.call(this, destination);
	        this.destination = destination;
	    }
	    return SubjectSubscriber;
	}(Subscriber_1.Subscriber));
	exports.SubjectSubscriber = SubjectSubscriber;
	/**
	 * @class Subject<T>
	 */
	var Subject = (function (_super) {
	    __extends(Subject, _super);
	    function Subject() {
	        _super.call(this);
	        this.observers = [];
	        this.closed = false;
	        this.isStopped = false;
	        this.hasError = false;
	        this.thrownError = null;
	    }
	    Subject.prototype[rxSubscriber_1.rxSubscriber] = function () {
	        return new SubjectSubscriber(this);
	    };
	    Subject.prototype.lift = function (operator) {
	        var subject = new AnonymousSubject(this, this);
	        subject.operator = operator;
	        return subject;
	    };
	    Subject.prototype.next = function (value) {
	        if (this.closed) {
	            throw new ObjectUnsubscribedError_1.ObjectUnsubscribedError();
	        }
	        if (!this.isStopped) {
	            var observers = this.observers;
	            var len = observers.length;
	            var copy = observers.slice();
	            for (var i = 0; i < len; i++) {
	                copy[i].next(value);
	            }
	        }
	    };
	    Subject.prototype.error = function (err) {
	        if (this.closed) {
	            throw new ObjectUnsubscribedError_1.ObjectUnsubscribedError();
	        }
	        this.hasError = true;
	        this.thrownError = err;
	        this.isStopped = true;
	        var observers = this.observers;
	        var len = observers.length;
	        var copy = observers.slice();
	        for (var i = 0; i < len; i++) {
	            copy[i].error(err);
	        }
	        this.observers.length = 0;
	    };
	    Subject.prototype.complete = function () {
	        if (this.closed) {
	            throw new ObjectUnsubscribedError_1.ObjectUnsubscribedError();
	        }
	        this.isStopped = true;
	        var observers = this.observers;
	        var len = observers.length;
	        var copy = observers.slice();
	        for (var i = 0; i < len; i++) {
	            copy[i].complete();
	        }
	        this.observers.length = 0;
	    };
	    Subject.prototype.unsubscribe = function () {
	        this.isStopped = true;
	        this.closed = true;
	        this.observers = null;
	    };
	    Subject.prototype._trySubscribe = function (subscriber) {
	        if (this.closed) {
	            throw new ObjectUnsubscribedError_1.ObjectUnsubscribedError();
	        }
	        else {
	            return _super.prototype._trySubscribe.call(this, subscriber);
	        }
	    };
	    /** @deprecated internal use only */ Subject.prototype._subscribe = function (subscriber) {
	        if (this.closed) {
	            throw new ObjectUnsubscribedError_1.ObjectUnsubscribedError();
	        }
	        else if (this.hasError) {
	            subscriber.error(this.thrownError);
	            return Subscription_1.Subscription.EMPTY;
	        }
	        else if (this.isStopped) {
	            subscriber.complete();
	            return Subscription_1.Subscription.EMPTY;
	        }
	        else {
	            this.observers.push(subscriber);
	            return new SubjectSubscription_1.SubjectSubscription(this, subscriber);
	        }
	    };
	    Subject.prototype.asObservable = function () {
	        var observable = new Observable_1.Observable();
	        observable.source = this;
	        return observable;
	    };
	    Subject.create = function (destination, source) {
	        return new AnonymousSubject(destination, source);
	    };
	    return Subject;
	}(Observable_1.Observable));
	exports.Subject = Subject;
	/**
	 * @class AnonymousSubject<T>
	 */
	var AnonymousSubject = (function (_super) {
	    __extends(AnonymousSubject, _super);
	    function AnonymousSubject(destination, source) {
	        _super.call(this);
	        this.destination = destination;
	        this.source = source;
	    }
	    AnonymousSubject.prototype.next = function (value) {
	        var destination = this.destination;
	        if (destination && destination.next) {
	            destination.next(value);
	        }
	    };
	    AnonymousSubject.prototype.error = function (err) {
	        var destination = this.destination;
	        if (destination && destination.error) {
	            this.destination.error(err);
	        }
	    };
	    AnonymousSubject.prototype.complete = function () {
	        var destination = this.destination;
	        if (destination && destination.complete) {
	            this.destination.complete();
	        }
	    };
	    /** @deprecated internal use only */ AnonymousSubject.prototype._subscribe = function (subscriber) {
	        var source = this.source;
	        if (source) {
	            return this.source.subscribe(subscriber);
	        }
	        else {
	            return Subscription_1.Subscription.EMPTY;
	        }
	    };
	    return AnonymousSubject;
	}(Subject));
	exports.AnonymousSubject = AnonymousSubject;
	//# sourceMappingURL=Subject.js.map

/***/ }),
/* 217 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var root_1 = __webpack_require__(218);
	var toSubscriber_1 = __webpack_require__(219);
	var observable_1 = __webpack_require__(230);
	var pipe_1 = __webpack_require__(231);
	/**
	 * A representation of any set of values over any amount of time. This is the most basic building block
	 * of RxJS.
	 *
	 * @class Observable<T>
	 */
	var Observable = (function () {
	    /**
	     * @constructor
	     * @param {Function} subscribe the function that is called when the Observable is
	     * initially subscribed to. This function is given a Subscriber, to which new values
	     * can be `next`ed, or an `error` method can be called to raise an error, or
	     * `complete` can be called to notify of a successful completion.
	     */
	    function Observable(subscribe) {
	        this._isScalar = false;
	        if (subscribe) {
	            this._subscribe = subscribe;
	        }
	    }
	    /**
	     * Creates a new Observable, with this Observable as the source, and the passed
	     * operator defined as the new observable's operator.
	     * @method lift
	     * @param {Operator} operator the operator defining the operation to take on the observable
	     * @return {Observable} a new observable with the Operator applied
	     */
	    Observable.prototype.lift = function (operator) {
	        var observable = new Observable();
	        observable.source = this;
	        observable.operator = operator;
	        return observable;
	    };
	    /**
	     * Invokes an execution of an Observable and registers Observer handlers for notifications it will emit.
	     *
	     * <span class="informal">Use it when you have all these Observables, but still nothing is happening.</span>
	     *
	     * `subscribe` is not a regular operator, but a method that calls Observable's internal `subscribe` function. It
	     * might be for example a function that you passed to a {@link create} static factory, but most of the time it is
	     * a library implementation, which defines what and when will be emitted by an Observable. This means that calling
	     * `subscribe` is actually the moment when Observable starts its work, not when it is created, as it is often
	     * thought.
	     *
	     * Apart from starting the execution of an Observable, this method allows you to listen for values
	     * that an Observable emits, as well as for when it completes or errors. You can achieve this in two
	     * following ways.
	     *
	     * The first way is creating an object that implements {@link Observer} interface. It should have methods
	     * defined by that interface, but note that it should be just a regular JavaScript object, which you can create
	     * yourself in any way you want (ES6 class, classic function constructor, object literal etc.). In particular do
	     * not attempt to use any RxJS implementation details to create Observers - you don't need them. Remember also
	     * that your object does not have to implement all methods. If you find yourself creating a method that doesn't
	     * do anything, you can simply omit it. Note however, that if `error` method is not provided, all errors will
	     * be left uncaught.
	     *
	     * The second way is to give up on Observer object altogether and simply provide callback functions in place of its methods.
	     * This means you can provide three functions as arguments to `subscribe`, where first function is equivalent
	     * of a `next` method, second of an `error` method and third of a `complete` method. Just as in case of Observer,
	     * if you do not need to listen for something, you can omit a function, preferably by passing `undefined` or `null`,
	     * since `subscribe` recognizes these functions by where they were placed in function call. When it comes
	     * to `error` function, just as before, if not provided, errors emitted by an Observable will be thrown.
	     *
	     * Whatever style of calling `subscribe` you use, in both cases it returns a Subscription object.
	     * This object allows you to call `unsubscribe` on it, which in turn will stop work that an Observable does and will clean
	     * up all resources that an Observable used. Note that cancelling a subscription will not call `complete` callback
	     * provided to `subscribe` function, which is reserved for a regular completion signal that comes from an Observable.
	     *
	     * Remember that callbacks provided to `subscribe` are not guaranteed to be called asynchronously.
	     * It is an Observable itself that decides when these functions will be called. For example {@link of}
	     * by default emits all its values synchronously. Always check documentation for how given Observable
	     * will behave when subscribed and if its default behavior can be modified with a {@link Scheduler}.
	     *
	     * @example <caption>Subscribe with an Observer</caption>
	     * const sumObserver = {
	     *   sum: 0,
	     *   next(value) {
	     *     console.log('Adding: ' + value);
	     *     this.sum = this.sum + value;
	     *   },
	     *   error() { // We actually could just remove this method,
	     *   },        // since we do not really care about errors right now.
	     *   complete() {
	     *     console.log('Sum equals: ' + this.sum);
	     *   }
	     * };
	     *
	     * Rx.Observable.of(1, 2, 3) // Synchronously emits 1, 2, 3 and then completes.
	     * .subscribe(sumObserver);
	     *
	     * // Logs:
	     * // "Adding: 1"
	     * // "Adding: 2"
	     * // "Adding: 3"
	     * // "Sum equals: 6"
	     *
	     *
	     * @example <caption>Subscribe with functions</caption>
	     * let sum = 0;
	     *
	     * Rx.Observable.of(1, 2, 3)
	     * .subscribe(
	     *   function(value) {
	     *     console.log('Adding: ' + value);
	     *     sum = sum + value;
	     *   },
	     *   undefined,
	     *   function() {
	     *     console.log('Sum equals: ' + sum);
	     *   }
	     * );
	     *
	     * // Logs:
	     * // "Adding: 1"
	     * // "Adding: 2"
	     * // "Adding: 3"
	     * // "Sum equals: 6"
	     *
	     *
	     * @example <caption>Cancel a subscription</caption>
	     * const subscription = Rx.Observable.interval(1000).subscribe(
	     *   num => console.log(num),
	     *   undefined,
	     *   () => console.log('completed!') // Will not be called, even
	     * );                                // when cancelling subscription
	     *
	     *
	     * setTimeout(() => {
	     *   subscription.unsubscribe();
	     *   console.log('unsubscribed!');
	     * }, 2500);
	     *
	     * // Logs:
	     * // 0 after 1s
	     * // 1 after 2s
	     * // "unsubscribed!" after 2.5s
	     *
	     *
	     * @param {Observer|Function} observerOrNext (optional) Either an observer with methods to be called,
	     *  or the first of three possible handlers, which is the handler for each value emitted from the subscribed
	     *  Observable.
	     * @param {Function} error (optional) A handler for a terminal event resulting from an error. If no error handler is provided,
	     *  the error will be thrown as unhandled.
	     * @param {Function} complete (optional) A handler for a terminal event resulting from successful completion.
	     * @return {ISubscription} a subscription reference to the registered handlers
	     * @method subscribe
	     */
	    Observable.prototype.subscribe = function (observerOrNext, error, complete) {
	        var operator = this.operator;
	        var sink = toSubscriber_1.toSubscriber(observerOrNext, error, complete);
	        if (operator) {
	            operator.call(sink, this.source);
	        }
	        else {
	            sink.add(this.source || !sink.syncErrorThrowable ? this._subscribe(sink) : this._trySubscribe(sink));
	        }
	        if (sink.syncErrorThrowable) {
	            sink.syncErrorThrowable = false;
	            if (sink.syncErrorThrown) {
	                throw sink.syncErrorValue;
	            }
	        }
	        return sink;
	    };
	    Observable.prototype._trySubscribe = function (sink) {
	        try {
	            return this._subscribe(sink);
	        }
	        catch (err) {
	            sink.syncErrorThrown = true;
	            sink.syncErrorValue = err;
	            sink.error(err);
	        }
	    };
	    /**
	     * @method forEach
	     * @param {Function} next a handler for each value emitted by the observable
	     * @param {PromiseConstructor} [PromiseCtor] a constructor function used to instantiate the Promise
	     * @return {Promise} a promise that either resolves on observable completion or
	     *  rejects with the handled error
	     */
	    Observable.prototype.forEach = function (next, PromiseCtor) {
	        var _this = this;
	        if (!PromiseCtor) {
	            if (root_1.root.Rx && root_1.root.Rx.config && root_1.root.Rx.config.Promise) {
	                PromiseCtor = root_1.root.Rx.config.Promise;
	            }
	            else if (root_1.root.Promise) {
	                PromiseCtor = root_1.root.Promise;
	            }
	        }
	        if (!PromiseCtor) {
	            throw new Error('no Promise impl found');
	        }
	        return new PromiseCtor(function (resolve, reject) {
	            // Must be declared in a separate statement to avoid a RefernceError when
	            // accessing subscription below in the closure due to Temporal Dead Zone.
	            var subscription;
	            subscription = _this.subscribe(function (value) {
	                if (subscription) {
	                    // if there is a subscription, then we can surmise
	                    // the next handling is asynchronous. Any errors thrown
	                    // need to be rejected explicitly and unsubscribe must be
	                    // called manually
	                    try {
	                        next(value);
	                    }
	                    catch (err) {
	                        reject(err);
	                        subscription.unsubscribe();
	                    }
	                }
	                else {
	                    // if there is NO subscription, then we're getting a nexted
	                    // value synchronously during subscription. We can just call it.
	                    // If it errors, Observable's `subscribe` will ensure the
	                    // unsubscription logic is called, then synchronously rethrow the error.
	                    // After that, Promise will trap the error and send it
	                    // down the rejection path.
	                    next(value);
	                }
	            }, reject, resolve);
	        });
	    };
	    /** @deprecated internal use only */ Observable.prototype._subscribe = function (subscriber) {
	        return this.source.subscribe(subscriber);
	    };
	    /**
	     * An interop point defined by the es7-observable spec https://github.com/zenparsing/es-observable
	     * @method Symbol.observable
	     * @return {Observable} this instance of the observable
	     */
	    Observable.prototype[observable_1.observable] = function () {
	        return this;
	    };
	    /* tslint:enable:max-line-length */
	    /**
	     * Used to stitch together functional operators into a chain.
	     * @method pipe
	     * @return {Observable} the Observable result of all of the operators having
	     * been called in the order they were passed in.
	     *
	     * @example
	     *
	     * import { map, filter, scan } from 'rxjs/operators';
	     *
	     * Rx.Observable.interval(1000)
	     *   .pipe(
	     *     filter(x => x % 2 === 0),
	     *     map(x => x + x),
	     *     scan((acc, x) => acc + x)
	     *   )
	     *   .subscribe(x => console.log(x))
	     */
	    Observable.prototype.pipe = function () {
	        var operations = [];
	        for (var _i = 0; _i < arguments.length; _i++) {
	            operations[_i - 0] = arguments[_i];
	        }
	        if (operations.length === 0) {
	            return this;
	        }
	        return pipe_1.pipeFromArray(operations)(this);
	    };
	    /* tslint:enable:max-line-length */
	    Observable.prototype.toPromise = function (PromiseCtor) {
	        var _this = this;
	        if (!PromiseCtor) {
	            if (root_1.root.Rx && root_1.root.Rx.config && root_1.root.Rx.config.Promise) {
	                PromiseCtor = root_1.root.Rx.config.Promise;
	            }
	            else if (root_1.root.Promise) {
	                PromiseCtor = root_1.root.Promise;
	            }
	        }
	        if (!PromiseCtor) {
	            throw new Error('no Promise impl found');
	        }
	        return new PromiseCtor(function (resolve, reject) {
	            var value;
	            _this.subscribe(function (x) { return value = x; }, function (err) { return reject(err); }, function () { return resolve(value); });
	        });
	    };
	    // HACK: Since TypeScript inherits static properties too, we have to
	    // fight against TypeScript here so Subject can have a different static create signature
	    /**
	     * Creates a new cold Observable by calling the Observable constructor
	     * @static true
	     * @owner Observable
	     * @method create
	     * @param {Function} subscribe? the subscriber function to be passed to the Observable constructor
	     * @return {Observable} a new cold observable
	     */
	    Observable.create = function (subscribe) {
	        return new Observable(subscribe);
	    };
	    return Observable;
	}());
	exports.Observable = Observable;
	//# sourceMappingURL=Observable.js.map

/***/ }),
/* 218 */
/***/ (function(module, exports) {

	/* WEBPACK VAR INJECTION */(function(global) {"use strict";
	// CommonJS / Node have global context exposed as "global" variable.
	// We don't want to include the whole node.d.ts this this compilation unit so we'll just fake
	// the global "global" var for now.
	var __window = typeof window !== 'undefined' && window;
	var __self = typeof self !== 'undefined' && typeof WorkerGlobalScope !== 'undefined' &&
	    self instanceof WorkerGlobalScope && self;
	var __global = typeof global !== 'undefined' && global;
	var _root = __window || __global || __self;
	exports.root = _root;
	// Workaround Closure Compiler restriction: The body of a goog.module cannot use throw.
	// This is needed when used with angular/tsickle which inserts a goog.module statement.
	// Wrap in IIFE
	(function () {
	    if (!_root) {
	        throw new Error('RxJS could not find any global context (window, self, global)');
	    }
	})();
	//# sourceMappingURL=root.js.map
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ }),
/* 219 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var Subscriber_1 = __webpack_require__(220);
	var rxSubscriber_1 = __webpack_require__(229);
	var Observer_1 = __webpack_require__(228);
	function toSubscriber(nextOrObserver, error, complete) {
	    if (nextOrObserver) {
	        if (nextOrObserver instanceof Subscriber_1.Subscriber) {
	            return nextOrObserver;
	        }
	        if (nextOrObserver[rxSubscriber_1.rxSubscriber]) {
	            return nextOrObserver[rxSubscriber_1.rxSubscriber]();
	        }
	    }
	    if (!nextOrObserver && !error && !complete) {
	        return new Subscriber_1.Subscriber(Observer_1.empty);
	    }
	    return new Subscriber_1.Subscriber(nextOrObserver, error, complete);
	}
	exports.toSubscriber = toSubscriber;
	//# sourceMappingURL=toSubscriber.js.map

/***/ }),
/* 220 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var isFunction_1 = __webpack_require__(221);
	var Subscription_1 = __webpack_require__(222);
	var Observer_1 = __webpack_require__(228);
	var rxSubscriber_1 = __webpack_require__(229);
	/**
	 * Implements the {@link Observer} interface and extends the
	 * {@link Subscription} class. While the {@link Observer} is the public API for
	 * consuming the values of an {@link Observable}, all Observers get converted to
	 * a Subscriber, in order to provide Subscription-like capabilities such as
	 * `unsubscribe`. Subscriber is a common type in RxJS, and crucial for
	 * implementing operators, but it is rarely used as a public API.
	 *
	 * @class Subscriber<T>
	 */
	var Subscriber = (function (_super) {
	    __extends(Subscriber, _super);
	    /**
	     * @param {Observer|function(value: T): void} [destinationOrNext] A partially
	     * defined Observer or a `next` callback function.
	     * @param {function(e: ?any): void} [error] The `error` callback of an
	     * Observer.
	     * @param {function(): void} [complete] The `complete` callback of an
	     * Observer.
	     */
	    function Subscriber(destinationOrNext, error, complete) {
	        _super.call(this);
	        this.syncErrorValue = null;
	        this.syncErrorThrown = false;
	        this.syncErrorThrowable = false;
	        this.isStopped = false;
	        switch (arguments.length) {
	            case 0:
	                this.destination = Observer_1.empty;
	                break;
	            case 1:
	                if (!destinationOrNext) {
	                    this.destination = Observer_1.empty;
	                    break;
	                }
	                if (typeof destinationOrNext === 'object') {
	                    // HACK(benlesh): To resolve an issue where Node users may have multiple
	                    // copies of rxjs in their node_modules directory.
	                    if (isTrustedSubscriber(destinationOrNext)) {
	                        var trustedSubscriber = destinationOrNext[rxSubscriber_1.rxSubscriber]();
	                        this.syncErrorThrowable = trustedSubscriber.syncErrorThrowable;
	                        this.destination = trustedSubscriber;
	                        trustedSubscriber.add(this);
	                    }
	                    else {
	                        this.syncErrorThrowable = true;
	                        this.destination = new SafeSubscriber(this, destinationOrNext);
	                    }
	                    break;
	                }
	            default:
	                this.syncErrorThrowable = true;
	                this.destination = new SafeSubscriber(this, destinationOrNext, error, complete);
	                break;
	        }
	    }
	    Subscriber.prototype[rxSubscriber_1.rxSubscriber] = function () { return this; };
	    /**
	     * A static factory for a Subscriber, given a (potentially partial) definition
	     * of an Observer.
	     * @param {function(x: ?T): void} [next] The `next` callback of an Observer.
	     * @param {function(e: ?any): void} [error] The `error` callback of an
	     * Observer.
	     * @param {function(): void} [complete] The `complete` callback of an
	     * Observer.
	     * @return {Subscriber<T>} A Subscriber wrapping the (partially defined)
	     * Observer represented by the given arguments.
	     */
	    Subscriber.create = function (next, error, complete) {
	        var subscriber = new Subscriber(next, error, complete);
	        subscriber.syncErrorThrowable = false;
	        return subscriber;
	    };
	    /**
	     * The {@link Observer} callback to receive notifications of type `next` from
	     * the Observable, with a value. The Observable may call this method 0 or more
	     * times.
	     * @param {T} [value] The `next` value.
	     * @return {void}
	     */
	    Subscriber.prototype.next = function (value) {
	        if (!this.isStopped) {
	            this._next(value);
	        }
	    };
	    /**
	     * The {@link Observer} callback to receive notifications of type `error` from
	     * the Observable, with an attached {@link Error}. Notifies the Observer that
	     * the Observable has experienced an error condition.
	     * @param {any} [err] The `error` exception.
	     * @return {void}
	     */
	    Subscriber.prototype.error = function (err) {
	        if (!this.isStopped) {
	            this.isStopped = true;
	            this._error(err);
	        }
	    };
	    /**
	     * The {@link Observer} callback to receive a valueless notification of type
	     * `complete` from the Observable. Notifies the Observer that the Observable
	     * has finished sending push-based notifications.
	     * @return {void}
	     */
	    Subscriber.prototype.complete = function () {
	        if (!this.isStopped) {
	            this.isStopped = true;
	            this._complete();
	        }
	    };
	    Subscriber.prototype.unsubscribe = function () {
	        if (this.closed) {
	            return;
	        }
	        this.isStopped = true;
	        _super.prototype.unsubscribe.call(this);
	    };
	    Subscriber.prototype._next = function (value) {
	        this.destination.next(value);
	    };
	    Subscriber.prototype._error = function (err) {
	        this.destination.error(err);
	        this.unsubscribe();
	    };
	    Subscriber.prototype._complete = function () {
	        this.destination.complete();
	        this.unsubscribe();
	    };
	    /** @deprecated internal use only */ Subscriber.prototype._unsubscribeAndRecycle = function () {
	        var _a = this, _parent = _a._parent, _parents = _a._parents;
	        this._parent = null;
	        this._parents = null;
	        this.unsubscribe();
	        this.closed = false;
	        this.isStopped = false;
	        this._parent = _parent;
	        this._parents = _parents;
	        return this;
	    };
	    return Subscriber;
	}(Subscription_1.Subscription));
	exports.Subscriber = Subscriber;
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @ignore
	 * @extends {Ignored}
	 */
	var SafeSubscriber = (function (_super) {
	    __extends(SafeSubscriber, _super);
	    function SafeSubscriber(_parentSubscriber, observerOrNext, error, complete) {
	        _super.call(this);
	        this._parentSubscriber = _parentSubscriber;
	        var next;
	        var context = this;
	        if (isFunction_1.isFunction(observerOrNext)) {
	            next = observerOrNext;
	        }
	        else if (observerOrNext) {
	            next = observerOrNext.next;
	            error = observerOrNext.error;
	            complete = observerOrNext.complete;
	            if (observerOrNext !== Observer_1.empty) {
	                context = Object.create(observerOrNext);
	                if (isFunction_1.isFunction(context.unsubscribe)) {
	                    this.add(context.unsubscribe.bind(context));
	                }
	                context.unsubscribe = this.unsubscribe.bind(this);
	            }
	        }
	        this._context = context;
	        this._next = next;
	        this._error = error;
	        this._complete = complete;
	    }
	    SafeSubscriber.prototype.next = function (value) {
	        if (!this.isStopped && this._next) {
	            var _parentSubscriber = this._parentSubscriber;
	            if (!_parentSubscriber.syncErrorThrowable) {
	                this.__tryOrUnsub(this._next, value);
	            }
	            else if (this.__tryOrSetError(_parentSubscriber, this._next, value)) {
	                this.unsubscribe();
	            }
	        }
	    };
	    SafeSubscriber.prototype.error = function (err) {
	        if (!this.isStopped) {
	            var _parentSubscriber = this._parentSubscriber;
	            if (this._error) {
	                if (!_parentSubscriber.syncErrorThrowable) {
	                    this.__tryOrUnsub(this._error, err);
	                    this.unsubscribe();
	                }
	                else {
	                    this.__tryOrSetError(_parentSubscriber, this._error, err);
	                    this.unsubscribe();
	                }
	            }
	            else if (!_parentSubscriber.syncErrorThrowable) {
	                this.unsubscribe();
	                throw err;
	            }
	            else {
	                _parentSubscriber.syncErrorValue = err;
	                _parentSubscriber.syncErrorThrown = true;
	                this.unsubscribe();
	            }
	        }
	    };
	    SafeSubscriber.prototype.complete = function () {
	        var _this = this;
	        if (!this.isStopped) {
	            var _parentSubscriber = this._parentSubscriber;
	            if (this._complete) {
	                var wrappedComplete = function () { return _this._complete.call(_this._context); };
	                if (!_parentSubscriber.syncErrorThrowable) {
	                    this.__tryOrUnsub(wrappedComplete);
	                    this.unsubscribe();
	                }
	                else {
	                    this.__tryOrSetError(_parentSubscriber, wrappedComplete);
	                    this.unsubscribe();
	                }
	            }
	            else {
	                this.unsubscribe();
	            }
	        }
	    };
	    SafeSubscriber.prototype.__tryOrUnsub = function (fn, value) {
	        try {
	            fn.call(this._context, value);
	        }
	        catch (err) {
	            this.unsubscribe();
	            throw err;
	        }
	    };
	    SafeSubscriber.prototype.__tryOrSetError = function (parent, fn, value) {
	        try {
	            fn.call(this._context, value);
	        }
	        catch (err) {
	            parent.syncErrorValue = err;
	            parent.syncErrorThrown = true;
	            return true;
	        }
	        return false;
	    };
	    /** @deprecated internal use only */ SafeSubscriber.prototype._unsubscribe = function () {
	        var _parentSubscriber = this._parentSubscriber;
	        this._context = null;
	        this._parentSubscriber = null;
	        _parentSubscriber.unsubscribe();
	    };
	    return SafeSubscriber;
	}(Subscriber));
	function isTrustedSubscriber(obj) {
	    return obj instanceof Subscriber || ('syncErrorThrowable' in obj && obj[rxSubscriber_1.rxSubscriber]);
	}
	//# sourceMappingURL=Subscriber.js.map

/***/ }),
/* 221 */
/***/ (function(module, exports) {

	"use strict";
	function isFunction(x) {
	    return typeof x === 'function';
	}
	exports.isFunction = isFunction;
	//# sourceMappingURL=isFunction.js.map

/***/ }),
/* 222 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var isArray_1 = __webpack_require__(223);
	var isObject_1 = __webpack_require__(224);
	var isFunction_1 = __webpack_require__(221);
	var tryCatch_1 = __webpack_require__(225);
	var errorObject_1 = __webpack_require__(226);
	var UnsubscriptionError_1 = __webpack_require__(227);
	/**
	 * Represents a disposable resource, such as the execution of an Observable. A
	 * Subscription has one important method, `unsubscribe`, that takes no argument
	 * and just disposes the resource held by the subscription.
	 *
	 * Additionally, subscriptions may be grouped together through the `add()`
	 * method, which will attach a child Subscription to the current Subscription.
	 * When a Subscription is unsubscribed, all its children (and its grandchildren)
	 * will be unsubscribed as well.
	 *
	 * @class Subscription
	 */
	var Subscription = (function () {
	    /**
	     * @param {function(): void} [unsubscribe] A function describing how to
	     * perform the disposal of resources when the `unsubscribe` method is called.
	     */
	    function Subscription(unsubscribe) {
	        /**
	         * A flag to indicate whether this Subscription has already been unsubscribed.
	         * @type {boolean}
	         */
	        this.closed = false;
	        this._parent = null;
	        this._parents = null;
	        this._subscriptions = null;
	        if (unsubscribe) {
	            this._unsubscribe = unsubscribe;
	        }
	    }
	    /**
	     * Disposes the resources held by the subscription. May, for instance, cancel
	     * an ongoing Observable execution or cancel any other type of work that
	     * started when the Subscription was created.
	     * @return {void}
	     */
	    Subscription.prototype.unsubscribe = function () {
	        var hasErrors = false;
	        var errors;
	        if (this.closed) {
	            return;
	        }
	        var _a = this, _parent = _a._parent, _parents = _a._parents, _unsubscribe = _a._unsubscribe, _subscriptions = _a._subscriptions;
	        this.closed = true;
	        this._parent = null;
	        this._parents = null;
	        // null out _subscriptions first so any child subscriptions that attempt
	        // to remove themselves from this subscription will noop
	        this._subscriptions = null;
	        var index = -1;
	        var len = _parents ? _parents.length : 0;
	        // if this._parent is null, then so is this._parents, and we
	        // don't have to remove ourselves from any parent subscriptions.
	        while (_parent) {
	            _parent.remove(this);
	            // if this._parents is null or index >= len,
	            // then _parent is set to null, and the loop exits
	            _parent = ++index < len && _parents[index] || null;
	        }
	        if (isFunction_1.isFunction(_unsubscribe)) {
	            var trial = tryCatch_1.tryCatch(_unsubscribe).call(this);
	            if (trial === errorObject_1.errorObject) {
	                hasErrors = true;
	                errors = errors || (errorObject_1.errorObject.e instanceof UnsubscriptionError_1.UnsubscriptionError ?
	                    flattenUnsubscriptionErrors(errorObject_1.errorObject.e.errors) : [errorObject_1.errorObject.e]);
	            }
	        }
	        if (isArray_1.isArray(_subscriptions)) {
	            index = -1;
	            len = _subscriptions.length;
	            while (++index < len) {
	                var sub = _subscriptions[index];
	                if (isObject_1.isObject(sub)) {
	                    var trial = tryCatch_1.tryCatch(sub.unsubscribe).call(sub);
	                    if (trial === errorObject_1.errorObject) {
	                        hasErrors = true;
	                        errors = errors || [];
	                        var err = errorObject_1.errorObject.e;
	                        if (err instanceof UnsubscriptionError_1.UnsubscriptionError) {
	                            errors = errors.concat(flattenUnsubscriptionErrors(err.errors));
	                        }
	                        else {
	                            errors.push(err);
	                        }
	                    }
	                }
	            }
	        }
	        if (hasErrors) {
	            throw new UnsubscriptionError_1.UnsubscriptionError(errors);
	        }
	    };
	    /**
	     * Adds a tear down to be called during the unsubscribe() of this
	     * Subscription.
	     *
	     * If the tear down being added is a subscription that is already
	     * unsubscribed, is the same reference `add` is being called on, or is
	     * `Subscription.EMPTY`, it will not be added.
	     *
	     * If this subscription is already in an `closed` state, the passed
	     * tear down logic will be executed immediately.
	     *
	     * @param {TeardownLogic} teardown The additional logic to execute on
	     * teardown.
	     * @return {Subscription} Returns the Subscription used or created to be
	     * added to the inner subscriptions list. This Subscription can be used with
	     * `remove()` to remove the passed teardown logic from the inner subscriptions
	     * list.
	     */
	    Subscription.prototype.add = function (teardown) {
	        if (!teardown || (teardown === Subscription.EMPTY)) {
	            return Subscription.EMPTY;
	        }
	        if (teardown === this) {
	            return this;
	        }
	        var subscription = teardown;
	        switch (typeof teardown) {
	            case 'function':
	                subscription = new Subscription(teardown);
	            case 'object':
	                if (subscription.closed || typeof subscription.unsubscribe !== 'function') {
	                    return subscription;
	                }
	                else if (this.closed) {
	                    subscription.unsubscribe();
	                    return subscription;
	                }
	                else if (typeof subscription._addParent !== 'function' /* quack quack */) {
	                    var tmp = subscription;
	                    subscription = new Subscription();
	                    subscription._subscriptions = [tmp];
	                }
	                break;
	            default:
	                throw new Error('unrecognized teardown ' + teardown + ' added to Subscription.');
	        }
	        var subscriptions = this._subscriptions || (this._subscriptions = []);
	        subscriptions.push(subscription);
	        subscription._addParent(this);
	        return subscription;
	    };
	    /**
	     * Removes a Subscription from the internal list of subscriptions that will
	     * unsubscribe during the unsubscribe process of this Subscription.
	     * @param {Subscription} subscription The subscription to remove.
	     * @return {void}
	     */
	    Subscription.prototype.remove = function (subscription) {
	        var subscriptions = this._subscriptions;
	        if (subscriptions) {
	            var subscriptionIndex = subscriptions.indexOf(subscription);
	            if (subscriptionIndex !== -1) {
	                subscriptions.splice(subscriptionIndex, 1);
	            }
	        }
	    };
	    Subscription.prototype._addParent = function (parent) {
	        var _a = this, _parent = _a._parent, _parents = _a._parents;
	        if (!_parent || _parent === parent) {
	            // If we don't have a parent, or the new parent is the same as the
	            // current parent, then set this._parent to the new parent.
	            this._parent = parent;
	        }
	        else if (!_parents) {
	            // If there's already one parent, but not multiple, allocate an Array to
	            // store the rest of the parent Subscriptions.
	            this._parents = [parent];
	        }
	        else if (_parents.indexOf(parent) === -1) {
	            // Only add the new parent to the _parents list if it's not already there.
	            _parents.push(parent);
	        }
	    };
	    Subscription.EMPTY = (function (empty) {
	        empty.closed = true;
	        return empty;
	    }(new Subscription()));
	    return Subscription;
	}());
	exports.Subscription = Subscription;
	function flattenUnsubscriptionErrors(errors) {
	    return errors.reduce(function (errs, err) { return errs.concat((err instanceof UnsubscriptionError_1.UnsubscriptionError) ? err.errors : err); }, []);
	}
	//# sourceMappingURL=Subscription.js.map

/***/ }),
/* 223 */
/***/ (function(module, exports) {

	"use strict";
	exports.isArray = Array.isArray || (function (x) { return x && typeof x.length === 'number'; });
	//# sourceMappingURL=isArray.js.map

/***/ }),
/* 224 */
/***/ (function(module, exports) {

	"use strict";
	function isObject(x) {
	    return x != null && typeof x === 'object';
	}
	exports.isObject = isObject;
	//# sourceMappingURL=isObject.js.map

/***/ }),
/* 225 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var errorObject_1 = __webpack_require__(226);
	var tryCatchTarget;
	function tryCatcher() {
	    try {
	        return tryCatchTarget.apply(this, arguments);
	    }
	    catch (e) {
	        errorObject_1.errorObject.e = e;
	        return errorObject_1.errorObject;
	    }
	}
	function tryCatch(fn) {
	    tryCatchTarget = fn;
	    return tryCatcher;
	}
	exports.tryCatch = tryCatch;
	;
	//# sourceMappingURL=tryCatch.js.map

/***/ }),
/* 226 */
/***/ (function(module, exports) {

	"use strict";
	// typeof any so that it we don't have to cast when comparing a result to the error object
	exports.errorObject = { e: {} };
	//# sourceMappingURL=errorObject.js.map

/***/ }),
/* 227 */
/***/ (function(module, exports) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	/**
	 * An error thrown when one or more errors have occurred during the
	 * `unsubscribe` of a {@link Subscription}.
	 */
	var UnsubscriptionError = (function (_super) {
	    __extends(UnsubscriptionError, _super);
	    function UnsubscriptionError(errors) {
	        _super.call(this);
	        this.errors = errors;
	        var err = Error.call(this, errors ?
	            errors.length + " errors occurred during unsubscription:\n  " + errors.map(function (err, i) { return ((i + 1) + ") " + err.toString()); }).join('\n  ') : '');
	        this.name = err.name = 'UnsubscriptionError';
	        this.stack = err.stack;
	        this.message = err.message;
	    }
	    return UnsubscriptionError;
	}(Error));
	exports.UnsubscriptionError = UnsubscriptionError;
	//# sourceMappingURL=UnsubscriptionError.js.map

/***/ }),
/* 228 */
/***/ (function(module, exports) {

	"use strict";
	exports.empty = {
	    closed: true,
	    next: function (value) { },
	    error: function (err) { throw err; },
	    complete: function () { }
	};
	//# sourceMappingURL=Observer.js.map

/***/ }),
/* 229 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var root_1 = __webpack_require__(218);
	var Symbol = root_1.root.Symbol;
	exports.rxSubscriber = (typeof Symbol === 'function' && typeof Symbol.for === 'function') ?
	    Symbol.for('rxSubscriber') : '@@rxSubscriber';
	/**
	 * @deprecated use rxSubscriber instead
	 */
	exports.$$rxSubscriber = exports.rxSubscriber;
	//# sourceMappingURL=rxSubscriber.js.map

/***/ }),
/* 230 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var root_1 = __webpack_require__(218);
	function getSymbolObservable(context) {
	    var $$observable;
	    var Symbol = context.Symbol;
	    if (typeof Symbol === 'function') {
	        if (Symbol.observable) {
	            $$observable = Symbol.observable;
	        }
	        else {
	            $$observable = Symbol('observable');
	            Symbol.observable = $$observable;
	        }
	    }
	    else {
	        $$observable = '@@observable';
	    }
	    return $$observable;
	}
	exports.getSymbolObservable = getSymbolObservable;
	exports.observable = getSymbolObservable(root_1.root);
	/**
	 * @deprecated use observable instead
	 */
	exports.$$observable = exports.observable;
	//# sourceMappingURL=observable.js.map

/***/ }),
/* 231 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var noop_1 = __webpack_require__(232);
	/* tslint:enable:max-line-length */
	function pipe() {
	    var fns = [];
	    for (var _i = 0; _i < arguments.length; _i++) {
	        fns[_i - 0] = arguments[_i];
	    }
	    return pipeFromArray(fns);
	}
	exports.pipe = pipe;
	/* @internal */
	function pipeFromArray(fns) {
	    if (!fns) {
	        return noop_1.noop;
	    }
	    if (fns.length === 1) {
	        return fns[0];
	    }
	    return function piped(input) {
	        return fns.reduce(function (prev, fn) { return fn(prev); }, input);
	    };
	}
	exports.pipeFromArray = pipeFromArray;
	//# sourceMappingURL=pipe.js.map

/***/ }),
/* 232 */
/***/ (function(module, exports) {

	"use strict";
	/* tslint:disable:no-empty */
	function noop() { }
	exports.noop = noop;
	//# sourceMappingURL=noop.js.map

/***/ }),
/* 233 */
/***/ (function(module, exports) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	/**
	 * An error thrown when an action is invalid because the object has been
	 * unsubscribed.
	 *
	 * @see {@link Subject}
	 * @see {@link BehaviorSubject}
	 *
	 * @class ObjectUnsubscribedError
	 */
	var ObjectUnsubscribedError = (function (_super) {
	    __extends(ObjectUnsubscribedError, _super);
	    function ObjectUnsubscribedError() {
	        var err = _super.call(this, 'object unsubscribed');
	        this.name = err.name = 'ObjectUnsubscribedError';
	        this.stack = err.stack;
	        this.message = err.message;
	    }
	    return ObjectUnsubscribedError;
	}(Error));
	exports.ObjectUnsubscribedError = ObjectUnsubscribedError;
	//# sourceMappingURL=ObjectUnsubscribedError.js.map

/***/ }),
/* 234 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var Subscription_1 = __webpack_require__(222);
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @ignore
	 * @extends {Ignored}
	 */
	var SubjectSubscription = (function (_super) {
	    __extends(SubjectSubscription, _super);
	    function SubjectSubscription(subject, subscriber) {
	        _super.call(this);
	        this.subject = subject;
	        this.subscriber = subscriber;
	        this.closed = false;
	    }
	    SubjectSubscription.prototype.unsubscribe = function () {
	        if (this.closed) {
	            return;
	        }
	        this.closed = true;
	        var subject = this.subject;
	        var observers = subject.observers;
	        this.subject = null;
	        if (!observers || observers.length === 0 || subject.isStopped || subject.closed) {
	            return;
	        }
	        var subscriberIndex = observers.indexOf(this.subscriber);
	        if (subscriberIndex !== -1) {
	            observers.splice(subscriberIndex, 1);
	        }
	    };
	    return SubjectSubscription;
	}(Subscription_1.Subscription));
	exports.SubjectSubscription = SubjectSubscription;
	//# sourceMappingURL=SubjectSubscription.js.map

/***/ }),
/* 235 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var Observable_1 = __webpack_require__(217);
	var switchMap_1 = __webpack_require__(236);
	Observable_1.Observable.prototype.switchMap = switchMap_1.switchMap;
	//# sourceMappingURL=switchMap.js.map

/***/ }),
/* 236 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var switchMap_1 = __webpack_require__(237);
	/* tslint:enable:max-line-length */
	/**
	 * Projects each source value to an Observable which is merged in the output
	 * Observable, emitting values only from the most recently projected Observable.
	 *
	 * <span class="informal">Maps each value to an Observable, then flattens all of
	 * these inner Observables using {@link switch}.</span>
	 *
	 * <img src="./img/switchMap.png" width="100%">
	 *
	 * Returns an Observable that emits items based on applying a function that you
	 * supply to each item emitted by the source Observable, where that function
	 * returns an (so-called "inner") Observable. Each time it observes one of these
	 * inner Observables, the output Observable begins emitting the items emitted by
	 * that inner Observable. When a new inner Observable is emitted, `switchMap`
	 * stops emitting items from the earlier-emitted inner Observable and begins
	 * emitting items from the new one. It continues to behave like this for
	 * subsequent inner Observables.
	 *
	 * @example <caption>Rerun an interval Observable on every click event</caption>
	 * var clicks = Rx.Observable.fromEvent(document, 'click');
	 * var result = clicks.switchMap((ev) => Rx.Observable.interval(1000));
	 * result.subscribe(x => console.log(x));
	 *
	 * @see {@link concatMap}
	 * @see {@link exhaustMap}
	 * @see {@link mergeMap}
	 * @see {@link switch}
	 * @see {@link switchMapTo}
	 *
	 * @param {function(value: T, ?index: number): ObservableInput} project A function
	 * that, when applied to an item emitted by the source Observable, returns an
	 * Observable.
	 * @param {function(outerValue: T, innerValue: I, outerIndex: number, innerIndex: number): any} [resultSelector]
	 * A function to produce the value on the output Observable based on the values
	 * and the indices of the source (outer) emission and the inner Observable
	 * emission. The arguments passed to this function are:
	 * - `outerValue`: the value that came from the source
	 * - `innerValue`: the value that came from the projected Observable
	 * - `outerIndex`: the "index" of the value that came from the source
	 * - `innerIndex`: the "index" of the value from the projected Observable
	 * @return {Observable} An Observable that emits the result of applying the
	 * projection function (and the optional `resultSelector`) to each item emitted
	 * by the source Observable and taking only the values from the most recently
	 * projected inner Observable.
	 * @method switchMap
	 * @owner Observable
	 */
	function switchMap(project, resultSelector) {
	    return switchMap_1.switchMap(project, resultSelector)(this);
	}
	exports.switchMap = switchMap;
	//# sourceMappingURL=switchMap.js.map

/***/ }),
/* 237 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var OuterSubscriber_1 = __webpack_require__(238);
	var subscribeToResult_1 = __webpack_require__(239);
	/* tslint:enable:max-line-length */
	/**
	 * Projects each source value to an Observable which is merged in the output
	 * Observable, emitting values only from the most recently projected Observable.
	 *
	 * <span class="informal">Maps each value to an Observable, then flattens all of
	 * these inner Observables using {@link switch}.</span>
	 *
	 * <img src="./img/switchMap.png" width="100%">
	 *
	 * Returns an Observable that emits items based on applying a function that you
	 * supply to each item emitted by the source Observable, where that function
	 * returns an (so-called "inner") Observable. Each time it observes one of these
	 * inner Observables, the output Observable begins emitting the items emitted by
	 * that inner Observable. When a new inner Observable is emitted, `switchMap`
	 * stops emitting items from the earlier-emitted inner Observable and begins
	 * emitting items from the new one. It continues to behave like this for
	 * subsequent inner Observables.
	 *
	 * @example <caption>Rerun an interval Observable on every click event</caption>
	 * var clicks = Rx.Observable.fromEvent(document, 'click');
	 * var result = clicks.switchMap((ev) => Rx.Observable.interval(1000));
	 * result.subscribe(x => console.log(x));
	 *
	 * @see {@link concatMap}
	 * @see {@link exhaustMap}
	 * @see {@link mergeMap}
	 * @see {@link switch}
	 * @see {@link switchMapTo}
	 *
	 * @param {function(value: T, ?index: number): ObservableInput} project A function
	 * that, when applied to an item emitted by the source Observable, returns an
	 * Observable.
	 * @param {function(outerValue: T, innerValue: I, outerIndex: number, innerIndex: number): any} [resultSelector]
	 * A function to produce the value on the output Observable based on the values
	 * and the indices of the source (outer) emission and the inner Observable
	 * emission. The arguments passed to this function are:
	 * - `outerValue`: the value that came from the source
	 * - `innerValue`: the value that came from the projected Observable
	 * - `outerIndex`: the "index" of the value that came from the source
	 * - `innerIndex`: the "index" of the value from the projected Observable
	 * @return {Observable} An Observable that emits the result of applying the
	 * projection function (and the optional `resultSelector`) to each item emitted
	 * by the source Observable and taking only the values from the most recently
	 * projected inner Observable.
	 * @method switchMap
	 * @owner Observable
	 */
	function switchMap(project, resultSelector) {
	    return function switchMapOperatorFunction(source) {
	        return source.lift(new SwitchMapOperator(project, resultSelector));
	    };
	}
	exports.switchMap = switchMap;
	var SwitchMapOperator = (function () {
	    function SwitchMapOperator(project, resultSelector) {
	        this.project = project;
	        this.resultSelector = resultSelector;
	    }
	    SwitchMapOperator.prototype.call = function (subscriber, source) {
	        return source.subscribe(new SwitchMapSubscriber(subscriber, this.project, this.resultSelector));
	    };
	    return SwitchMapOperator;
	}());
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @ignore
	 * @extends {Ignored}
	 */
	var SwitchMapSubscriber = (function (_super) {
	    __extends(SwitchMapSubscriber, _super);
	    function SwitchMapSubscriber(destination, project, resultSelector) {
	        _super.call(this, destination);
	        this.project = project;
	        this.resultSelector = resultSelector;
	        this.index = 0;
	    }
	    SwitchMapSubscriber.prototype._next = function (value) {
	        var result;
	        var index = this.index++;
	        try {
	            result = this.project(value, index);
	        }
	        catch (error) {
	            this.destination.error(error);
	            return;
	        }
	        this._innerSub(result, value, index);
	    };
	    SwitchMapSubscriber.prototype._innerSub = function (result, value, index) {
	        var innerSubscription = this.innerSubscription;
	        if (innerSubscription) {
	            innerSubscription.unsubscribe();
	        }
	        this.add(this.innerSubscription = subscribeToResult_1.subscribeToResult(this, result, value, index));
	    };
	    SwitchMapSubscriber.prototype._complete = function () {
	        var innerSubscription = this.innerSubscription;
	        if (!innerSubscription || innerSubscription.closed) {
	            _super.prototype._complete.call(this);
	        }
	    };
	    /** @deprecated internal use only */ SwitchMapSubscriber.prototype._unsubscribe = function () {
	        this.innerSubscription = null;
	    };
	    SwitchMapSubscriber.prototype.notifyComplete = function (innerSub) {
	        this.remove(innerSub);
	        this.innerSubscription = null;
	        if (this.isStopped) {
	            _super.prototype._complete.call(this);
	        }
	    };
	    SwitchMapSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
	        if (this.resultSelector) {
	            this._tryNotifyNext(outerValue, innerValue, outerIndex, innerIndex);
	        }
	        else {
	            this.destination.next(innerValue);
	        }
	    };
	    SwitchMapSubscriber.prototype._tryNotifyNext = function (outerValue, innerValue, outerIndex, innerIndex) {
	        var result;
	        try {
	            result = this.resultSelector(outerValue, innerValue, outerIndex, innerIndex);
	        }
	        catch (err) {
	            this.destination.error(err);
	            return;
	        }
	        this.destination.next(result);
	    };
	    return SwitchMapSubscriber;
	}(OuterSubscriber_1.OuterSubscriber));
	//# sourceMappingURL=switchMap.js.map

/***/ }),
/* 238 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var Subscriber_1 = __webpack_require__(220);
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @ignore
	 * @extends {Ignored}
	 */
	var OuterSubscriber = (function (_super) {
	    __extends(OuterSubscriber, _super);
	    function OuterSubscriber() {
	        _super.apply(this, arguments);
	    }
	    OuterSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
	        this.destination.next(innerValue);
	    };
	    OuterSubscriber.prototype.notifyError = function (error, innerSub) {
	        this.destination.error(error);
	    };
	    OuterSubscriber.prototype.notifyComplete = function (innerSub) {
	        this.destination.complete();
	    };
	    return OuterSubscriber;
	}(Subscriber_1.Subscriber));
	exports.OuterSubscriber = OuterSubscriber;
	//# sourceMappingURL=OuterSubscriber.js.map

/***/ }),
/* 239 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var root_1 = __webpack_require__(218);
	var isArrayLike_1 = __webpack_require__(240);
	var isPromise_1 = __webpack_require__(241);
	var isObject_1 = __webpack_require__(224);
	var Observable_1 = __webpack_require__(217);
	var iterator_1 = __webpack_require__(242);
	var InnerSubscriber_1 = __webpack_require__(243);
	var observable_1 = __webpack_require__(230);
	function subscribeToResult(outerSubscriber, result, outerValue, outerIndex) {
	    var destination = new InnerSubscriber_1.InnerSubscriber(outerSubscriber, outerValue, outerIndex);
	    if (destination.closed) {
	        return null;
	    }
	    if (result instanceof Observable_1.Observable) {
	        if (result._isScalar) {
	            destination.next(result.value);
	            destination.complete();
	            return null;
	        }
	        else {
	            destination.syncErrorThrowable = true;
	            return result.subscribe(destination);
	        }
	    }
	    else if (isArrayLike_1.isArrayLike(result)) {
	        for (var i = 0, len = result.length; i < len && !destination.closed; i++) {
	            destination.next(result[i]);
	        }
	        if (!destination.closed) {
	            destination.complete();
	        }
	    }
	    else if (isPromise_1.isPromise(result)) {
	        result.then(function (value) {
	            if (!destination.closed) {
	                destination.next(value);
	                destination.complete();
	            }
	        }, function (err) { return destination.error(err); })
	            .then(null, function (err) {
	            // Escaping the Promise trap: globally throw unhandled errors
	            root_1.root.setTimeout(function () { throw err; });
	        });
	        return destination;
	    }
	    else if (result && typeof result[iterator_1.iterator] === 'function') {
	        var iterator = result[iterator_1.iterator]();
	        do {
	            var item = iterator.next();
	            if (item.done) {
	                destination.complete();
	                break;
	            }
	            destination.next(item.value);
	            if (destination.closed) {
	                break;
	            }
	        } while (true);
	    }
	    else if (result && typeof result[observable_1.observable] === 'function') {
	        var obs = result[observable_1.observable]();
	        if (typeof obs.subscribe !== 'function') {
	            destination.error(new TypeError('Provided object does not correctly implement Symbol.observable'));
	        }
	        else {
	            return obs.subscribe(new InnerSubscriber_1.InnerSubscriber(outerSubscriber, outerValue, outerIndex));
	        }
	    }
	    else {
	        var value = isObject_1.isObject(result) ? 'an invalid object' : "'" + result + "'";
	        var msg = ("You provided " + value + " where a stream was expected.")
	            + ' You can provide an Observable, Promise, Array, or Iterable.';
	        destination.error(new TypeError(msg));
	    }
	    return null;
	}
	exports.subscribeToResult = subscribeToResult;
	//# sourceMappingURL=subscribeToResult.js.map

/***/ }),
/* 240 */
/***/ (function(module, exports) {

	"use strict";
	exports.isArrayLike = (function (x) { return x && typeof x.length === 'number'; });
	//# sourceMappingURL=isArrayLike.js.map

/***/ }),
/* 241 */
/***/ (function(module, exports) {

	"use strict";
	function isPromise(value) {
	    return value && typeof value.subscribe !== 'function' && typeof value.then === 'function';
	}
	exports.isPromise = isPromise;
	//# sourceMappingURL=isPromise.js.map

/***/ }),
/* 242 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var root_1 = __webpack_require__(218);
	function symbolIteratorPonyfill(root) {
	    var Symbol = root.Symbol;
	    if (typeof Symbol === 'function') {
	        if (!Symbol.iterator) {
	            Symbol.iterator = Symbol('iterator polyfill');
	        }
	        return Symbol.iterator;
	    }
	    else {
	        // [for Mozilla Gecko 27-35:](https://mzl.la/2ewE1zC)
	        var Set_1 = root.Set;
	        if (Set_1 && typeof new Set_1()['@@iterator'] === 'function') {
	            return '@@iterator';
	        }
	        var Map_1 = root.Map;
	        // required for compatability with es6-shim
	        if (Map_1) {
	            var keys = Object.getOwnPropertyNames(Map_1.prototype);
	            for (var i = 0; i < keys.length; ++i) {
	                var key = keys[i];
	                // according to spec, Map.prototype[@@iterator] and Map.orototype.entries must be equal.
	                if (key !== 'entries' && key !== 'size' && Map_1.prototype[key] === Map_1.prototype['entries']) {
	                    return key;
	                }
	            }
	        }
	        return '@@iterator';
	    }
	}
	exports.symbolIteratorPonyfill = symbolIteratorPonyfill;
	exports.iterator = symbolIteratorPonyfill(root_1.root);
	/**
	 * @deprecated use iterator instead
	 */
	exports.$$iterator = exports.iterator;
	//# sourceMappingURL=iterator.js.map

/***/ }),
/* 243 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var Subscriber_1 = __webpack_require__(220);
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @ignore
	 * @extends {Ignored}
	 */
	var InnerSubscriber = (function (_super) {
	    __extends(InnerSubscriber, _super);
	    function InnerSubscriber(parent, outerValue, outerIndex) {
	        _super.call(this);
	        this.parent = parent;
	        this.outerValue = outerValue;
	        this.outerIndex = outerIndex;
	        this.index = 0;
	    }
	    InnerSubscriber.prototype._next = function (value) {
	        this.parent.notifyNext(this.outerValue, value, this.outerIndex, this.index++, this);
	    };
	    InnerSubscriber.prototype._error = function (error) {
	        this.parent.notifyError(error, this);
	        this.unsubscribe();
	    };
	    InnerSubscriber.prototype._complete = function () {
	        this.parent.notifyComplete(this);
	        this.unsubscribe();
	    };
	    return InnerSubscriber;
	}(Subscriber_1.Subscriber));
	exports.InnerSubscriber = InnerSubscriber;
	//# sourceMappingURL=InnerSubscriber.js.map

/***/ }),
/* 244 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var Observable_1 = __webpack_require__(217);
	var catch_1 = __webpack_require__(245);
	Observable_1.Observable.prototype.catch = catch_1._catch;
	Observable_1.Observable.prototype._catch = catch_1._catch;
	//# sourceMappingURL=catch.js.map

/***/ }),
/* 245 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var catchError_1 = __webpack_require__(246);
	/**
	 * Catches errors on the observable to be handled by returning a new observable or throwing an error.
	 *
	 * <img src="./img/catch.png" width="100%">
	 *
	 * @example <caption>Continues with a different Observable when there's an error</caption>
	 *
	 * Observable.of(1, 2, 3, 4, 5)
	 *   .map(n => {
	 * 	   if (n == 4) {
	 * 	     throw 'four!';
	 *     }
	 *	   return n;
	 *   })
	 *   .catch(err => Observable.of('I', 'II', 'III', 'IV', 'V'))
	 *   .subscribe(x => console.log(x));
	 *   // 1, 2, 3, I, II, III, IV, V
	 *
	 * @example <caption>Retries the caught source Observable again in case of error, similar to retry() operator</caption>
	 *
	 * Observable.of(1, 2, 3, 4, 5)
	 *   .map(n => {
	 * 	   if (n === 4) {
	 * 	     throw 'four!';
	 *     }
	 * 	   return n;
	 *   })
	 *   .catch((err, caught) => caught)
	 *   .take(30)
	 *   .subscribe(x => console.log(x));
	 *   // 1, 2, 3, 1, 2, 3, ...
	 *
	 * @example <caption>Throws a new error when the source Observable throws an error</caption>
	 *
	 * Observable.of(1, 2, 3, 4, 5)
	 *   .map(n => {
	 *     if (n == 4) {
	 *       throw 'four!';
	 *     }
	 *     return n;
	 *   })
	 *   .catch(err => {
	 *     throw 'error in source. Details: ' + err;
	 *   })
	 *   .subscribe(
	 *     x => console.log(x),
	 *     err => console.log(err)
	 *   );
	 *   // 1, 2, 3, error in source. Details: four!
	 *
	 * @param {function} selector a function that takes as arguments `err`, which is the error, and `caught`, which
	 *  is the source observable, in case you'd like to "retry" that observable by returning it again. Whatever observable
	 *  is returned by the `selector` will be used to continue the observable chain.
	 * @return {Observable} An observable that originates from either the source or the observable returned by the
	 *  catch `selector` function.
	 * @method catch
	 * @name catch
	 * @owner Observable
	 */
	function _catch(selector) {
	    return catchError_1.catchError(selector)(this);
	}
	exports._catch = _catch;
	//# sourceMappingURL=catch.js.map

/***/ }),
/* 246 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var OuterSubscriber_1 = __webpack_require__(238);
	var subscribeToResult_1 = __webpack_require__(239);
	/**
	 * Catches errors on the observable to be handled by returning a new observable or throwing an error.
	 *
	 * <img src="./img/catch.png" width="100%">
	 *
	 * @example <caption>Continues with a different Observable when there's an error</caption>
	 *
	 * Observable.of(1, 2, 3, 4, 5)
	 *   .map(n => {
	 * 	   if (n == 4) {
	 * 	     throw 'four!';
	 *     }
	 *	   return n;
	 *   })
	 *   .catch(err => Observable.of('I', 'II', 'III', 'IV', 'V'))
	 *   .subscribe(x => console.log(x));
	 *   // 1, 2, 3, I, II, III, IV, V
	 *
	 * @example <caption>Retries the caught source Observable again in case of error, similar to retry() operator</caption>
	 *
	 * Observable.of(1, 2, 3, 4, 5)
	 *   .map(n => {
	 * 	   if (n === 4) {
	 * 	     throw 'four!';
	 *     }
	 * 	   return n;
	 *   })
	 *   .catch((err, caught) => caught)
	 *   .take(30)
	 *   .subscribe(x => console.log(x));
	 *   // 1, 2, 3, 1, 2, 3, ...
	 *
	 * @example <caption>Throws a new error when the source Observable throws an error</caption>
	 *
	 * Observable.of(1, 2, 3, 4, 5)
	 *   .map(n => {
	 *     if (n == 4) {
	 *       throw 'four!';
	 *     }
	 *     return n;
	 *   })
	 *   .catch(err => {
	 *     throw 'error in source. Details: ' + err;
	 *   })
	 *   .subscribe(
	 *     x => console.log(x),
	 *     err => console.log(err)
	 *   );
	 *   // 1, 2, 3, error in source. Details: four!
	 *
	 * @param {function} selector a function that takes as arguments `err`, which is the error, and `caught`, which
	 *  is the source observable, in case you'd like to "retry" that observable by returning it again. Whatever observable
	 *  is returned by the `selector` will be used to continue the observable chain.
	 * @return {Observable} An observable that originates from either the source or the observable returned by the
	 *  catch `selector` function.
	 * @name catchError
	 */
	function catchError(selector) {
	    return function catchErrorOperatorFunction(source) {
	        var operator = new CatchOperator(selector);
	        var caught = source.lift(operator);
	        return (operator.caught = caught);
	    };
	}
	exports.catchError = catchError;
	var CatchOperator = (function () {
	    function CatchOperator(selector) {
	        this.selector = selector;
	    }
	    CatchOperator.prototype.call = function (subscriber, source) {
	        return source.subscribe(new CatchSubscriber(subscriber, this.selector, this.caught));
	    };
	    return CatchOperator;
	}());
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @ignore
	 * @extends {Ignored}
	 */
	var CatchSubscriber = (function (_super) {
	    __extends(CatchSubscriber, _super);
	    function CatchSubscriber(destination, selector, caught) {
	        _super.call(this, destination);
	        this.selector = selector;
	        this.caught = caught;
	    }
	    // NOTE: overriding `error` instead of `_error` because we don't want
	    // to have this flag this subscriber as `isStopped`. We can mimic the
	    // behavior of the RetrySubscriber (from the `retry` operator), where
	    // we unsubscribe from our source chain, reset our Subscriber flags,
	    // then subscribe to the selector result.
	    CatchSubscriber.prototype.error = function (err) {
	        if (!this.isStopped) {
	            var result = void 0;
	            try {
	                result = this.selector(err, this.caught);
	            }
	            catch (err2) {
	                _super.prototype.error.call(this, err2);
	                return;
	            }
	            this._unsubscribeAndRecycle();
	            this.add(subscribeToResult_1.subscribeToResult(this, result));
	        }
	    };
	    return CatchSubscriber;
	}(OuterSubscriber_1.OuterSubscriber));
	//# sourceMappingURL=catchError.js.map

/***/ }),
/* 247 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var __assign = (this && this.__assign) || function () {
	    __assign = Object.assign || function(t) {
	        for (var s, i = 1, n = arguments.length; i < n; i++) {
	            s = arguments[i];
	            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
	                t[p] = s[p];
	        }
	        return t;
	    };
	    return __assign.apply(this, arguments);
	};
	var __importDefault = (this && this.__importDefault) || function (mod) {
	    return (mod && mod.__esModule) ? mod : { "default": mod };
	};
	Object.defineProperty(exports, "__esModule", { value: true });
	// (C) 2007-2020 GoodData Corporation
	var compact_1 = __importDefault(__webpack_require__(155));
	var flatMap_1 = __importDefault(__webpack_require__(248));
	var get_1 = __importDefault(__webpack_require__(89));
	var typings_1 = __webpack_require__(137);
	var FilterConverter_1 = __webpack_require__(191);
	var MeasureConverter_1 = __importDefault(__webpack_require__(249));
	var buckets_1 = __webpack_require__(251);
	function convertAttribute(attribute, idx) {
	    var alias = attribute.visualizationAttribute.alias;
	    var aliasProp = alias ? { alias: alias } : {};
	    return __assign({ displayForm: attribute.visualizationAttribute.displayForm, localIdentifier: attribute.visualizationAttribute.localIdentifier || "a" + (idx + 1) }, aliasProp);
	}
	function convertAFM(visualizationObject) {
	    var textualAttributes = getAttributes(visualizationObject.buckets).map(convertAttribute);
	    var geoAttribute = getGeoAttributeForTooltip(visualizationObject);
	    var attributes = geoAttribute ? textualAttributes.concat([geoAttribute]) : textualAttributes;
	    var attrProp = attributes.length ? { attributes: attributes } : {};
	    var measures = getMeasures(visualizationObject.buckets).map(MeasureConverter_1.default.convertMeasure);
	    var measuresProp = measures.length ? { measures: measures } : {};
	    var filters = visualizationObject.filters
	        ? compact_1.default(visualizationObject.filters.map(FilterConverter_1.convertVisualizationObjectExtendedFilter))
	        : [];
	    var filtersProp = filters.length ? { filters: filters } : {};
	    var nativeTotals = convertNativeTotals(visualizationObject);
	    var nativeTotalsProp = nativeTotals.length ? { nativeTotals: nativeTotals } : {};
	    return __assign({}, measuresProp, attrProp, filtersProp, nativeTotalsProp);
	}
	function getMeasures(buckets) {
	    return buckets.reduce(function (result, bucket) {
	        var measureItems = bucket.items.filter(typings_1.VisualizationObject.isMeasure);
	        return result.concat(measureItems);
	    }, []);
	}
	function getNativeTotalAttributeIdentifiers(bucket, total) {
	    var attributes = bucket.items.filter(typings_1.VisualizationObject.isAttribute);
	    var totalAttributeIndex = attributes.findIndex(function (attribute) { return attribute.visualizationAttribute.localIdentifier === total.attributeIdentifier; });
	    return attributes
	        .slice(0, totalAttributeIndex)
	        .map(function (attribute) { return attribute.visualizationAttribute.localIdentifier; });
	}
	function convertNativeTotals(visObj) {
	    var nativeTotalsPerBucket = visObj.buckets.map(function (bucket) {
	        var totals = bucket.totals || [];
	        var nativeTotals = totals.filter(function (total) { return total.type === "nat"; });
	        return nativeTotals.map(function (total) { return ({
	            measureIdentifier: total.measureIdentifier,
	            attributeIdentifiers: getNativeTotalAttributeIdentifiers(bucket, total),
	        }); });
	    });
	    return flatMap_1.default(nativeTotalsPerBucket);
	}
	function getAttributes(buckets) {
	    return buckets.reduce(function (result, bucket) {
	        var items = bucket.items.filter(typings_1.VisualizationObject.isAttribute);
	        return result.concat(items);
	    }, []);
	}
	function parsePropertyItem(item) {
	    try {
	        return JSON.parse(item);
	    }
	    catch (e) {
	        return {};
	    }
	}
	function buildTooltipBucketItem(tooltipText, alias) {
	    var tooltipAlias = alias ? { alias: alias } : {};
	    return __assign({ localIdentifier: buckets_1.TOOLTIP_TEXT, displayForm: {
	            uri: tooltipText,
	        } }, tooltipAlias);
	}
	function getGeoAttributeForTooltip(visualizationObject) {
	    var properties = parsePropertyItem(visualizationObject.properties || "");
	    var tooltipText = get_1.default(properties, "controls.tooltipText", "");
	    if (tooltipText) {
	        // copy alias of Geo attribute to alias of tooltipText attribute
	        var locationAlias = visualizationObject.buckets.reduce(function (locationAlias, bucket) {
	            if (!locationAlias && bucket.localIdentifier === buckets_1.LOCATION) {
	                return get_1.default(bucket, "items[0].visualizationAttribute.alias");
	            }
	            return locationAlias;
	        }, "");
	        return buildTooltipBucketItem(tooltipText, locationAlias);
	    }
	    return null;
	}
	function convertSorting(visObj) {
	    if (visObj.properties) {
	        var properties = {};
	        try {
	            properties = JSON.parse(visObj.properties);
	        }
	        catch (_a) {
	            // tslint:disable-next-line:no-console
	            console.error("Properties contains invalid JSON string.");
	        }
	        var sorts = get_1.default(properties, "sortItems", []);
	        return sorts ? sorts : [];
	    }
	    return [];
	}
	function convertResultSpec(visObj) {
	    var sorts = convertSorting(visObj);
	    // Workaround because we can handle only 1 sort item for now
	    var sortsProp = sorts.length ? { sorts: sorts.slice(0, 1) } : {};
	    return __assign({}, sortsProp);
	}
	/**
	 * Converts visualizationObject to afm and resultSpec
	 *
	 * @method toAfmResultSpec
	 * @param {VisualizationObject.IVisualizationObjectContent} visObj
	 * @returns {IConvertedAFM}
	 */
	function toAfmResultSpec(visObj) {
	    var afm = convertAFM(visObj);
	    return {
	        afm: afm,
	        resultSpec: convertResultSpec(visObj),
	    };
	}
	exports.toAfmResultSpec = toAfmResultSpec;


/***/ }),
/* 248 */
/***/ (function(module, exports, __webpack_require__) {

	var baseFlatten = __webpack_require__(105),
	    map = __webpack_require__(164);

	/**
	 * Creates a flattened array of values by running each element in `collection`
	 * thru `iteratee` and flattening the mapped results. The iteratee is invoked
	 * with three arguments: (value, index|key, collection).
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Collection
	 * @param {Array|Object} collection The collection to iterate over.
	 * @param {Function} [iteratee=_.identity] The function invoked per iteration.
	 * @returns {Array} Returns the new flattened array.
	 * @example
	 *
	 * function duplicate(n) {
	 *   return [n, n];
	 * }
	 *
	 * _.flatMap([1, 2], duplicate);
	 * // => [1, 1, 2, 2]
	 */
	function flatMap(collection, iteratee) {
	  return baseFlatten(map(collection, iteratee), 1);
	}

	module.exports = flatMap;


/***/ }),
/* 249 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var __assign = (this && this.__assign) || function () {
	    __assign = Object.assign || function(t) {
	        for (var s, i = 1, n = arguments.length; i < n; i++) {
	            s = arguments[i];
	            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
	                t[p] = s[p];
	        }
	        return t;
	    };
	    return __assign.apply(this, arguments);
	};
	var __importDefault = (this && this.__importDefault) || function (mod) {
	    return (mod && mod.__esModule) ? mod : { "default": mod };
	};
	Object.defineProperty(exports, "__esModule", { value: true });
	// (C) 2007-2020 GoodData Corporation
	var compact_1 = __importDefault(__webpack_require__(155));
	var typings_1 = __webpack_require__(137);
	var FilterConverter_1 = __webpack_require__(191);
	var formats_1 = __webpack_require__(250);
	var MeasureConverter = {
	    convertMeasure: convertMeasure,
	};
	exports.default = MeasureConverter;
	function convertMeasure(measure) {
	    var definition = measure.measure.definition;
	    var convertedDefinition = convertMeasureDefinition(definition);
	    var format = getFormat(measure);
	    var formatProp = format ? { format: format } : {};
	    var alias = measure.measure.alias ? measure.measure.alias : measure.measure.title;
	    var aliasProp = alias ? { alias: alias } : {};
	    return __assign({ localIdentifier: measure.measure.localIdentifier, definition: convertedDefinition }, aliasProp, formatProp);
	}
	function convertMeasureDefinition(definition) {
	    if (typings_1.VisualizationObject.isMeasureDefinition(definition)) {
	        return convertSimpleMeasureDefinition(definition);
	    }
	    else if (typings_1.VisualizationObject.isPopMeasureDefinition(definition)) {
	        return convertPopMeasureDefinition(definition);
	    }
	    else if (typings_1.VisualizationObject.isPreviousPeriodMeasureDefinition(definition)) {
	        return convertPreviousPeriodMeasureDefinition(definition);
	    }
	    else if (typings_1.VisualizationObject.isArithmeticMeasureDefinition(definition)) {
	        return convertArithmeticMeasureDefinition(definition);
	    }
	    else {
	        throw Error("The measure definition is not supported: " + JSON.stringify(definition));
	    }
	}
	function convertSimpleMeasureDefinition(definition) {
	    var measureDefinition = definition.measureDefinition;
	    var filters = measureDefinition.filters
	        ? compact_1.default(measureDefinition.filters.map(FilterConverter_1.convertVisualizationObjectFilter))
	        : [];
	    var filtersProp = filters.length ? { filters: filters } : {};
	    var aggregation = measureDefinition.aggregation;
	    var aggregationProp = aggregation ? { aggregation: aggregation } : {};
	    var computeRatio = measureDefinition.computeRatio;
	    var computeRatioProp = computeRatio ? { computeRatio: computeRatio } : {};
	    return {
	        measure: __assign({ item: measureDefinition.item }, filtersProp, aggregationProp, computeRatioProp),
	    };
	}
	function convertPopMeasureDefinition(definition) {
	    var popMeasureDefinition = definition.popMeasureDefinition;
	    return {
	        popMeasure: {
	            measureIdentifier: popMeasureDefinition.measureIdentifier,
	            popAttribute: popMeasureDefinition.popAttribute,
	        },
	    };
	}
	function convertPreviousPeriodMeasureDefinition(definition) {
	    var previousPeriodMeasure = definition.previousPeriodMeasure;
	    return {
	        previousPeriodMeasure: {
	            measureIdentifier: previousPeriodMeasure.measureIdentifier,
	            dateDataSets: previousPeriodMeasure.dateDataSets.map(function (dateDataSet) { return ({
	                dataSet: dateDataSet.dataSet,
	                periodsAgo: dateDataSet.periodsAgo,
	            }); }),
	        },
	    };
	}
	function convertArithmeticMeasureDefinition(definition) {
	    var arithmeticMeasure = definition.arithmeticMeasure;
	    return {
	        arithmeticMeasure: {
	            measureIdentifiers: arithmeticMeasure.measureIdentifiers.slice(),
	            operator: arithmeticMeasure.operator,
	        },
	    };
	}
	function getFormat(measure) {
	    var _a = measure.measure, definition = _a.definition, format = _a.format;
	    // Override incorrect formats of ad-hoc measures with computeRatio
	    // and use decimal percentage  instead.
	    // This code will be removed once saved viz. objects are fixed in BB-2287
	    if (typings_1.VisualizationObject.isMeasureDefinition(definition)) {
	        var measureDefinition = definition.measureDefinition;
	        if (measureDefinition.computeRatio && measureDefinition.aggregation) {
	            if (measureDefinition.aggregation === "count") {
	                if (format === formats_1.DEFAULT_INTEGER_FORMAT) {
	                    return formats_1.DEFAULT_PERCENTAGE_FORMAT;
	                }
	            }
	            else {
	                if (format === formats_1.DEFAULT_DECIMAL_FORMAT) {
	                    return formats_1.DEFAULT_PERCENTAGE_FORMAT;
	                }
	            }
	        }
	    }
	    if (format) {
	        return format;
	    }
	    var isArithmeticMeasureChange = typings_1.VisualizationObject.isArithmeticMeasureDefinition(definition) &&
	        definition.arithmeticMeasure.operator === "change";
	    if (isArithmeticMeasureChange) {
	        return formats_1.DEFAULT_PERCENTAGE_FORMAT;
	    }
	    if (typings_1.VisualizationObject.isMeasureDefinition(definition)) {
	        var measureDefinition = definition.measureDefinition;
	        if (measureDefinition.computeRatio) {
	            return formats_1.DEFAULT_PERCENTAGE_FORMAT;
	        }
	        if (measureDefinition.aggregation === "count") {
	            return formats_1.DEFAULT_INTEGER_FORMAT;
	        }
	    }
	    return undefined;
	}


/***/ }),
/* 250 */
/***/ (function(module, exports) {

	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	// (C) 2007-2020 GoodData Corporation
	exports.DEFAULT_DECIMAL_FORMAT = "#,##0.00";
	exports.DEFAULT_PERCENTAGE_FORMAT = "#,##0.00%";
	exports.DEFAULT_INTEGER_FORMAT = "#,##0";


/***/ }),
/* 251 */
/***/ (function(module, exports) {

	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	// (C) 2020 GoodData Corporation
	exports.TOOLTIP_TEXT = "tooltipText";
	exports.LOCATION = "location";


/***/ }),
/* 252 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var __assign = (this && this.__assign) || function () {
	    __assign = Object.assign || function(t) {
	        for (var s, i = 1, n = arguments.length; i < n; i++) {
	            s = arguments[i];
	            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
	                t[p] = s[p];
	        }
	        return t;
	    };
	    return __assign.apply(this, arguments);
	};
	Object.defineProperty(exports, "__esModule", { value: true });
	var AfmUtils_1 = __webpack_require__(253);
	/**
	 * Attaches sorts into resultSpec
	 *
	 * @method applySorting
	 * @param {AFM.IResultSpec} resultSpec
	 * @param {AFM.SortItem[]} sortItems
	 * @returns {AFM.IResultSpec}
	 */
	function applySorting(resultSpec, sortItems) {
	    if (resultSpec === void 0) { resultSpec = {}; }
	    if (sortItems === void 0) { sortItems = []; }
	    if (sortItems.length === 0) {
	        return resultSpec;
	    }
	    return __assign({}, resultSpec, { sorts: sortItems });
	}
	exports.applySorting = applySorting;
	function sortItemIsAttribute(sortItem) {
	    return !!sortItem.attributeSortItem;
	}
	function sortItemIsMeasure(sortItem) {
	    return !sortItemIsAttribute(sortItem);
	}
	function locatorIsMeasure(locator) {
	    return !!locator.measureLocatorItem;
	}
	function getSortItemIdentifier(sortItem) {
	    if (sortItemIsAttribute(sortItem)) {
	        return sortItem.attributeSortItem.attributeIdentifier;
	    }
	    if (sortItemIsMeasure(sortItem)) {
	        var locator = sortItem.measureSortItem.locators[0];
	        if (locatorIsMeasure(locator)) {
	            return locator.measureLocatorItem.measureIdentifier;
	        }
	    }
	    return null;
	}
	/**
	 * Returns true if sortItem fits to afm
	 *
	 * @method isSortValid
	 * @param {AFM.IAfm} afm
	 * @param {AFM.SortItem} sortItem
	 * @returns {boolean}
	 */
	function isSortValid(afm, sortItem) {
	    if (!sortItem) {
	        return true;
	    }
	    var sortIdentifier = getSortItemIdentifier(sortItem);
	    var normalizedAfm = AfmUtils_1.normalizeAfm(afm);
	    return (normalizedAfm.measures.some(function (m) { return m.localIdentifier === sortIdentifier; }) ||
	        normalizedAfm.attributes.some(function (a) { return a.localIdentifier === sortIdentifier; }));
	}
	exports.isSortValid = isSortValid;


/***/ }),
/* 253 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var __assign = (this && this.__assign) || function () {
	    __assign = Object.assign || function(t) {
	        for (var s, i = 1, n = arguments.length; i < n; i++) {
	            s = arguments[i];
	            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
	                t[p] = s[p];
	        }
	        return t;
	    };
	    return __assign.apply(this, arguments);
	};
	var __importDefault = (this && this.__importDefault) || function (mod) {
	    return (mod && mod.__esModule) ? mod : { "default": mod };
	};
	Object.defineProperty(exports, "__esModule", { value: true });
	// (C) 2007-2018 GoodData Corporation
	var flatMap_1 = __importDefault(__webpack_require__(248));
	var compact_1 = __importDefault(__webpack_require__(155));
	var typings_1 = __webpack_require__(137);
	exports.ALL_TIME_GRANULARITY = "ALL_TIME_GRANULARITY";
	/**
	 * Unwraps measure object
	 *
	 * @method unwrapSimpleMeasure
	 * @param {AFM.IMeasure} item
	 * @returns {AFM.ISimpleMeasure}
	 */
	function unwrapSimpleMeasure(item) {
	    return item.definition.measure;
	}
	exports.unwrapSimpleMeasure = unwrapSimpleMeasure;
	/**
	 * Unwraps popMeasure object
	 *
	 * @method unwrapPoPMeasure
	 * @param {AFM.IMeasure} item
	 * @returns {AFM.IPopMeasure}
	 */
	function unwrapPoPMeasure(item) {
	    return item.definition.popMeasure;
	}
	exports.unwrapPoPMeasure = unwrapPoPMeasure;
	/**
	 * Unwraps previousPeriodMeasure object
	 *
	 * @method unwrapPreviousPeriodMeasure
	 * @param {AFM.IMeasure} item
	 * @returns {AFM.IPreviousPeriodMeasure}
	 */
	function unwrapPreviousPeriodMeasure(item) {
	    return item.definition.previousPeriodMeasure;
	}
	exports.unwrapPreviousPeriodMeasure = unwrapPreviousPeriodMeasure;
	/**
	 * Unwraps arithmeticMeasure object
	 *
	 * @method unwrapArithmeticMeasure
	 * @param {AFM.IMeasure} item
	 * @returns {AFM.IArithmeticMeasure}
	 */
	function unwrapArithmeticMeasure(item) {
	    return item.definition.arithmeticMeasure;
	}
	exports.unwrapArithmeticMeasure = unwrapArithmeticMeasure;
	/**
	 * Normalize AFM
	 *
	 * @method normalizeAfm
	 * @param {AFM.IAfm} afm
	 * @returns {INormalizedAFM}
	 */
	function normalizeAfm(afm) {
	    return {
	        attributes: afm.attributes || [],
	        measures: afm.measures || [],
	        filters: afm.filters || [],
	        nativeTotals: afm.nativeTotals || [],
	    };
	}
	exports.normalizeAfm = normalizeAfm;
	/**
	 * Returns true if measure is a simple measure
	 *
	 * @method isSimpleMeasure
	 * @param {AFM.IMeasure} item
	 * @returns {boolean}
	 */
	function isSimpleMeasure(item) {
	    return !!unwrapSimpleMeasure(item);
	}
	exports.isSimpleMeasure = isSimpleMeasure;
	/**
	 * Returns true if measure is PeriodOverPeriod
	 *
	 * @method isPoP
	 * @param {AFM.IMeasure} item
	 * @returns {boolean}
	 */
	function isPoP(item) {
	    return !!unwrapPoPMeasure(item);
	}
	exports.isPoP = isPoP;
	/**
	 * Returns true if measure is previous period measure
	 *
	 * @method isPreviousPeriodMeasure
	 * @param {AFM.IMeasure} item
	 * @returns {boolean}
	 */
	function isPreviousPeriodMeasure(item) {
	    return !!unwrapPreviousPeriodMeasure(item);
	}
	exports.isPreviousPeriodMeasure = isPreviousPeriodMeasure;
	/**
	 * Returns true if measure is arithmetic measure
	 *
	 * @method isArithmeticMeasure
	 * @param {AFM.IMeasure} item
	 * @returns {boolean}
	 */
	function isArithmeticMeasure(item) {
	    return !!unwrapArithmeticMeasure(item);
	}
	exports.isArithmeticMeasure = isArithmeticMeasure;
	/**
	 * Returns true if filter is attributeFilter
	 *
	 * @method isAttributeFilter
	 * @param {AFM.FilterItem} filter
	 * @returns {boolean}
	 * @deprecated use AFM.isAttributeFilter instead
	 */
	function isAttributeFilter(filter) {
	    return typings_1.AFM.isAttributeFilter(filter);
	}
	exports.isAttributeFilter = isAttributeFilter;
	/**
	 * Returns true if filter is dateFilter
	 *
	 * @method isDateFilter
	 * @param {AFM.CompatibilityFilter} filter
	 * @returns {boolean}
	 * @deprecated use AFM.isDateFilter instead
	 */
	function isDateFilter(filter) {
	    return typings_1.AFM.isDateFilter(filter);
	}
	exports.isDateFilter = isDateFilter;
	/**
	 * Returns true if filter is negative attribute filter and has no selected elements,
	 * meaning that this is "Select all"
	 *
	 * @method isAttributeFilterSelectAll
	 * @param {AFM.FilterItem} filter
	 * @returns {boolean}
	 */
	function isAttributeFilterSelectAll(filter) {
	    if (typings_1.AFM.isNegativeAttributeFilter(filter)) {
	        return filter.negativeAttributeFilter.notIn.length === 0;
	    }
	    return false;
	}
	exports.isAttributeFilterSelectAll = isAttributeFilterSelectAll;
	/**
	 * Returns true if measure has dateFilters
	 *
	 * @method hasMetricDateFilters
	 * @param {INormalizedAFM} normalizedAfm
	 * @returns {boolean}
	 */
	function hasMetricDateFilters(normalizedAfm) {
	    return normalizedAfm.measures.some(function (measure) {
	        if (isSimpleMeasure(measure)) {
	            var filters = unwrapSimpleMeasure(measure).filters;
	            return !!(filters && filters.some(typings_1.AFM.isDateFilter));
	        }
	        return false;
	    });
	}
	exports.hasMetricDateFilters = hasMetricDateFilters;
	/**
	 * Returns global date filters
	 *
	 * @method getGlobalDateFilters
	 * @param {INormalizedAFM} normalizedAfm
	 * @returns {AFM.DateFilterItem[]}
	 */
	function getGlobalDateFilters(normalizedAfm) {
	    return normalizedAfm.filters.filter(typings_1.AFM.isDateFilter);
	}
	exports.getGlobalDateFilters = getGlobalDateFilters;
	/**
	 * Returns true if measure has filters
	 *
	 * @method hasFilters
	 * @param {AFM.ISimpleMeasure} measure
	 * @returns {boolean}
	 */
	exports.hasFilters = function (measure) {
	    return !!(measure.filters && measure.filters.length > 0);
	};
	/**
	 * Return date filters from AFM
	 *
	 * @method getMeasureDateFilters
	 * @param {AFM.IAfm} normalizedAfm
	 * @returns {AFM.DateFilterItem[]}
	 */
	function getMeasureDateFilters(normalizedAfm) {
	    return flatMap_1.default(normalizedAfm.measures, function (item) {
	        var measure = unwrapSimpleMeasure(item);
	        if (!measure || !exports.hasFilters(measure)) {
	            return [];
	        }
	        return (measure.filters || []).filter(typings_1.AFM.isDateFilter);
	    });
	}
	exports.getMeasureDateFilters = getMeasureDateFilters;
	/**
	 * Return true if AFM has global date filter
	 *
	 * @method hasGlobalDateFilter
	 * @param {INormalizedAFM} afm
	 * @returns {boolean}
	 */
	function hasGlobalDateFilter(afm) {
	    return afm.filters.some(typings_1.AFM.isDateFilter);
	}
	exports.hasGlobalDateFilter = hasGlobalDateFilter;
	/**
	 * Return uri or identifier from ObjQualifier
	 *
	 * @method getId
	 * @param {AFM.ObjQualifier} obj
	 * @returns {string|null}
	 */
	function getId(obj) {
	    if (obj.uri) {
	        return obj.uri;
	    }
	    if (obj.identifier) {
	        return obj.identifier;
	    }
	    return null;
	}
	exports.getId = getId;
	/**
	 * Returns date filter date dataset
	 *
	 * @method getDateFilterDateDataSet
	 * @param {AFM.DateFilterItem} filter
	 * @returns {AFM.ObjQualifier | null }
	 */
	function getDateFilterDateDataSet(filter) {
	    if (typings_1.AFM.isRelativeDateFilter(filter)) {
	        return filter.relativeDateFilter.dataSet;
	    }
	    if (typings_1.AFM.isAbsoluteDateFilter(filter)) {
	        return filter.absoluteDateFilter.dataSet;
	    }
	    throw new Error("Unsupported type of date filter");
	}
	exports.getDateFilterDateDataSet = getDateFilterDateDataSet;
	/**
	 * Returns true if dateFilters dataSets match
	 *
	 * @method dateFiltersDataSetsMatch
	 * @param {AFM.DateFilterItem} f1
	 * @param {AFM.DateFilterItem} f2
	 * @returns {AFM.ObjQualifier | null | boolean}
	 */
	function dateFiltersDataSetsMatch(f1, f2) {
	    var d1 = getDateFilterDateDataSet(f1);
	    var d2 = getDateFilterDateDataSet(f2);
	    return d1 && d2 && getId(d1) === getId(d2);
	}
	exports.dateFiltersDataSetsMatch = dateFiltersDataSetsMatch;
	function isDateFilterAllTime(dateFilter) {
	    if (typings_1.AFM.isRelativeDateFilter(dateFilter)) {
	        return dateFilter.relativeDateFilter.granularity === exports.ALL_TIME_GRANULARITY;
	    }
	    return false;
	}
	/**
	 * Append attribute filters and date filter to afm
	 *
	 * Date filter handling:
	 *      - Override if date filter has the same id
	 *      - Add if date filter if date filter id is different
	 *
	 * Attribute filter handling:
	 *      - Add all
	 *
	 * @method appendFilters
	 * @param {AFM.IAfm} afm
	 * @param {AFM.AttributeFilterItem[]} attributeFilters
	 * @param {AFM.DateFilterItem} dateFilter
	 * @param {AFM.IMeasureValueFilter[]} measureValueFilters
	 * @return {AFM.IAfm}
	 */
	function appendFilters(afm, attributeFilters, dateFilter, measureValueFilters) {
	    var dateFilters = dateFilter && !isDateFilterAllTime(dateFilter) ? [dateFilter] : [];
	    var afmDateFilter = afm.filters ? afm.filters.filter(typings_1.AFM.isDateFilter)[0] : null;
	    // all-time selected, need to delete date filter from filters
	    var afmFilters = afm.filters || [];
	    if (dateFilter && isDateFilterAllTime(dateFilter)) {
	        afmFilters = afmFilters.filter(function (filter) {
	            if (typings_1.AFM.isDateFilter(filter)) {
	                return !dateFiltersDataSetsMatch(filter, dateFilter);
	            }
	            return true;
	        });
	    }
	    if ((afmDateFilter && dateFilter && !dateFiltersDataSetsMatch(afmDateFilter, dateFilter)) ||
	        (afmDateFilter && !dateFilter)) {
	        dateFilters.push(afmDateFilter);
	    }
	    var afmNonDateFilters = afmFilters.filter(function (filter) { return !typings_1.AFM.isDateFilter(filter); });
	    var filters = compact_1.default(afmNonDateFilters.concat(attributeFilters, dateFilters, (measureValueFilters || [])));
	    if (filters.length || (afm.filters && afm.filters.length)) {
	        return __assign({}, afm, { filters: filters });
	    }
	    return afm;
	}
	exports.appendFilters = appendFilters;
	/**
	 * Returns true if AFM is executable
	 *
	 * @method isAfmExecutable
	 * @param {AFM.IAfm} afm
	 * @returns {boolean}
	 */
	function isAfmExecutable(afm) {
	    var normalizedAfm = normalizeAfm(afm);
	    return normalizedAfm.measures.length > 0 || normalizedAfm.attributes.length > 0;
	}
	exports.isAfmExecutable = isAfmExecutable;


/***/ }),
/* 254 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	var __importDefault = (this && this.__importDefault) || function (mod) {
	    return (mod && mod.__esModule) ? mod : { "default": mod };
	};
	Object.defineProperty(exports, "__esModule", { value: true });
	// (C) 2007-2018 GoodData Corporation
	var get_1 = __importDefault(__webpack_require__(89));
	var isEmpty_1 = __importDefault(__webpack_require__(117));
	var isEqual_1 = __importDefault(__webpack_require__(255));
	var AfmUtils_1 = __webpack_require__(253);
	var async_1 = __webpack_require__(215);
	var DataTable = /** @class */ (function () {
	    function DataTable(adapter) {
	        var _this = this;
	        this.dataSubscribers = [];
	        this.errorSubscribers = [];
	        this.adapter = adapter;
	        this.subject = async_1.createSubject(function (result) { return _this.dataSubscribers.forEach(function (handler) { return handler(result); }); }, function (error) { return _this.errorSubscribers.forEach(function (handler) { return handler(error); }); });
	    }
	    DataTable.getDefaultDimensionsForTable = function (afm) {
	        return [
	            {
	                itemIdentifiers: (afm.attributes || []).map(function (a) { return a.localIdentifier; }),
	            },
	            {
	                itemIdentifiers: ["measureGroup"],
	            },
	        ];
	    };
	    DataTable.prototype.getData = function (afm, resultSpec) {
	        var _this = this;
	        if (resultSpec === void 0) { resultSpec = {}; }
	        if (!AfmUtils_1.isAfmExecutable(afm)) {
	            return;
	        }
	        if (isEmpty_1.default(get_1.default(resultSpec, "dimensions"))) {
	            resultSpec.dimensions = DataTable.getDefaultDimensionsForTable(afm);
	        }
	        if (!isEqual_1.default(afm, this.afm)) {
	            this.afm = afm;
	            this.adapter.createDataSource(afm).then(function (dataSource) {
	                _this.dataSource = dataSource;
	                _this.fetchData(resultSpec);
	            }, function (error) {
	                _this.errorSubscribers.forEach(function (handler) { return handler(error); });
	            });
	        }
	        else if (this.dataSource) {
	            this.fetchData(resultSpec);
	        }
	    };
	    DataTable.prototype.onData = function (callback) {
	        this.dataSubscribers.push(callback);
	        return this;
	    };
	    DataTable.prototype.onError = function (callback) {
	        this.errorSubscribers.push(callback);
	        return this;
	    };
	    DataTable.prototype.resetDataSubscribers = function () {
	        this.dataSubscribers = [];
	        return this;
	    };
	    DataTable.prototype.resetErrorSubscribers = function () {
	        this.errorSubscribers = [];
	        return this;
	    };
	    DataTable.prototype.fetchData = function (resultSpec) {
	        if (this.dataSource) {
	            this.subject.next(this.dataSource.getData(resultSpec));
	        }
	    };
	    return DataTable;
	}());
	exports.DataTable = DataTable;


/***/ }),
/* 255 */
/***/ (function(module, exports, __webpack_require__) {

	var baseIsEqual = __webpack_require__(256);

	/**
	 * Performs a deep comparison between two values to determine if they are
	 * equivalent.
	 *
	 * **Note:** This method supports comparing arrays, array buffers, booleans,
	 * date objects, error objects, maps, numbers, `Object` objects, regexes,
	 * sets, strings, symbols, and typed arrays. `Object` objects are compared
	 * by their own, not inherited, enumerable properties. Functions and DOM
	 * nodes are compared by strict equality, i.e. `===`.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Lang
	 * @param {*} value The value to compare.
	 * @param {*} other The other value to compare.
	 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
	 * @example
	 *
	 * var object = { 'a': 1 };
	 * var other = { 'a': 1 };
	 *
	 * _.isEqual(object, other);
	 * // => true
	 *
	 * object === other;
	 * // => false
	 */
	function isEqual(value, other) {
	  return baseIsEqual(value, other);
	}

	module.exports = isEqual;


/***/ }),
/* 256 */
/***/ (function(module, exports, __webpack_require__) {

	var baseIsEqualDeep = __webpack_require__(257),
	    isObjectLike = __webpack_require__(51);

	/**
	 * The base implementation of `_.isEqual` which supports partial comparisons
	 * and tracks traversed objects.
	 *
	 * @private
	 * @param {*} value The value to compare.
	 * @param {*} other The other value to compare.
	 * @param {boolean} bitmask The bitmask flags.
	 *  1 - Unordered comparison
	 *  2 - Partial comparison
	 * @param {Function} [customizer] The function to customize comparisons.
	 * @param {Object} [stack] Tracks traversed `value` and `other` objects.
	 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
	 */
	function baseIsEqual(value, other, bitmask, customizer, stack) {
	  if (value === other) {
	    return true;
	  }
	  if (value == null || other == null || (!isObjectLike(value) && !isObjectLike(other))) {
	    return value !== value && other !== other;
	  }
	  return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);
	}

	module.exports = baseIsEqual;


/***/ }),
/* 257 */
/***/ (function(module, exports, __webpack_require__) {

	var Stack = __webpack_require__(6),
	    equalArrays = __webpack_require__(258),
	    equalByTag = __webpack_require__(260),
	    equalObjects = __webpack_require__(261),
	    getTag = __webpack_require__(36),
	    isArray = __webpack_require__(44),
	    isBuffer = __webpack_require__(45),
	    isTypedArray = __webpack_require__(83);

	/** Used to compose bitmasks for value comparisons. */
	var COMPARE_PARTIAL_FLAG = 1;

	/** `Object#toString` result references. */
	var argsTag = '[object Arguments]',
	    arrayTag = '[object Array]',
	    objectTag = '[object Object]';

	/** Used for built-in method references. */
	var objectProto = Object.prototype;

	/** Used to check objects for own properties. */
	var hasOwnProperty = objectProto.hasOwnProperty;

	/**
	 * A specialized version of `baseIsEqual` for arrays and objects which performs
	 * deep comparisons and tracks traversed objects enabling objects with circular
	 * references to be compared.
	 *
	 * @private
	 * @param {Object} object The object to compare.
	 * @param {Object} other The other object to compare.
	 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
	 * @param {Function} customizer The function to customize comparisons.
	 * @param {Function} equalFunc The function to determine equivalents of values.
	 * @param {Object} [stack] Tracks traversed `object` and `other` objects.
	 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
	 */
	function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {
	  var objIsArr = isArray(object),
	      othIsArr = isArray(other),
	      objTag = objIsArr ? arrayTag : getTag(object),
	      othTag = othIsArr ? arrayTag : getTag(other);

	  objTag = objTag == argsTag ? objectTag : objTag;
	  othTag = othTag == argsTag ? objectTag : othTag;

	  var objIsObj = objTag == objectTag,
	      othIsObj = othTag == objectTag,
	      isSameTag = objTag == othTag;

	  if (isSameTag && isBuffer(object)) {
	    if (!isBuffer(other)) {
	      return false;
	    }
	    objIsArr = true;
	    objIsObj = false;
	  }
	  if (isSameTag && !objIsObj) {
	    stack || (stack = new Stack);
	    return (objIsArr || isTypedArray(object))
	      ? equalArrays(object, other, bitmask, customizer, equalFunc, stack)
	      : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);
	  }
	  if (!(bitmask & COMPARE_PARTIAL_FLAG)) {
	    var objIsWrapped = objIsObj && hasOwnProperty.call(object, '__wrapped__'),
	        othIsWrapped = othIsObj && hasOwnProperty.call(other, '__wrapped__');

	    if (objIsWrapped || othIsWrapped) {
	      var objUnwrapped = objIsWrapped ? object.value() : object,
	          othUnwrapped = othIsWrapped ? other.value() : other;

	      stack || (stack = new Stack);
	      return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
	    }
	  }
	  if (!isSameTag) {
	    return false;
	  }
	  stack || (stack = new Stack);
	  return equalObjects(object, other, bitmask, customizer, equalFunc, stack);
	}

	module.exports = baseIsEqualDeep;


/***/ }),
/* 258 */
/***/ (function(module, exports, __webpack_require__) {

	var SetCache = __webpack_require__(176),
	    arraySome = __webpack_require__(259),
	    cacheHas = __webpack_require__(181);

	/** Used to compose bitmasks for value comparisons. */
	var COMPARE_PARTIAL_FLAG = 1,
	    COMPARE_UNORDERED_FLAG = 2;

	/**
	 * A specialized version of `baseIsEqualDeep` for arrays with support for
	 * partial deep comparisons.
	 *
	 * @private
	 * @param {Array} array The array to compare.
	 * @param {Array} other The other array to compare.
	 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
	 * @param {Function} customizer The function to customize comparisons.
	 * @param {Function} equalFunc The function to determine equivalents of values.
	 * @param {Object} stack Tracks traversed `array` and `other` objects.
	 * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.
	 */
	function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {
	  var isPartial = bitmask & COMPARE_PARTIAL_FLAG,
	      arrLength = array.length,
	      othLength = other.length;

	  if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
	    return false;
	  }
	  // Assume cyclic values are equal.
	  var stacked = stack.get(array);
	  if (stacked && stack.get(other)) {
	    return stacked == other;
	  }
	  var index = -1,
	      result = true,
	      seen = (bitmask & COMPARE_UNORDERED_FLAG) ? new SetCache : undefined;

	  stack.set(array, other);
	  stack.set(other, array);

	  // Ignore non-index properties.
	  while (++index < arrLength) {
	    var arrValue = array[index],
	        othValue = other[index];

	    if (customizer) {
	      var compared = isPartial
	        ? customizer(othValue, arrValue, index, other, array, stack)
	        : customizer(arrValue, othValue, index, array, other, stack);
	    }
	    if (compared !== undefined) {
	      if (compared) {
	        continue;
	      }
	      result = false;
	      break;
	    }
	    // Recursively compare arrays (susceptible to call stack limits).
	    if (seen) {
	      if (!arraySome(other, function(othValue, othIndex) {
	            if (!cacheHas(seen, othIndex) &&
	                (arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
	              return seen.push(othIndex);
	            }
	          })) {
	        result = false;
	        break;
	      }
	    } else if (!(
	          arrValue === othValue ||
	            equalFunc(arrValue, othValue, bitmask, customizer, stack)
	        )) {
	      result = false;
	      break;
	    }
	  }
	  stack['delete'](array);
	  stack['delete'](other);
	  return result;
	}

	module.exports = equalArrays;


/***/ }),
/* 259 */
/***/ (function(module, exports) {

	/**
	 * A specialized version of `_.some` for arrays without support for iteratee
	 * shorthands.
	 *
	 * @private
	 * @param {Array} [array] The array to iterate over.
	 * @param {Function} predicate The function invoked per iteration.
	 * @returns {boolean} Returns `true` if any element passes the predicate check,
	 *  else `false`.
	 */
	function arraySome(array, predicate) {
	  var index = -1,
	      length = array == null ? 0 : array.length;

	  while (++index < length) {
	    if (predicate(array[index], index, array)) {
	      return true;
	    }
	  }
	  return false;
	}

	module.exports = arraySome;


/***/ }),
/* 260 */
/***/ (function(module, exports) {

	/**
	 * Performs a
	 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
	 * comparison between two values to determine if they are equivalent.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to compare.
	 * @param {*} other The other value to compare.
	 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
	 * @example
	 *
	 * var object = { 'a': 1 };
	 * var other = { 'a': 1 };
	 *
	 * _.eq(object, object);
	 * // => true
	 *
	 * _.eq(object, other);
	 * // => false
	 *
	 * _.eq('a', 'a');
	 * // => true
	 *
	 * _.eq('a', Object('a'));
	 * // => false
	 *
	 * _.eq(NaN, NaN);
	 * // => true
	 */
	function eq(value, other) {
	  return value === other || (value !== value && other !== other);
	}

	module.exports = eq;


/***/ }),
/* 261 */
/***/ (function(module, exports, __webpack_require__) {

	var getAllKeys = __webpack_require__(34);

	/** Used to compose bitmasks for value comparisons. */
	var COMPARE_PARTIAL_FLAG = 1;

	/** Used for built-in method references. */
	var objectProto = Object.prototype;

	/** Used to check objects for own properties. */
	var hasOwnProperty = objectProto.hasOwnProperty;

	/**
	 * A specialized version of `baseIsEqualDeep` for objects with support for
	 * partial deep comparisons.
	 *
	 * @private
	 * @param {Object} object The object to compare.
	 * @param {Object} other The other object to compare.
	 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
	 * @param {Function} customizer The function to customize comparisons.
	 * @param {Function} equalFunc The function to determine equivalents of values.
	 * @param {Object} stack Tracks traversed `object` and `other` objects.
	 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
	 */
	function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {
	  var isPartial = bitmask & COMPARE_PARTIAL_FLAG,
	      objProps = getAllKeys(object),
	      objLength = objProps.length,
	      othProps = getAllKeys(other),
	      othLength = othProps.length;

	  if (objLength != othLength && !isPartial) {
	    return false;
	  }
	  var index = objLength;
	  while (index--) {
	    var key = objProps[index];
	    if (!(isPartial ? key in other : hasOwnProperty.call(other, key))) {
	      return false;
	    }
	  }
	  // Assume cyclic values are equal.
	  var stacked = stack.get(object);
	  if (stacked && stack.get(other)) {
	    return stacked == other;
	  }
	  var result = true;
	  stack.set(object, other);
	  stack.set(other, object);

	  var skipCtor = isPartial;
	  while (++index < objLength) {
	    key = objProps[index];
	    var objValue = object[key],
	        othValue = other[key];

	    if (customizer) {
	      var compared = isPartial
	        ? customizer(othValue, objValue, key, other, object, stack)
	        : customizer(objValue, othValue, key, object, other, stack);
	    }
	    // Recursively compare objects (susceptible to call stack limits).
	    if (!(compared === undefined
	          ? (objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack))
	          : compared
	        )) {
	      result = false;
	      break;
	    }
	    skipCtor || (skipCtor = key == 'constructor');
	  }
	  if (result && !skipCtor) {
	    var objCtor = object.constructor,
	        othCtor = other.constructor;

	    // Non `Object` object instances with different constructors are not equal.
	    if (objCtor != othCtor &&
	        ('constructor' in object && 'constructor' in other) &&
	        !(typeof objCtor == 'function' && objCtor instanceof objCtor &&
	          typeof othCtor == 'function' && othCtor instanceof othCtor)) {
	      result = false;
	    }
	  }
	  stack['delete'](object);
	  stack['delete'](other);
	  return result;
	}

	module.exports = equalObjects;


/***/ }),
/* 262 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var DummyDataSource_1 = __webpack_require__(263);
	var DummyAdapter = /** @class */ (function () {
	    // Intentional any
	    function DummyAdapter(data, success, dataSource) {
	        if (success === void 0) { success = true; }
	        if (dataSource === void 0) { dataSource = null; }
	        this.data = data;
	        this.success = success;
	        this.dataSource = dataSource;
	    }
	    DummyAdapter.prototype.createDataSource = function (_afm) {
	        return this.dataSource
	            ? Promise.resolve(this.dataSource)
	            : Promise.resolve(new DummyDataSource_1.DummyDataSource(this.data, this.success));
	    };
	    return DummyAdapter;
	}());
	exports.DummyAdapter = DummyAdapter;


/***/ }),
/* 263 */
/***/ (function(module, exports) {

	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	function getExecutionResponse(numOfDimensions) {
	    if (numOfDimensions === void 0) { numOfDimensions = 2; }
	    var dimension = { headers: [] };
	    return {
	        dimensions: Array(numOfDimensions).fill(dimension),
	        links: {
	            executionResult: "/gdc/app/projects/myFakeProjectId/executionResults/123?limit=overridden&dimensions=" + numOfDimensions,
	        },
	    };
	}
	function getExecutionResult() {
	    return {
	        data: [
	            [11, 12],
	            [51, 52],
	        ],
	        paging: {
	            count: [2, 2],
	            offset: [0, 0],
	            total: [2, 2],
	        },
	        headerItems: [
	            [
	                [
	                    {
	                        attributeHeaderItem: {
	                            name: "A1",
	                            uri: "/gdc/md/obj/attr1",
	                        },
	                    },
	                    {
	                        attributeHeaderItem: {
	                            name: "A2",
	                            uri: "/gdc/md/obj/attr2",
	                        },
	                    },
	                ],
	            ],
	            [
	                [
	                    {
	                        measureHeaderItem: {
	                            name: "M1",
	                            order: 0,
	                        },
	                    },
	                    {
	                        measureHeaderItem: {
	                            name: "M2",
	                            order: 0,
	                        },
	                    },
	                ],
	            ],
	        ],
	    };
	}
	var DummyDataSource = /** @class */ (function () {
	    function DummyDataSource(data, resolve) {
	        if (resolve === void 0) { resolve = true; }
	        this.data = data;
	        this.resolve = resolve;
	        this.resultSpec = {};
	    }
	    DummyDataSource.prototype.getData = function (resultSpec) {
	        this.resultSpec = resultSpec;
	        if (this.resolve) {
	            return Promise.resolve(this.data);
	        }
	        return Promise.reject("DummyDataSource reject");
	    };
	    DummyDataSource.prototype.getPage = function (resultSpec, _limit, _offset) {
	        this.resultSpec = resultSpec;
	        if (this.resolve) {
	            return Promise.resolve({
	                executionResponse: getExecutionResponse(2),
	                executionResult: getExecutionResult(),
	            });
	        }
	        return Promise.reject("DummyDataSource reject");
	    };
	    DummyDataSource.prototype.getFingerprint = function () {
	        return "";
	    };
	    DummyDataSource.prototype.getResultSpec = function () {
	        return this.resultSpec;
	    };
	    DummyDataSource.prototype.getAfm = function () {
	        return {};
	    };
	    return DummyDataSource;
	}());
	exports.DummyDataSource = DummyDataSource;


/***/ }),
/* 264 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var DataSource_1 = __webpack_require__(212);
	var package_json_1 = __webpack_require__(92);
	var ExecuteAfmAdapter = /** @class */ (function () {
	    function ExecuteAfmAdapter(sdk, projectId) {
	        this.projectId = projectId;
	        this.sdk = sdk.clone();
	        this.sdk.config.setJsPackage("@gooddata/data-layer", package_json_1.version);
	    }
	    ExecuteAfmAdapter.prototype.createDataSource = function (afm, fingerprint) {
	        var _this = this;
	        var execFactory = function (resultSpec) {
	            var execution = {
	                execution: {
	                    afm: afm,
	                    resultSpec: resultSpec,
	                },
	            };
	            return _this.sdk.execution.executeAfm(_this.projectId, execution);
	        };
	        var responseFactory = function (resultSpec) {
	            var execution = {
	                execution: {
	                    afm: afm,
	                    resultSpec: resultSpec,
	                },
	            };
	            return _this.sdk.execution.getExecutionResponse(_this.projectId, execution);
	        };
	        var resultFactory = this.sdk.execution.getPartialExecutionResult;
	        var dataSource = new DataSource_1.DataSource(execFactory, afm, fingerprint, responseFactory, resultFactory);
	        return Promise.resolve(dataSource);
	    };
	    return ExecuteAfmAdapter;
	}());
	exports.ExecuteAfmAdapter = ExecuteAfmAdapter;


/***/ }),
/* 265 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var ExecuteAfmAdapter_1 = __webpack_require__(264);
	var toAfmResultSpec_1 = __webpack_require__(247);
	var AfmUtils_1 = __webpack_require__(253);
	var package_json_1 = __webpack_require__(92);
	function defaultExecuteAdapterFactory(sdk, projectId) {
	    return new ExecuteAfmAdapter_1.ExecuteAfmAdapter(sdk, projectId);
	}
	var UriAdapter = /** @class */ (function () {
	    function UriAdapter(sdk, projectId, executeAdapterFactory) {
	        if (executeAdapterFactory === void 0) { executeAdapterFactory = defaultExecuteAdapterFactory; }
	        this.projectId = projectId;
	        this.executeAdapterFactory = executeAdapterFactory;
	        this.sdk = sdk.clone();
	        this.sdk.config.setJsPackage("@gooddata/data-layer", package_json_1.version);
	    }
	    UriAdapter.prototype.createDataSource = function (sourceParams) {
	        var _this = this;
	        return this.fetchVisualizationObject(sourceParams.uri).then(function (visualizationObject) {
	            var content = visualizationObject.visualizationObject.content;
	            var _a = toAfmResultSpec_1.toAfmResultSpec(content), afm = _a.afm, resultSpec = _a.resultSpec;
	            var afmWithAttributeFilters = AfmUtils_1.appendFilters(afm, sourceParams.attributeFilters || [], sourceParams.dateFilter);
	            var executeAdapter = _this.executeAdapterFactory(_this.sdk, _this.projectId);
	            var execution = {
	                execution: {
	                    afm: afmWithAttributeFilters,
	                    resultSpec: resultSpec,
	                },
	            };
	            return executeAdapter.createDataSource(execution);
	        });
	    };
	    UriAdapter.prototype.fetchVisualizationObject = function (uri) {
	        var _this = this;
	        if (uri === this.uri && this.visualizationObject) {
	            return Promise.resolve(this.visualizationObject);
	        }
	        return this.sdk.xhr.get(uri).then(function (response) {
	            var visObject = response.data;
	            _this.uri = uri;
	            _this.visualizationObject = visObject;
	            return visObject;
	        });
	    };
	    return UriAdapter;
	}());
	exports.UriAdapter = UriAdapter;


/***/ }),
/* 266 */
/***/ (function(module, exports) {

	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });


/***/ }),
/* 267 */
/***/ (function(module, exports) {

	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var isValidColorItem = function (value) {
	    return !!(value && value.type && value.value !== undefined);
	};
	exports.isGuidColorItem = function (color) {
	    return isValidColorItem(color) && color.type === "guid";
	};
	exports.isRgbColorItem = function (color) {
	    return isValidColorItem(color) && color.type === "rgb";
	};
	function isApiExecutionResponseError(error) {
	    return !!error.executionResponse;
	}
	exports.isApiExecutionResponseError = isApiExecutionResponseError;


/***/ }),
/* 268 */
/***/ (function(module, exports) {

	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });


/***/ })
/******/ ])
});
;