"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
Object.defineProperty(exports, "__esModule", { value: true });
// (C) 2019-2020 GoodData Corporation
var cloneDeep = require("lodash/cloneDeep");
var get = require("lodash/get");
var merge = require("lodash/merge");
var flatMap = require("lodash/flatMap");
var isNil = require("lodash/isNil");
var includes = require("lodash/includes");
var React = require("react");
var react_measure_1 = require("react-measure");
var react_dom_1 = require("react-dom");
var typings_1 = require("@gooddata/typings");
var immer_1 = require("immer");
var bucketConfig_1 = require("../../../utils/bucketConfig");
var UnsupportedConfigurationPanel_1 = require("../../configurationPanels/UnsupportedConfigurationPanel");
var domHelper_1 = require("../../../utils/domHelper");
var BucketNames = require("../../../../constants/bucketNames");
var Visualization_1 = require("../../../interfaces/Visualization");
var bucket_1 = require("../../../constants/bucket");
var bucketHelper_1 = require("../../../utils/bucketHelper");
var pivotTableUiConfigHelper_1 = require("../../../utils/uiConfigHelpers/pivotTableUiConfigHelper");
var internalIntlProvider_1 = require("../../../utils/internalIntlProvider");
var uiConfig_1 = require("../../../constants/uiConfig");
var AbstractPluggableVisualization_1 = require("../AbstractPluggableVisualization");
var propertiesHelper_1 = require("../../../utils/propertiesHelper");
var visualizationTypes_1 = require("../../../../constants/visualizationTypes");
var PivotTable_1 = require("../../../../components/core/PivotTable");
var dimensions_1 = require("../../../../helpers/dimensions");
var localization_1 = require("../../../../constants/localization");
var properties_1 = require("../../../constants/properties");
exports.getColumnAttributes = function (buckets) {
    return bucketHelper_1.getItemsFromBuckets(buckets, [BucketNames.COLUMNS, BucketNames.STACK, BucketNames.SEGMENT], [bucket_1.ATTRIBUTE, bucket_1.DATE]);
};
exports.getRowAttributes = function (buckets) {
    return bucketHelper_1.getItemsFromBuckets(buckets, [
        BucketNames.ATTRIBUTE,
        BucketNames.ATTRIBUTES,
        BucketNames.VIEW,
        BucketNames.TREND,
        BucketNames.LOCATION,
    ], [bucket_1.ATTRIBUTE, bucket_1.DATE]);
};
// removes attribute sortItems with invalid identifiers
// removes measure sortItems with invalid identifiers and invalid number of locators
function adaptSortItemsToPivotTable(originalSortItems, measureLocalIdentifiers, rowAttributeLocalIdentifiers, columnAttributeLocalIdentifiers) {
    var attributeLocalIdentifiers = rowAttributeLocalIdentifiers.concat(columnAttributeLocalIdentifiers);
    return originalSortItems.reduce(function (sortItems, sortItem) {
        if (typings_1.AFM.isMeasureSortItem(sortItem)) {
            // filter out invalid locators
            var filteredSortItem = {
                measureSortItem: __assign({}, sortItem.measureSortItem, { locators: sortItem.measureSortItem.locators.filter(function (locator) {
                        // filter out invalid measure locators
                        if (typings_1.AFM.isMeasureLocatorItem(locator)) {
                            return includes(measureLocalIdentifiers, locator.measureLocatorItem.measureIdentifier);
                        }
                        // filter out invalid column attribute locators
                        return includes(columnAttributeLocalIdentifiers, locator.attributeLocatorItem.attributeIdentifier);
                    }) }),
            };
            // keep sortItem if measureLocator is present and locators are correct length
            if (filteredSortItem.measureSortItem.locators.some(function (locator) {
                return typings_1.AFM.isMeasureLocatorItem(locator);
            }) &&
                filteredSortItem.measureSortItem.locators.length ===
                    columnAttributeLocalIdentifiers.length + 1) {
                return sortItems.concat([filteredSortItem]);
            }
            // otherwise just carry over previous sortItems
            return sortItems;
        }
        if (includes(attributeLocalIdentifiers, sortItem.attributeSortItem.attributeIdentifier)) {
            return sortItems.concat([sortItem]);
        }
        return sortItems;
    }, []);
}
function adaptReferencePointSortItemsToPivotTable(originalSortItems, measures, rowAttributes, columnAttributes) {
    var measureLocalIdentifiers = measures.map(function (measure) { return measure.localIdentifier; });
    var rowAttributeLocalIdentifiers = rowAttributes.map(function (rowAttribute) { return rowAttribute.localIdentifier; });
    var columnAttributeLocalIdentifiers = columnAttributes.map(function (columnAttribute) { return columnAttribute.localIdentifier; });
    return adaptSortItemsToPivotTable(originalSortItems, measureLocalIdentifiers, rowAttributeLocalIdentifiers, columnAttributeLocalIdentifiers);
}
exports.adaptReferencePointSortItemsToPivotTable = adaptReferencePointSortItemsToPivotTable;
var bucketItemGetter = function (bucketId) { return function (buckets) { return flatMap(buckets.filter(function (b) { return b.localIdentifier === bucketId; }), function (i) { return i.items; }); }; };
var getMeasures = bucketItemGetter(BucketNames.MEASURES);
var getRows = bucketItemGetter(BucketNames.ATTRIBUTE);
var getColumns = bucketItemGetter(BucketNames.COLUMNS);
function adaptMdObjectSortItemsToPivotTable(originalSortItems, buckets) {
    var measureLocalIdentifiers = getMeasures(buckets).map(function (measure) { return measure.measure.localIdentifier; });
    var rowAttributeLocalIdentifiers = getRows(buckets).map(function (rowAttribute) { return rowAttribute.visualizationAttribute.localIdentifier; });
    var columnAttributeLocalIdentifiers = getColumns(buckets).map(function (columnAttribute) { return columnAttribute.visualizationAttribute.localIdentifier; });
    return adaptSortItemsToPivotTable(originalSortItems, measureLocalIdentifiers, rowAttributeLocalIdentifiers, columnAttributeLocalIdentifiers);
}
var isAttributeSortItemVisible = function (_sortItem, _filters) {
    return true;
};
var isMeasureSortItemMatchedByFilter = function (sortItem, filter) {
    return filter.selectedElements.some(function (selectedElement) {
        return sortItem.measureSortItem.locators.some(function (locator) {
            return !typings_1.AFM.isMeasureLocatorItem(locator) &&
                locator.attributeLocatorItem.element === selectedElement.uri;
        });
    });
};
var isMeasureSortItemVisible = function (sortItem, filters) {
    return filters.reduce(function (isVisible, filter) {
        if (Visualization_1.isAttributeFilter(filter)) {
            var shouldBeMatched = !filter.isInverted;
            return isVisible && shouldBeMatched === isMeasureSortItemMatchedByFilter(sortItem, filter);
        }
        return isVisible;
    }, true);
};
exports.isSortItemVisible = function (sortItem, filters) {
    return typings_1.AFM.isAttributeSortItem(sortItem)
        ? isAttributeSortItemVisible(sortItem, filters)
        : isMeasureSortItemVisible(sortItem, filters);
};
function addDefaultSort(sortItems, filters, rowAttributes, previousRowAttributes) {
    // cannot construct default sort without a row
    if (rowAttributes.length < 1) {
        return sortItems;
    }
    // detect custom sort
    var firstRow = rowAttributes[0];
    var previousFirstRow = previousRowAttributes && previousRowAttributes[0];
    var hasVisibleCustomSort = sortItems.some(function (sortItem) {
        if (!exports.isSortItemVisible(sortItem, filters)) {
            return false;
        }
        // non attribute sort is definitely custom
        if (!typings_1.AFM.isAttributeSortItem(sortItem)) {
            return true;
        }
        // asc sort on first row is considered default
        if (sortItem.attributeSortItem.attributeIdentifier === firstRow.localIdentifier &&
            sortItem.attributeSortItem.direction === "asc") {
            return false;
        }
        // asc sort on row that was first until now is considered default as well
        if (previousFirstRow &&
            sortItem.attributeSortItem.attributeIdentifier === previousFirstRow.localIdentifier &&
            sortItem.attributeSortItem.direction === "asc") {
            return false;
        }
        return true;
    });
    return hasVisibleCustomSort
        ? sortItems
        : [
            {
                attributeSortItem: {
                    attributeIdentifier: firstRow.localIdentifier,
                    direction: "asc",
                },
            },
        ];
}
exports.addDefaultSort = addDefaultSort;
var PluggablePivotTable = /** @class */ (function (_super) {
    __extends(PluggablePivotTable, _super);
    function PluggablePivotTable(props) {
        var _this = _super.call(this) || this;
        _this.projectId = props.projectId;
        _this.element = props.element;
        _this.configPanelElement = props.configPanelElement;
        _this.callbacks = props.callbacks;
        _this.locale = props.locale || localization_1.DEFAULT_LOCALE;
        _this.intl = internalIntlProvider_1.createInternalIntl(_this.locale);
        _this.onExportReady = props.callbacks.onExportReady && _this.onExportReady.bind(_this);
        _this.environment = props.environment;
        _this.featureFlags = props.featureFlags || {};
        return _this;
    }
    PluggablePivotTable.prototype.unmount = function () {
        domHelper_1.unmountComponentsAtNodes([this.element, this.configPanelElement]);
    };
    PluggablePivotTable.prototype.update = function (options, visualizationProperties, mdObject) {
        this.visualizationProperties = visualizationProperties;
        this.renderVisualization(options, visualizationProperties, mdObject);
        this.renderConfigurationPanel(mdObject);
    };
    PluggablePivotTable.prototype.getExtendedReferencePoint = function (referencePoint, previousReferencePoint) {
        var _this = this;
        return Promise.resolve(immer_1.default(referencePoint, function (referencePointDraft) {
            referencePointDraft.uiConfig = cloneDeep(uiConfig_1.DEFAULT_PIVOT_TABLE_UICONFIG);
            var buckets = referencePointDraft.buckets;
            var measures = bucketHelper_1.getAllItemsByType(buckets, [bucket_1.METRIC]);
            var rowAttributes = exports.getRowAttributes(buckets);
            var previousRowAttributes = previousReferencePoint && exports.getRowAttributes(previousReferencePoint.buckets);
            var columnAttributes = exports.getColumnAttributes(buckets);
            var totals = bucketHelper_1.getTotalsFromBucket(buckets, BucketNames.ATTRIBUTE);
            referencePointDraft.buckets = bucketHelper_1.removeDuplicateBucketItems([
                {
                    localIdentifier: BucketNames.MEASURES,
                    items: measures,
                },
                __assign({ localIdentifier: BucketNames.ATTRIBUTE, items: rowAttributes }, (totals.length > 0 ? { totals: totals } : null)),
                {
                    localIdentifier: BucketNames.COLUMNS,
                    items: columnAttributes,
                },
            ]);
            var originalSortItems = get(referencePointDraft.properties, "sortItems", []);
            referencePointDraft.properties = {
                sortItems: addDefaultSort(adaptReferencePointSortItemsToPivotTable(originalSortItems, measures, rowAttributes, columnAttributes), referencePointDraft.filters
                    ? flatMap(referencePointDraft.filters.items, function (item) { return item.filters; })
                    : [], rowAttributes, previousRowAttributes),
            };
            pivotTableUiConfigHelper_1.setPivotTableUiConfig(referencePointDraft, _this.intl, visualizationTypes_1.VisualizationTypes.TABLE);
            bucketConfig_1.configurePercent(referencePointDraft, false);
            bucketConfig_1.configureOverTimeComparison(referencePointDraft, !!_this.featureFlags.enableWeekFilters);
            Object.assign(referencePointDraft, propertiesHelper_1.getReferencePointWithSupportedProperties(referencePointDraft, _this.supportedPropertiesList));
            referencePointDraft.filters = bucketHelper_1.sanitizeFilters(referencePointDraft).filters;
        }));
    };
    PluggablePivotTable.prototype.getExtendedPivotTableProps = function (pivotTableProps, config) {
        return __assign({}, pivotTableProps, { config: config });
    };
    PluggablePivotTable.prototype.renderVisualization = function (options, visualizationProperties, mdObject) {
        var _this = this;
        var dataSource = options.dataSource;
        if (dataSource) {
            var resultSpec = options.resultSpec, locale = options.locale, custom = options.custom, dimensions = options.dimensions, config = options.config;
            var height = dimensions.height;
            var drillableItems = custom.drillableItems;
            var _a = this.callbacks, afterRender = _a.afterRender, onError = _a.onError, onLoadingChanged = _a.onLoadingChanged, pushData = _a.pushData, onDrill = _a.onDrill, onFiredDrillEvent = _a.onFiredDrillEvent;
            var resultSpecWithDimensions = __assign({}, resultSpec, { dimensions: this.getDimensions(mdObject) });
            var sorts = get(visualizationProperties, "sortItems", []);
            var resultSpecWithSorts = resultSpecWithDimensions.sorts
                ? resultSpecWithDimensions
                : __assign({}, resultSpecWithDimensions, { sorts: sorts });
            var rowsBucket = mdObject.buckets.find(function (bucket) { return bucket.localIdentifier === BucketNames.ATTRIBUTE; });
            var totals = (rowsBucket && rowsBucket.totals) || [];
            var updatedConfig_1 = this.enrichConfigWithColumnSizing(this.enrichConfigWithMenu(config));
            var pivotTableProps_1 = {
                projectId: this.projectId,
                drillableItems: drillableItems,
                onDrill: onDrill,
                onFiredDrillEvent: onFiredDrillEvent,
                totals: totals,
                config: updatedConfig_1,
                height: height,
                locale: locale,
                dataSource: dataSource,
                resultSpec: resultSpecWithSorts,
                afterRender: afterRender,
                onLoadingChanged: onLoadingChanged,
                pushData: pushData,
                onError: onError,
                onExportReady: this.onExportReady,
                LoadingComponent: null,
                ErrorComponent: null,
                intl: this.intl,
            };
            if (this.environment === properties_1.DASHBOARDS_ENVIRONMENT) {
                if (isNil(height)) {
                    react_dom_1.render(React.createElement(react_measure_1.default, { client: true }, function (_a) {
                        var measureRef = _a.measureRef, contentRect = _a.contentRect;
                        var clientHeight = contentRect.client.height;
                        var usedHeight = Math.floor(clientHeight || 0);
                        var pivotWrapperStyle = {
                            height: "100%",
                            textAlign: "left",
                        };
                        var extendedPivotTableProps = _this.getExtendedPivotTableProps(pivotTableProps_1, __assign({}, updatedConfig_1, { maxHeight: clientHeight }));
                        return (React.createElement("div", { ref: measureRef, style: pivotWrapperStyle, className: "gd-table-dashboard-wrapper" },
                            React.createElement(PivotTable_1.PivotTable, __assign({}, extendedPivotTableProps, { height: usedHeight }))));
                    }), document.querySelector(this.element));
                    return;
                }
                react_dom_1.render(React.createElement(react_measure_1.default, { client: true }, function (_a) {
                    var measureRef = _a.measureRef, contentRect = _a.contentRect;
                    var extendedPivotTableProps = _this.getExtendedPivotTableProps(pivotTableProps_1, __assign({}, updatedConfig_1, { maxHeight: contentRect.client.height }));
                    return (React.createElement("div", { ref: measureRef, style: { height: 328, textAlign: "left" }, className: "gd-table-dashboard-wrapper" },
                        React.createElement(PivotTable_1.PivotTable, __assign({}, extendedPivotTableProps))));
                }), document.querySelector(this.element));
            }
            else {
                react_dom_1.render(React.createElement(PivotTable_1.PivotTable, __assign({}, pivotTableProps_1)), document.querySelector(this.element));
            }
        }
    };
    PluggablePivotTable.prototype.onExportReady = function (exportResult) {
        var onExportReady = this.callbacks.onExportReady;
        if (onExportReady) {
            onExportReady(exportResult);
        }
    };
    PluggablePivotTable.prototype.renderConfigurationPanel = function (mdObject) {
        if (document.querySelector(this.configPanelElement)) {
            var properties = get(this.visualizationProperties, "properties", {});
            // we need to handle cases when attribute previously bearing the default sort is no longer available
            var sanitizedProperties = properties.sortItems
                ? __assign({}, properties, { sortItems: adaptMdObjectSortItemsToPivotTable(properties.sortItems, mdObject.buckets) }) : properties;
            react_dom_1.render(React.createElement(UnsupportedConfigurationPanel_1.default, { locale: this.locale, pushData: this.callbacks.pushData, properties: sanitizedProperties }), document.querySelector(this.configPanelElement));
        }
    };
    PluggablePivotTable.prototype.getDimensions = function (mdObject) {
        return dimensions_1.generateDimensions(mdObject, visualizationTypes_1.VisualizationTypes.TABLE);
    };
    PluggablePivotTable.prototype.enrichConfigWithMenu = function (config) {
        if (this.environment === properties_1.DASHBOARDS_ENVIRONMENT) {
            // Menu aggregations turned off in KD
            return config;
        }
        var menu = {
            aggregations: true,
            aggregationsSubMenu: true,
        };
        return merge({ menu: menu }, config);
    };
    PluggablePivotTable.prototype.enrichConfigWithColumnSizing = function (config) {
        var result = this.enrichConfigWithAutosize(config);
        return this.enrichConfigWithGrowToFit(result);
    };
    PluggablePivotTable.prototype.enrichConfigWithAutosize = function (config) {
        if (!this.featureFlags.enableTableColumnsAutoResizing) {
            return config;
        }
        var columnSizing = { defaultWidth: "viewport" };
        return merge(config, { columnSizing: columnSizing });
    };
    PluggablePivotTable.prototype.enrichConfigWithGrowToFit = function (config) {
        if (this.environment === properties_1.DASHBOARDS_ENVIRONMENT) {
            if (!this.featureFlags.enableTableColumnsGrowToFit) {
                return config;
            }
            var columnSizing = merge(config.columnSizing, { growToFit: true });
            return merge(config, { columnSizing: columnSizing });
        }
        return config;
    };
    return PluggablePivotTable;
}(AbstractPluggableVisualization_1.AbstractPluggableVisualization));
exports.PluggablePivotTable = PluggablePivotTable;
//# sourceMappingURL=PluggablePivotTable.js.map